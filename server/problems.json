{"content": [{"id": 1, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt; \nusing namespace std;\n\nvoid f(int x, int y) {\n\tcout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; &quot;y=&quot; &lt;&lt; y &lt;&lt; endl;\n}\n\nvoid f(int x, double y) {\n\tcout &lt;&lt; &quot;x+y=&quot; &lt;&lt; x + y &lt;&lt; endl;\n}\n\nint main()\n{\n\tf(1.5, 2);\n\tf(4, 2.4);\n\treturn 0;\n}</code></pre>", "solution": "<div><div>\nProgramul funtioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>x=1 y=2\nx+y=6.4</samp>\n<div>\nFunctia f este supraincarcata. La linia 14: <pre class='inline'><code class='language-cpp'>f(1.5, 2);</code></pre> se apeleaza prima functie iar la linia 16: <pre class='inline'><code class='language-cpp'>f(4, 2.4)</code></pre> se apeleaza a doua. De ce? \n</div>\n<div>\nSa ne uitam la <pre class='inline'><code class='language-cpp'>f(1.5, 2);</code></pre>. Ambele functii, <pre class='inline'><code class='language-cpp'>void f(int x, int y)</code></pre> si <pre class='inline'><code class='language-cpp'>void f(int x, double y)</code></pre> au ca prim parametru o variabila de tip <pre class='inline'><code class='language-cpp'>int</code></pre> deci ambele functii convertesc 1.5 la 1 (de la <pre class='inline'><code class='language-cpp'>double</code></pre> la <pre class='inline'><code class='language-cpp'>int</code></pre>).\n</div>\n<div>\nAl doilea parametru din prima functie este de tip <pre class='inline'><code class='language-cpp'>int</code></pre> care se potriveste perfect cu ce avem. Al doilea parametru din a doua functie este de tip <pre class='inline'><code class='language-cpp'>double</code></pre> deci trebuie o conversie de la <pre class='inline'><code class='language-cpp'>int</code></pre> la <pre class='inline'><code class='language-cpp'>double</code></pre>, adica munca in plus. Deci prima functie este aleasa.\n</div>\n<div>\nSimilar se comporta linia 15: <pre class='inline'><code class='language-cpp'>f(4, 2.4);</code></pre>. Pentru mai multe detalii legat de cum se alege o functie daca este supraincarcata si are mai multe variante vezi ce am scris <a href='./tips.html#function-overloading'>aici</a>.\n</div></div>", "tags": ["easy", "correct", "function overloading", "implicit cast"]}, {"id": 2, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt; \nusing namespace std;\n\nvoid f(double x, int y) {\n\tcout &lt;&lt; &quot;x * y =&quot; &lt;&lt; x + y &lt;&lt; endl;\n}\n\nvoid f(int x, double y) {\n\tcout &lt;&lt; &quot;x + y =&quot; &lt;&lt; x + y &lt;&lt; endl;\n}\n\nint main()\n{\n\tf(1, 2);\n\tf(1.5, 2);\n\treturn 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect. Avem eroare de compilare la linia 14: <pre class='inline'><code class='language-cpp'>f(1, 2);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nDe ce avem eroare? In primul rand functia f este supraincarcata. Daca ne uitam la linia 14: <pre class='inline'><code class='language-cpp'>f(1, 2);</code></pre> ambele argumente sunt de tip <pre class='inline'><code class='language-cpp'>int</code></pre>. Acum sa ne uitam la functii: <pre class='inline'><code class='language-cpp'>void f(double x, int y)</code></pre> si <pre class='inline'><code class='language-cpp'>void f(int x, double y)</code></pre>. Prima functie trebuie sa converteasca primul argument (adica 1) din <pre class='inline'><code class='language-cpp'>int</code></pre> in <pre class='inline'><code class='language-cpp'>double</code></pre>, a doua functie nu trebuie sa faca nimic.\n</div>\n<div>\nAcum, prima functie nu trebuie sa mai faca nimic pentru al doilea argument (adica 2) pentru ca e deja <pre class='inline'><code class='language-cpp'>int</code></pre> in schimb a doua funtie trebuie sa convertesca din <pre class='inline'><code class='language-cpp'>double</code></pre> in <pre class='inline'><code class='language-cpp'>int</code></pre>.\n</div>\n<div>\nIn concluzie ambele functii trebuie sa faca o conversie obligatoriu, deci apelul functiei f este ambiguu, nu se stie care functie sa se apeleze. Ca programul sa fie corect sunt mai multe variante:\n</div>\n<div>\n1) schimbi linia 15 din <pre class='inline'><code class='language-cpp'>f(1, 2);</code></pre> in <pre class='inline'><code class='language-cpp'>f(1.0, 2);</code></pre> de exemplu (sa fie un double ca prim argument) sau in <pre class='inline'><code class='language-cpp'>f(1, 2.0);</code></pre>. Ai grija ca ceva de genul <pre class='inline'><code class='language-cpp'>f(1.3, 2.1);</code></pre> da aceeasi eroare.\n</div>\n<div>\n2) schimbi linia 4: <pre class='inline'><code class='language-cpp'>void f(double x, int y) {</code></pre> in <pre class='inline'><code class='language-cpp'>void f(int x, int y){</code></pre>\n</div>\n<div>\n3) schimbi linia 8: <pre class='inline'><code class='language-cpp'>void f(int x, double y) {</code></pre> in <pre class='inline'><code class='language-cpp'>void f(double x, double y) {</code></pre> sau <pre class='inline'><code class='language-cpp'>void f(int x, int y) {</code></pre>\n</div></div>", "tags": ["incorrect", "function overloading", "implicit cast", "easy"]}, {"id": 3, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt; \nusing namespace std;\n\nint f(int x, int y) {\n\tcout &lt;&lt; &quot;Salut din prima functie&quot; &lt;&lt; endl;\n\treturn x + y;\n}\n\ndouble f(int y, int x) {\n\tcout &lt;&lt; &quot;Salut din a doua functie&quot; &lt;&lt; endl;\n\treturn 10.0;\n}\n\nint main()\n{\n\tf(2, 2);\n\tf(2.5, 3);\n\treturn 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu funtioneaza corect. Avem eroare de compilare la linia 9: <pre class='inline'><code class='language-cpp'>double f(int y, int x) {</code></pre>\n</div>\n<samp class='error'>cannot overload functions distinguished by return type alone</samp>\n<div>\nPare ca functia f este supraincarcata dar nu este asa. Ca sa supraincarci o functie trebuie sa schimbi ori numarul de parametrii ori tipul parametrilor ori ordinea parametrilor (daca ai parametrii cu tipuri diferite) si cateva alte lucruri pe care la discut <a href='./tips.html#function-overloading'> aici</a>.\n</div>\n<div>\nDeci functiile <pre class='inline'><code class='language-cpp'>int f(int x, int y)</code></pre> si <pre class='inline'><code class='language-cpp'>double f(int y, int x)</code></pre> se deosebesc doar prin tipul returnat, care nu este destul pentru a le diferentia (am schimbat si <var>x</var> cu <var>y</var> in a doua functie dar asta nu are nicio treaba, sunt doar niste nume, tot doi parametrii de tip <pre class='inline'><code class='language-cpp'>int</code></pre> avem). De ce nu se deosebesc prin tipul returnat? Pentru ca exista situatii de genul urmator:\n</div>\n<div>\n<pre class='block'><code>#include &lt;iostream&gt; \nusing namespace std;\n\nint calculeazaPret(int pret, float TVA){\n\treturn pret + TVA * pret / 100;\n}\n\nfloat calculeazaPret(int pret, float TVA){\n\treturn pret + TVA * pret / 100;\n}\n\nint main()\n{\n\tdouble x = calculeazaPret(100, 4);\n\tcout &lt;&lt; x &lt;&lt; endl;\n}</code></pre>\n</div>\n<div>\nAici si <pre class='inline'><code class='language-cpp'>int</code></pre> si <pre class='inline'><code class='language-cpp'>float</code></pre> se poate converti la <pre class='inline'><code class='language-cpp'>double</code></pre> deci la linia <pre class='inline'><code class='language-cpp'>double x = calculeazaPret(100, 4);</code></pre> care functie se apeleaza? Ca sa se evite situatii de genul asta fara sens, tipul returnat nu e destul pentru a face diferenta.\n</div>\n<div>\nCa programul sa fie corect trebuie schimbata linia 9: <pre class='inline'><code class='language-cpp'>double f(int y, int x) {</code></pre> in ceva de genul <pre class='inline'><code class='language-cpp'>double f(double y, int x) {</code></pre> de exemplu.\n</div></div>", "tags": ["easy", "incorrect", "function overloading", "function signature"]}, {"id": 4, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt; \nusing namespace std;\n\nvoid g(int x, int y, double z) {\n\tcout &lt;&lt; &quot;x + y + z = &quot; &lt;&lt; x + y + z &lt;&lt; endl;\n\tz = x + y;\n}\n\nvoid g(int x, double y, int z) {\n\tcout &lt;&lt; &quot;x + y - z = &quot; &lt;&lt; x + y - z &lt;&lt; endl;\n\tz = 5;\n}\n\nvoid g(double x, double y, int z) {\n\tx = y = 1.0;\n\tcout &lt;&lt; &quot;x * y + z =&quot; &lt;&lt; x * y + z &lt;&lt; endl;\n}\n\nint main() {\n\tg(5, 6.5, 10);\n\tg(1, 2, 3);\n\tg(4, 5, 2.0);\n}</code></pre>", "solution": "<div><div>\nProgramul nu este corect. Avem eroare de compilare la linia 21: <pre class='inline'><code class='language-cpp'>g(1, 2, 3);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nAvem functia g care este supraincarcata si avem 3 &quot;variante&quot;: <pre class='inline'><code class='language-cpp'>void g(int x, int y, double z)</code></pre>, <pre class='inline'><code class='language-cpp'>void g(int x, double y, int z)</code></pre>, <pre class='inline'><code class='language-cpp'>void g(double x, double y, int z)</code></pre>. In main mai intai apelam functia g aici <pre class='inline'><code class='language-cpp'>g(5, 6.5, 10);</code></pre>. Se potriveste perfect cu a doua functie (<pre class='inline'><code class='language-cpp'>void g(int x, double y, int z)</code></pre>, are 3 argumente in ordinea asta: <pre class='inline'><code class='language-cpp'>int</code></pre>, <pre class='inline'><code class='language-cpp'>double</code></pre>, <pre class='inline'><code class='language-cpp'>int</code></pre>). Cand apelam functia g la sfarsit <pre class='inline'><code class='language-cpp'>g(4, 5, 2.0);</code></pre> si acum se potriveste perfect cu prima functie <pre class='inline'><code class='language-cpp'>void g(int x, int y, double z)</code></pre>.\n</div>\n<div>\nProblemele apar la <pre class='inline'><code class='language-cpp'>g(1, 2, 3);</code></pre>. Toate argumentele sunt de tip <pre class='inline'><code class='language-cpp'>int</code></pre>. Acum sa ne uitam la functii: avem prima si a doua care trebuie sa faca 1 conversie (de la <pre class='inline'><code class='language-cpp'>int</code></pre> la <pre class='inline'><code class='language-cpp'>double</code></pre>) si a treia care trebuie sa faca 2 conversii. A treia iese din discutie fiindca trebuie sa faca mai multa treaba. Dintre prima si a doua functie pe care o alegem? Asta e problema, ca nu stim, se potrivesc amandoua. Deci apelul functiei g la linia 21: <pre class='inline'><code class='language-cpp'>g(1, 2, 3);</code></pre> este ambiguu.\n</div></div>", "tags": ["easy", "incorrect", "function overloading", "implicit cast"]}, {"id": 5, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid f(int x, int y) {\n\tcout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot; si y = &quot; &lt;&lt; y &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Prima functie!&quot; &lt;&lt; endl;\n\tint z = x + y;\n}\n\nvoid f(double x, int y) {\n\tdouble z = x + x;\n\tcout &lt;&lt; &quot;Dublul lui x = &quot; &lt;&lt; z &lt;&lt; endl;\n\tcout &lt;&lt; &quot;A doua functie!&quot; &lt;&lt; endl;\n\tz = x - 20.0;\n}\n\nint main() {\n\tfloat x = 5;\n\tint y = 2;\n\tf(x, y);\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>Dublul lui x = 10\nA doua functie!</samp>\n<div>\nPoate te-a luat prin surprindere ca este corect. Avem functia f care este supraincarcata <pre class='inline'><code class='language-cpp'>void f(int x, int y)</code></pre> si <pre class='inline'><code class='language-cpp'>void f(double x, int y)</code></pre>. In main apelam functia f cu un <pre class='inline'><code class='language-cpp'>float</code></pre> si cu un <pre class='inline'><code class='language-cpp'>int</code></pre>.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>void f(int x, int y)</code></pre> trebuie sa converteasca <pre class='inline'><code class='language-cpp'>float</code></pre> la <pre class='inline'><code class='language-cpp'>int</code></pre> iar <pre class='inline'><code class='language-cpp'>void f(double x, int y)</code></pre> trebuie sa converteasca <pre class='inline'><code class='language-cpp'>float</code></pre> la <pre class='inline'><code class='language-cpp'>double</code></pre>. Ambele fac o singura conversie de ce nu este ambiguu apelul <pre class='inline'><code class='language-cpp'>f(x, y);</code></pre>?\n</div>\n<div>\nPentru ca aceste conversii si ele de mai multe feluri, unele mai importante decat celelalte si asta contribuie la ce functie se alege in cazul asta.\nConversia de la <pre class='inline'><code class='language-cpp'>float</code></pre> la <pre class='inline'><code class='language-cpp'>double</code></pre> are un nume special putin, se numeste &quot;<b>promotie</b>&quot; (floating-point promotion). Conversia de la <pre class='inline'><code class='language-cpp'>int</code></pre> la <pre class='inline'><code class='language-cpp'>double</code></pre> se numeste tot &quot;<b>conversie</b>&quot; (floating-point conversion). \n</div>\n<div>\nPromotia se refera ca poti reprezenta si pastra exact informatia din tipul care se converteste in tipul convertit fara sa pierzi informatia. (de ex din <pre class='inline'><code class='language-cpp'>float</code></pre> in <pre class='inline'><code class='language-cpp'>double</code></pre> sau din <pre class='inline'><code class='language-cpp'>short</code></pre> in <pre class='inline'><code class='language-cpp'>int</code></pre>). Cand faci o conversie s-ar putea sa pierzi infomatia sau sa se modifice(de ex din <pre class='inline'><code class='language-cpp'>int</code></pre> in <pre class='inline'><code class='language-cpp'>float</code></pre>, pentru ca exista numere intregi care nu se reprezinta exact cu un <pre class='inline'><code class='language-cpp'>float</code></pre> ). Ai grija ca conversia din <pre class='inline'><code class='language-cpp'>int</code></pre> in <pre class='inline'><code class='language-cpp'>long</code></pre> sau <pre class='inline'><code class='language-cpp'>long long</code></pre> (dar si altele) <b>NU</b> sunt promotii, sunt conversii. Pentru mai multe detalii citeste <a href='./tips.html#function-overloading'>aici</a>.\n</div>\n<div>\nIn cazul asta se face o conversie in cazul primei functii si o promotie in cazul celei de a doua functii, si cum promotia este mai puternica nu mai exista ambiguitate si prin <pre class='inline'><code class='language-cpp'>f(x,y);</code></pre> apelezi a doua functie. \n</div></div>", "tags": ["correct", "easy", "function overloading", "implicit cast"]}, {"id": 6, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint *n, *nr, *s;\n\n\tcout &lt;&lt; &quot;Cate numere sunt?&quot; &lt;&lt; endl;\n\tn = new int;\n\tcin &gt;&gt; *n;\t// 5\n\n\tnr = new int[*n];\n\n\tcout &lt;&lt; &quot;Introdu numerele&quot; &lt;&lt; endl;\n\tfor (int i = 0; i &lt; *n; ++i) {\n\t\tcin &gt;&gt; nr[i]; // 1 2 3 4 5\n\t}\n\n\ts = new int(0);\n\tfor (int i = 0; i &lt; *n; ++i) {\n\t\t*s += nr[i];\n\t}\n\n\tcout &lt;&lt; &quot;Suma este: &quot; &lt;&lt; *s &lt;&lt; endl;\n\n\tdelete n;\n\tdelete s;\n\tdelete nr;\n}</code></pre>", "solution": "<div><div>\nDaca se citeste de la tastatura <pre class='inline'><code class='language-cpp'>1</code></pre> si dupa <pre class='inline'><code class='language-cpp'>1 2 3 4 5</code></pre> se afiseaza:\n</div>\n<samp class='output'>Cate numere sunt?\n5\nIntrodu numerele\n1 2 3 4 5\nSuma este: 15</samp>\n<div>\nProbabil va functiona corect daca incerci, dar la linia 27: <pre class='inline'><code class='language-cpp'>delete nr;</code></pre> nu e corect. Cand aloci dinamic memorie cu <pre class='inline'><code class='language-cpp'>new</code></pre>, eliberezi memoria cu <pre class='inline'><code class='language-cpp'>delete</code></pre> iar cand aloci memorie cu <pre class='inline'><code class='language-cpp'>new[]</code></pre> eliberezi cu <pre class='inline'><code class='language-cpp'>delete[]</code></pre>. In cazul asta <pre class='inline'><code class='language-cpp'>nr</code></pre> e un array alocat dinamic si trebuie eliberata memoria cu <pre class='inline'><code class='language-cpp'>delete[]</code></pre> nu cu <pre class='inline'><code class='language-cpp'>delete</code></pre>. Daca folosesti <pre class='inline'><code class='language-cpp'>delete</code></pre> pentru un array ce se intampla e <i>undefined behaviour</i>, adica depinde de compilator ce se intampla, poate nimic, poate ceva grav care nu va genera eroare dar va face programul sa nu functioneze corect mai tarziu. Deci corect ar fi sa inlocuiesti <pre class='inline'><code class='language-cpp'>delete nr;</code></pre> cu <pre class='inline'><code class='language-cpp'>delete[] nr;</code></pre>\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>s = new int(0);</code></pre> inseamna ca aloci dinamic un <pre class='inline'><code class='language-cpp'>int</code></pre> si ii dai valoarea 0. Poti pune si alte numere. \n</div>\n<div>\nCand aloci dinamic un array de ex. <pre class='inline'><code class='language-cpp'>int *s = new int[10];</code></pre> si vrei ca elementele sa fie 0 poti scrie direct <pre class='inline'><code class='language-cpp'>int *s = new int[10]()</code></pre>, nu pune nimic intre paranteze.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "dynamic memory allocation"]}, {"id": 7, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nint main() {\n\tchar* s = new char[20];\n\tstrcpy(s, &quot;Hello world!&quot;);\n\n\tcout &lt;&lt; s &lt;&lt; endl;\n\n\tdelete[] s;\n\n\ts = new char[4];\n\ts[0] = &#39;a&#39;;\n\ts[1] = &#39;b&#39;;\n\ts[2] = &#39;c&#39;;\n\ts[3] = 0;\n\n\tcout &lt;&lt; s &lt;&lt; endl;\n\n\tdelete[] s;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>Hello world!\nabc</samp>\n<div>\nSe aloca dinamic spatiu in memorie pentru un sir de caractere de lungime 20 (practic 19 pentru ca ultimul trebuie sa fie caracterul special <pre class='inline'><code class='language-cpp'>&#39;\\0&#39;</code></pre> ca sa marcheze sfarsitul). Se copiaza <pre class='inline'><code class='language-cpp'>&quot;Hello world!&quot;</code></pre> in <var>s</var> si se afiseaza dupa care se sterge si se aloca iar spatiu pentru 4 caractere de data asta. Se pun <pre class='inline'><code class='language-cpp'>&#39;a&#39;</code></pre>, <pre class='inline'><code class='language-cpp'>&#39;b&#39;</code></pre>, <pre class='inline'><code class='language-cpp'>&#39;c&#39;</code></pre> pe primele 3 pozitii iar pe ultima se pune caracterul special <pre class='inline'><code class='language-cpp'>&#39;\\0&#39;</code></pre> sau <pre class='inline'><code class='language-cpp'>0</code></pre> (sau <pre class='inline'><code class='language-cpp'>NULL</code></pre>). La final se elibereaza memoria cu <pre class='inline'><code class='language-cpp'>delete[]</code></pre>.\n</div>\n<div>\nDaca nu pui <pre class='inline'><code class='language-cpp'>&#39;\\0&#39;</code></pre> sau <pre class='inline'><code class='language-cpp'>0</code></pre> la sfarsit se pot afisa caractere in plus la finalul cuvantului pentru ca se afiseaza caracter cu caracter pana la <pre class='inline'><code class='language-cpp'>0</code></pre> pus de tine sau gasit undeva in memorie random.\n</div>\n<pre class='block'><code>s = new char[3];\ns[0] = &#39;a&#39;;\ns[1] = &#39;b&#39;;\ns[2] = &#39;c&#39;;\n\ncout &lt;&lt; s &lt;&lt; endl;</code></pre>\n<div>\nSe afiseaza (pe calculatorul meu):\n</div>\n<samp class='output'>Hello world!\nabc$|PPP</samp></div>", "tags": ["easy", "correct", "pointers", "dynamic memory allocation"]}, {"id": 8, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint a = 5;\n\tint b = 2;\n\tint&amp; x = a;\n\n\tx += b;\n\ta = b;\n\tb += x;\n\n\tcout &lt;&lt; a &lt;&lt; &#39; &#39; &lt;&lt; b &lt;&lt; &#39; &#39; &lt;&lt; x &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul este corect, se afiseaza:\n</div>\n<samp class='output'>2 4 2</samp>\n<div>\nSe creeaza variabila <var>a</var> avand valoarea 5 si variabila <var>b</var> avand valoarea 2 si o referinta la variabila <var>a</var>. In cazul asta referinta este un alias pentru variabila <var>a</var> deci <pre class='inline'><code class='language-cpp'>x += b;</code></pre> este practic <pre class='inline'><code class='language-cpp'>a += b;</code></pre>. Deci acum <var>a</var> = 7. Dupa <var>a</var> ia valorea lui <var>b</var> adica 2 si dupa <pre class='inline'><code class='language-cpp'>b += x;</code></pre> inseamna <pre class='inline'><code class='language-cpp'>b += a;</code></pre>. Deci in final <var>a</var> = 2, <var>b</var> = 4.\n</div>\n<div>\nTrebuie sa initializezi o referinta cand o creezi si nu poti schimba la cine se refera referinta dupa ce faci asta.\n</div>\n<pre class='block'><code>int a = 5;\nint&amp; b;\t\t// eroare\nb = a;\n\nint c = 10;\nint &amp;t = c;\nt = a;\t\t// inseamna &#39;c = a;&#39;</code></pre></div>", "tags": ["correct", "references", "easy"]}, {"id": 9, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint x = 1, y = 2, z = 3;\n\tint &amp;a = x, &amp;b = y, &amp;c = z;\n\n\tint&amp; arr[] = { a, b ,c };\n\n\tarr[0] = 100;\n\n\tcout &lt;&lt; arr[0] &lt;&lt; endl;\n\tcout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul nu e corect, avem eroare la linia 8:<pre class='inline'><code class='language-cpp'>int&amp; arr[] = { a, b ,c };</code></pre>\n</div>\n<samp class='error'>array of reference is not allowed</samp>\n<div>\nCum spune si eroarea nu putem creea array-uri (de fapt orice container) de referinte. Trebuie schimbata linia 8:<pre class='inline'><code class='language-cpp'>int&amp; arr[] = { a, b ,c };</code></pre> in <pre class='inline'><code class='language-cpp'>int arr[] = { a, b ,c };</code></pre>.\n</div>\n<div>\nMai intai se creeaza 3 variabile si dupa 3 referinte pentru cele 3 variabile. Dupa se creeaza un array de <pre class='inline'><code class='language-cpp'>int</code></pre> iar valorile din el sunt de fapt valorile variabilelor <var>x</var>, <var>y</var>, <var>z</var> pentru ca referintele sunt ca un alias pentru variabilele <var>x</var>, <var>y</var>, <var>z</var> deci <pre class='inline'><code class='language-cpp'>arr[0] = 100;</code></pre> nu modifica valoarea lui <var>x</var>.\n</div>\n<div>\nDe ce nu putem avea array de referinte? Cand creezi un array, de ex <pre class='inline'><code class='language-cpp'>int v[3] = {1, 2, 3};</code></pre>, <pre class='inline'><code class='language-cpp'>v</code></pre> este un pointer la primul element, iar elementele sunt unele langa altele in memorie. Cand accesezi elementul <pre class='inline'><code class='language-cpp'>v[2]</code></pre> de fapt este <pre class='inline'><code class='language-cpp'>*(v + 2)</code></pre>(de la primul element te duci 2 pozitii in fata). Acum daca ai avea <pre class='inline'><code class='language-cpp'>int&amp; v[3] = {a, b, c};</code></pre> v este un pointer la primul element, adica <var>a</var>, dar <var>a</var> e referinta si adresa lui <var>a</var> este adresa varibilei la care se refera (pentru care e un alias) care este altundeva in memorie deci nu ai cum sa te referi la restul elementelor.\n</div>\n<div>\nDe asemenea nu poti avea pointeri la referinte si referinte la referinte.\n</div></div>", "tags": ["incorrect", "easy", "references"]}, {"id": 10, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint x = 123, y = 456;\n\tint&amp; rx = x;\n\trx = 50;\n\t\n\tint* p = &amp;rx;\n\tint*&amp; rp = p;\n\n\t*rp = 100;\n\tp = &amp;y;\n\t*rp = 200;\n\n\tcout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>100 200</samp>\n<div>\nAvem doua variabile <var>x</var> si <var>y</var> si o referinta la <var>x</var>. <pre class='inline'><code class='language-cpp'>rx = 50;</code></pre> este de fapt <pre class='inline'><code class='language-cpp'>x = 50;</code></pre> pentru ca referinta este ca un alias pentru variabila <var>x</var>. Dupa avem un pointer care arata spre adresa de memorie lui <var>rx</var> care este de fapt adresa de memorie lui <var>x</var> pentru ca referintele nu ocupa memorie. Dupa la linia 10: <pre class='inline'><code class='language-cpp'>int*&amp; rp = p;</code></pre> se creeaza o referinta la pointerul <var>p</var>. Deci acum <var>rp</var> este practic <var>p</var>. <pre class='inline'><code class='language-cpp'>*rp = 100;</code></pre> este ca si cum ai scrie <pre class='inline'><code class='language-cpp'>*p = 100;</code></pre>. Adica dereferentiezi pointerul <var>p</var> ca sa ai acces la zona din memorie la care arata, adica la variabila <var>x</var> a carui valorea este modificata in 100.\n</div>\n<div>\nApoi <var>p</var> arata acum spre zona din memorie unde este <var>y</var>. <var>rp</var> continua sa fie o referinta la <var>p</var> deci <pre class='inline'><code class='language-cpp'>*rp = 200;</code></pre> este practic <pre class='inline'><code class='language-cpp'>*p = 200;</code></pre> adica prin <var>p</var> accesezi variabila <var>y</var> a carui valoare o schimbi in 200.\n</div></div>", "tags": ["easy", "pointers", "references", "correct"]}, {"id": 11, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid f(int*&amp; x, int&amp; y) {\n\ty = *x;\n\tx = &amp;y;\n}\n\nint main()\n{\n\tint a = 10;\n\tint b = 20;\n\tint* p = &amp;a;\n\tf(p, b);\n\n\t*p = 0;\n\n\tcout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>10 0</samp>\n<div>\nSe creeaza 2 variabile <var>a</var> si <var>b</var> si un pointer care arata spre zona de memorie unde este <var>a</var>. Se apeleaza functia f unde parametrii sunt de tip referinta (referinta la un pointer de tip <pre class='inline'><code class='language-cpp'>int</code></pre> si referinta la un <pre class='inline'><code class='language-cpp'>int</code></pre>). Deci in interiorul functiei <var>x</var> este <var>p</var> iar <var>y</var> este <var>b</var>. <var>y</var> ia valoarea variabilei de la adresa la care arata pointerul <var>x</var> adica <var>b</var> ia valorea lui <var>a</var> si dupa <var>x</var> arata spre adresa lui <var>y</var>, deci <var>p</var> arata spre adresa lui <var>b</var>. Prin <pre class='inline'><code class='language-cpp'>*p</code></pre> accesezi zona din memorie la care arata pointerul si in cazul asta setezi valorea lui <var>b</var> la 0.\n</div></div>", "tags": ["correct", "easy", "pointers", "references"]}, {"id": 12, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\tint N = 99, M = 2;\n\tint v[] = { 10, 20, N, M };\n\n\tint(*p1)[4] = &amp;v;\n\tint* p2 = v;\n\n\tp1++;\n\tp2++;\n\tcout &lt;&lt; (*p1)[1] &lt;&lt; &quot; &quot; &lt;&lt; p2[1];\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect. Nu avem eroare de compilare dar posibil eroare la runtime pentru ca accesam memorie unde nu trebuie.\n</div>\n<div>\nDeci avem un array <pre class='inline'><code class='language-cpp'>v[] = {10, 20, 99, 2};</code></pre> (am pus direct valorile lui <var>N</var> si <var>M</var>). La linia 9: <pre class='inline'><code class='language-cpp'>int(*p1)[4] = &amp;v;</code></pre> se creeaza un pointer cu numele <var>p1</var> de tip <pre class='inline'><code class='language-cpp'>int(*)[4]</code></pre> care arata spre un array cu 4 elemente, in cazul asta <var>v</var>. Deci <var>p1</var> arata spre intreg array-ul <var>v</var>. \n</div>\n<div>\nCand scrii <pre class='inline'><code class='language-cpp'>int* p2 = v;</code></pre> este ca si cum ai scrie <pre class='inline'><code class='language-cpp'>int* p2 = &amp;v[0];</code></pre>. (se produce un &quot;decay&quot;, array-ul se transforma intr-un pointer la primul element, <var>v</var> nu este de tip <pre class='inline'><code class='language-cpp'>int*</code></pre> ci <pre class='inline'><code class='language-cpp'>int[4]</code></pre> dar totusi poti scrie <pre class='inline'><code class='language-cpp'>int* p2 = v;</code></pre>). Deci <var>p2</var> este un pointer la primul element.\n</div>\n<div>\nDeci <var>p2</var> este un pointer de tip <pre class='inline'><code class='language-cpp'>int*</code></pre> la primul element din array-ul <var>v</var>, iar <var>p1</var> este un pointer de tip <pre class='inline'><code class='language-cpp'>int(*)[4]</code></pre> la intreg array-ul v. Deocamdata ambii pointeri arata spre aceeasi zona de memorie (inceputul array-ului) dar sunt de tipuri <b>diferite</b>.\n</div>\n<div>\nAcum urmeaza partea care nu e corecta. Operatiile aritmetice cu pointeri se folosesc de tipul lor. Un <pre class='inline'><code class='language-cpp'>int</code></pre> are 4 bytes si <var>p2</var> arata spre un <pre class='inline'><code class='language-cpp'>int</code></pre> deci <pre class='inline'><code class='language-cpp'>p2++;</code></pre> inseamna ca adresa la care arata p2 se mareste cu 4 bytes adica trece la urmatorul numar din array-ul <var>v</var> adica <pre class='inline'><code class='language-cpp'>20</code></pre>. Insa <var>p1</var> arata spre un <pre class='inline'><code class='language-cpp'>int[4]</code></pre> si <pre class='inline'><code class='language-cpp'>p1++;</code></pre> mareste adresa lui p1 cu 4*4=16 bytes (dimensiunea lui <pre class='inline'><code class='language-cpp'>int[4]</code></pre>) deci ajunge <b>dupa</b> zona de memorie rezervata pentru array-ul <var>v</var>. Cand scrii <pre class='inline'><code class='language-cpp'>(*p1)[1]</code></pre> si dereferentiezi <var>p1</var> obtii ceva de tip <pre class='inline'><code class='language-cpp'>int[4]</code></pre> adica un array, dar array-ul asta e dupa zona de memorie a lui <var>v</var> daca incerci sa accesezi primul element obtii o valoare random din memorie sau intri peste memorie deja alocata si ai eroare. Este corect sa scrii <pre class='inline'><code class='language-cpp'>p2[1]</code></pre> pentru ca inseamna de fapt <pre class='inline'><code class='language-cpp'>*(p2 + 1)</code></pre> adica urmatorul nr din array-ul <var>v</var> dupa <pre class='inline'><code class='language-cpp'>20</code></pre> adica 99.\n</div>\n<img class='img-fluid' src='./imgs/p12.png' alt='...'>\n<div>\nDeci ca sa fie corect stergi linia 12: <pre class='inline'><code class='language-cpp'>p1++;</code></pre>. Sau ai putea inlocui linia 15: cu <pre class='inline'><code class='language-cpp'>cout &lt;&lt; (*(p1-1))[1] &lt;&lt; &quot; &quot; &lt;&lt; p2[1];</code></pre>. <pre class='inline'><code class='language-cpp'>p1-1</code></pre> inseamna practic ca te intorci la adresa la care se afla <var>v</var>. Ca sa ai acces la array trebuie sa deferentiezi pointerul adica <pre class='inline'><code class='language-cpp'>*(p1-1)</code></pre> si pentru ca <pre class='inline'><code class='language-cpp'>[]</code></pre> are precedenta mai mare mai trebuie niste paranteze <pre class='inline'><code class='language-cpp'>(*(p1-1))[1]</code></pre> si asta inseamana practic <pre class='inline'><code class='language-cpp'>v[1]</code></pre>.\n</div></div>", "tags": ["incorrect", "easy", "pointers", "array"]}, {"id": 13, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint x = 5;\n\tconst int y = 10;\n\n\tconst int* p = &amp;y;\n\tint const* p2 = &amp;x;\n\n\t*p2 = *p;\n\n\tcout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul nu este corect, avem eroare la linia 11: <pre class='inline'><code class='language-cpp'>*p2 = *p;</code></pre>\n</div>\n<samp class='error'>expression must be a modifiable lvalue</samp>\n<div>\nAvem <var>x</var> care are valoarea 5 si <var>y</var> care are valoarea 10 (<var>y</var> este <pre class='inline'><code class='language-cpp'>const int</code></pre> si deci nu mai poti schimba valoarea lui <var>y</var>, poti elimina partea de const cu un cast dar ce rost mai are). <pre class='inline'><code class='language-cpp'>const int*</code></pre> este identic cu <pre class='inline'><code class='language-cpp'>int const*</code></pre> deci\n</div>\n<pre class='block'><code>const int* p = &amp;y;\nint const* p2 = &amp;x;</code></pre>\n<div>\ne identic cu\n</div>\n<pre class='block'><code>const int* p = &amp;y;\nconst int* p2 = &amp;x;</code></pre>\n<div>\n<pre class='inline'><code class='language-cpp'>const int* p = &amp;y;</code></pre> inseamna un pointer la un <pre class='inline'><code class='language-cpp'>const int</code></pre> adica NU ai voie sa modifici valorea de la adresa la care arata pointerul dar in schimb poti modifica la ce adresa arata pointerul (gen <pre class='inline'><code class='language-cpp'>p = &amp;x;</code></pre> e corect dar <pre class='inline'><code class='language-cpp'>*p = 5;</code></pre> nu e corect pentru ca modific valoarea de la adresa la care arata pointerul).\n</div>\n<div>\nProblema e la <pre class='inline'><code class='language-cpp'>*p2 = *p;</code></pre> ca <var>p2</var> e pointer la <pre class='inline'><code class='language-cpp'>const int</code></pre> si incerci sa modifici valoarea de la adresa la care arata pointerul. Ca sa mearga programul trebuie schimbata linia 9: <pre class='inline'><code class='language-cpp'>int const* p2 = &amp;x;</code></pre> in <pre class='inline'><code class='language-cpp'>int* p2 = &amp;x;</code></pre> si acum <var>p2</var> e pointer la <pre class='inline'><code class='language-cpp'>int</code></pre> si poti sa modifici valoarea de la adresa la care arata pointerul, deci <var>x</var> ia valoarea lui <var>y</var> adica 10.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "const"]}, {"id": 14, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint a = 100;\n\tint b = 200;\n\tint c = 300;\n\n\tint* const p1 = &amp;a;\n\t*p1 = 999;\n\tp1 = &amp;b;\n\t*p1 = 9999;\n\n\tconst int* p2 = &amp;c;\n\tp2 = p1;\n\tp2 = &amp;a;\n\n\tcout &lt;&lt; *p1 &lt;&lt; &#39; &#39; &lt;&lt; *p2;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare la linia 11: <pre class='inline'><code class='language-cpp'>p1 = &amp;b;</code></pre>\n</div>\n<samp class='error'>expression must be a modifiable lvalue</samp>\n<div>\n<var>p1</var> este un pointer constant la un <pre class='inline'><code class='language-cpp'>int</code></pre>, deci il poti dereferentia cu <pre class='inline'><code class='language-cpp'>*</code></pre> si sa schimbi valorea de la adresa la care arata, dar nu poti schimba la ce adresa arata (adica arata spre <var>a</var>, nu poti schimba sa arate spre <var>b</var>). Ca sa fie corect poti schimba linia 10: <pre class='inline'><code class='language-cpp'>int* const p1 = &amp;a;</code></pre> in <pre class='inline'><code class='language-cpp'>int* p1 = &amp;a;</code></pre> si acum <var>p1</var> este un simplu pointer la un <pre class='inline'><code class='language-cpp'>int</code></pre> si poti schimba si adresa la care arata.\n</div>\n<pre class='block'><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint a = 100;\n\tint b = 200;\n\tint c = 300;\n\n\tint* p1 = &amp;a;\t// p1 arata spre a\n\t*p1 = 999;\t\t// a ia valorea 999\n\tp1 = &amp;b;\t\t// acum p1 arata spre b\n\t*p1 = 9999;\t\t// b ia valoarea 9999\n\n\tconst int* p2 = &amp;c;\t\t// p2 arata spre c\n\t\n\t// p2 e un pointer la un int constant, poti schimba la ce\n\t// adresa arata dar nu poti schimba valoarea de la adresa \n\t// la care arata: *p2 = 5; eroare si p2 = &amp;a; ok\n\t\n\tp2 = p1;\t// p2 arata spre ce arata p1 adica b\n\tp2 = &amp;a;\t// acum p2 arata spre a (p1 nu se modifica)\n\n\tcout &lt;&lt; *p1 &lt;&lt; &#39; &#39; &lt;&lt; *p2; // 9999 999\n}</code></pre></div>", "tags": ["easy", "incorrect", "pointers", "const"]}, {"id": 15, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tconst int x = 5;\n\tint* const p = &amp;x;\n\n\tint y = 100;\n\tconst int* const p2 = &amp;y;\n\ty = 200;\n\n\tcout &lt;&lt; *p + *p2;\n}</code></pre>", "solution": "<div><div>\nProgramul nu este corect, avem eroare la linia 6: <pre class='inline'><code class='language-cpp'>int* const p = &amp;x;</code></pre>\n</div>\n<samp class='error'>a value of type &quot;const int *&quot; cannot be used to initialize an entity of type &quot;int *const&quot;</samp>\n<div>\n<var>p</var> este un pointer const la un <pre class='inline'><code class='language-cpp'>int</code></pre> (poti modifica valoarea de la adresa la care arata, dar nu poti modifica la ce adresa arata pointerul) dar <var>x</var> este <pre class='inline'><code class='language-cpp'>const int</code></pre> si practic ai putea modifica valorea lui prin pointerul <var>p</var> deci nu e corect sa initializezi pointerul <var>p</var> cu adresa lui <var>x</var>. Ca sa fie corect <var>p</var> trebuie sa fie un pointer la <pre class='inline'><code class='language-cpp'>const int</code></pre> sau <var>x</var> sa fie doar <pre class='inline'><code class='language-cpp'>int</code></pre>. Deci ori schimbi linia 5: <pre class='inline'><code class='language-cpp'>const int x = 5;</code></pre> in <pre class='inline'><code class='language-cpp'>int x = 5;</code></pre> ori schimbi linia 6: <pre class='inline'><code class='language-cpp'>int* const p = &amp;x;</code></pre> in <pre class='inline'><code class='language-cpp'>const int* const p = &amp;x</code></pre>.\n</div>\n<div>\n<var>p2</var> este un pointer constant la un <pre class='inline'><code class='language-cpp'>const int</code></pre> deci nu poti modifica valoarea de la adresa la care arata <var>p2</var> si nici adresa la care arata. Poti modifica <var>y</var>, nu are legatura cu <var>p2</var>. La final se afiseaza: <pre class='inline'><code class='language-cpp'>205</code></pre> (daca faci modificarile de mai sus).\n</div>\n<div>\nCa sa nu te incurci cand citesti ceva de genul <pre class='inline'><code class='language-cpp'>const int* const p2 = &amp;y;</code></pre>, citeste de la dreapta la stanga: <var>p2</var> este un const  pointer la un <pre class='inline'><code class='language-cpp'>int</code></pre> const, <pre class='inline'><code class='language-cpp'>const int* const * const p3 = &amp;p2;</code></pre> este un const pointer la un const pointer la un <pre class='inline'><code class='language-cpp'>const int</code></pre>. Poti folosi si site-ul <a href='https://cdecl.org/?q=int*const+*const+p3'>asta</a>.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "const"]}, {"id": 16, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int f(int x, int y) {\n\tint* p = &amp;x;\n\tint&amp; ry = y;\n\n\t*p = 100;\n\try = x;\n\try = 5;\n\n\treturn x + y;\n}\n\nint main() {\n\tconst int a = 500;\n\tint b = 300;\n\n\tint c = f(a, b);\n\n\tcout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>500 300 105</samp>\n<div>\nAvem <var>a</var> care este un <pre class='inline'><code class='language-cpp'>const int</code></pre> cu valorea 500 si <var>b</var> care are valorea 300. <var>c</var> se initializeaza cu valorea returnata de functia <var>f</var> (nu conteaza ca <var>f</var> intoarce un <pre class='inline'><code class='language-cpp'>const int</code></pre>, se poate initializa un <pre class='inline'><code class='language-cpp'>int</code></pre> cu un <pre class='inline'><code class='language-cpp'>const int</code></pre>).\n</div>\n<div>\nIn functia <var>f</var> parametrii sunt transmisi prin valoare deci <var>x</var> si <var>y</var> sunt copii ale variabilelor <var>a</var> si <var>b</var>. <pre class='inline'><code class='language-cpp'>int* p = &amp;x;</code></pre> inseamna ca pointerul <var>p</var> arata spre zona de memorie unde este <var>x</var>, iar <var>ry</var> este o referinta la y (un alt nume practic). Prin <pre class='inline'><code class='language-cpp'>*p = 100;</code></pre> dereferentiezi pointerul <var>p</var> ca sa ai acces la zona de memorie la care arata si modifici valoarea de acolo in 100, adica <var>x</var> devine 100. <pre class='inline'><code class='language-cpp'>ry = x;</code></pre> inseamna practic <pre class='inline'><code class='language-cpp'>y = x;</code></pre>, pentru ca <var>ry</var> este o referinta la <var>y</var> (NU inseamna ca schimbi la ce se refera <var>ry</var>, nu poti face asta), deci <var>y</var> ia valorea lui <var>x</var> adica 100. <pre class='inline'><code class='language-cpp'>ry = 5;</code></pre> inseamna ca <var>y</var> ia valorea 5. La final se returneaza 100 + 5 adica 105. (nu uita ca <var>x</var> si <var>y</var> sunt copii ale lui <var>a</var> si <var>b</var> deci nu le modifica). Deci <var>a</var> ramane 500, <var>b</var> ramane 300 si <var>c</var> ia valorea 105.\n</div></div>", "tags": ["easy", "pointers", "references", "correct"]}, {"id": 17, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nvoid f(int x, const double&amp; y) {\n\tif (x == 0) {\n\t\tcout &lt;&lt; &quot;x = 0!&quot;;\n\t}\n\telse {\n\t\tcout &lt;&lt; y / x &lt;&lt; endl;\n\t}\n}\n\nvoid f(int x, double&amp; y) {\n\tcout &lt;&lt; x &lt;&lt; &quot; si &quot; &lt;&lt; y &lt;&lt; endl;\n}\n\nint main() {\n\tf(2, 3.0);\n\n\tint x = 4;\n\tdouble y = 10.0;\n\n\tf(x, y);\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>1.5\n4 si 10</samp>\n<div>\nPrima functie <pre class='inline'><code class='language-cpp'>void f(int x, const double&amp; y)</code></pre> are ca parametru o referinta la un <pre class='inline'><code class='language-cpp'>const double</code></pre>, asta inseamana ca poti apela functia asta si cu ceva temporar care nu exista in memorie adica <pre class='inline'><code class='language-cpp'>f(1, 2.0)</code></pre> si cu o variabila <pre class='inline'><code class='language-cpp'>f(1, a);</code></pre>.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>void f(int x, double&amp; y)</code></pre> aici referinta e la un <pre class='inline'><code class='language-cpp'>double</code></pre> deci functia se asteapta ca parametrul <var>y</var> sa fie o referinta la ceva care chiar exista in memorie, nu ar merge <pre class='inline'><code class='language-cpp'>f(1, 2.0)</code></pre>.\n</div>\n<div>\nDeci la <pre class='inline'><code class='language-cpp'>f(2, 3.0);</code></pre> se apeleaza prima functie, <var>x</var> e diferit de 0 si se afiseaza 3.0 / 2 adica <pre class='inline'><code class='language-cpp'>1.5</code></pre>.\nLa linia 24: <pre class='inline'><code class='language-cpp'>f(x, y);</code></pre> desi se potrivesc ambele functii a doua este preferata, e mai specifica, si se apeleaza <pre class='inline'><code class='language-cpp'>void f(int x, double&amp; y)</code></pre> si se afiseaza <pre class='inline'><code class='language-cpp'>4 si 10</code></pre>.\n</div>\n<div>\nDaca vrei ca functia sa accepte numai ceva temporar poti scrie <pre class='inline'><code class='language-cpp'>void f(int x, double&amp;&amp; y)</code></pre> (asta de la C++11 incoace), acum <pre class='inline'><code class='language-cpp'>f(1, 2.0);</code></pre> merge dar <pre class='inline'><code class='language-cpp'>f(1, x);</code></pre> nu merge.\n</div></div>", "tags": ["easy", "references", "function overloading", "correct"]}, {"id": 18, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nvoid afis(char v[][20], int rows) {\n\t\n\tfor (int i = 0; i &lt; rows; ++i) {\n\t\tfor (int j = 0; j &lt; strlen(v[i]); ++j) {\n\t\t\tcout &lt;&lt; v[i][j] &lt;&lt; &quot; &quot;;\n\t\t}\n\t\tcout &lt;&lt; &#39;\\n&#39;;\n\t}\n}\n\nint main() {\n\tchar v[3][20] = {\n\t\t&quot;Creion&quot;,\n\t\t&quot;Hartie&quot;,\n\t\t&quot;Pix&quot;\n\t};\n\n\tafis(v, 3);\n}</code></pre>", "solution": "<div><div>\nProgramul e corect, se afiseaza:\n</div>\n<samp class='output'>C r e i o n\nH a r t i e\nP i x</samp>\n<div>\nSe creeaza o &quot;matrice&quot; de <pre class='inline'><code class='language-cpp'>char</code></pre> sau mai bine zis, un array de cuvinte, unde lungimea maxima a cuvintelor este 20 si exista 3 cuvinte. Daca ai in parametrii functiei array-uri care au mai multe dimensiuni (in cazul asta 2) trebuie sa specifici marimea pentru fiecare dimensiune in afara de prima (poti si la prima dar daca nu faci asta dimensiunea e variabila). \n</div>\n<pre class='block'><code>void f(int v[][][100])  { /* ... */ } \t// gresit\nvoid f(int v[25][][30]) { /* ... */ } \t// gresit\nvoid f(int v[][20][10]) { /* ... */ } \t// corect\nvoid f(int v[10][20][10]) { /* ... */ } // corect</code></pre>\n<div><pre class='inline'><code class='language-cpp'>void afis(char v[][20], int rows)</code></pre> are ca prim parametru o matrice de <pre class='inline'><code class='language-cpp'>char</code></pre> cu 20 coloane si numar variabil de linii, parametrul <var>rows</var> inseamna numarul de linii.\n</div>\n<div>\nLuam fiecare linie pe rand (pe fiecare linie e un cuvant), acum parcurgem pe rand literele cuvantului respectiv, care poate avea mai putin de 20 de caractere de aceea folosim <pre class='inline'><code class='language-cpp'>strlen</code></pre> care e o functie care ne da numarul de caractere din cuvant. Se afiseaza literele cuvintelor separate prin spatiu, iar cand se termina cuvantul se trece la o linie noua si la urmatorul cuvant.\n</div></div>", "tags": ["correct", "easy", "2d array"]}, {"id": 19, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid f(int x, double y, const int z) \n{\n\tcout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;\n\tcout &lt;&lt; y / 2 &lt;&lt; endl;\n\tint temp = z + x;\n\n\tfor (int i = 0; i &lt; temp; ++i)\n\t{\n\t\tcout &lt;&lt; &#39;a&#39; &lt;&lt; &#39; &#39; &lt;&lt; endl;\n\t}\n}\n\nvoid f(int x,const double y, int z)\n{\n\twhile (x &gt; 1) \n\t{\n\t\tcout &lt;&lt; y &lt;&lt; &quot;, &quot;;\n\t\tx--;\n\t}\n\tcout &lt;&lt; endl;\n\n\tif (z &lt; 0) z = -z;\n\t\n\tcout &lt;&lt; x + z &lt;&lt; endl;\n}\n \n\nint main() {\n\tconst int x = 4;\n\tconst double y = 3.14;\n\tf(2, 2.0, x);\n\tf(3, y, 3);\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 16\n</div>\n<samp class='error'>function &#39;void f(int,double,const int)&#39; already has a body</samp>\n<div>\nNu te poti baza pe faptul ca un parametru este sau nu <pre class='inline'><code class='language-cpp'>const</code></pre> atunci cand vrei sa supraincarci o functie, decat daca acel parametru este <b>pointer sau referinta</b> pentru ca daca nu este pointer sau referinta se transmite argumentul prin valoare, adica se copiaza si nu conteaza ca parametrul e <pre class='inline'><code class='language-cpp'>const</code></pre> pentru ca oricum este o copie.\n</div>\n<div>\nEroarea spune ca practic definesti aceeasi functie de 2 ori, nu conteaza ca unii paramterii sunt <pre class='inline'><code class='language-cpp'>const</code></pre> pentru ca nu sunt referinte sau pointeri. Ca programul sa functioneze corect poti schimba prima functie (linia 4) in <pre class='inline'><code class='language-cpp'>void f(int x, double&amp; y, const int z)</code></pre>, acum primeste o referinta la <pre class='inline'><code class='language-cpp'>double</code></pre>, ceea ce ii permite sa modifice valoarea argumentului cand se apeleaza functia, deci nu mai face acelasi lucru cu a doua functie care nu putea face asta pentru ca argumentul se transmite prin copiere.\n</div>\n<div>\nCu modificarea de mai sus, <pre class='inline'><code class='language-cpp'>f(2, 2.0, x);</code></pre> se apeleaza a doua functie pentru ca <pre class='inline'><code class='language-cpp'>2.0</code></pre> este o valoare temporara care nu exista in memorie si nu putem avea referinta la ea. La urmatoarea linie <pre class='inline'><code class='language-cpp'>f(3, y, 3);</code></pre> se apeleaza a doua functie pentru ca la prima ai referinta la un <pre class='inline'><code class='language-cpp'>double</code></pre> care NU e const, deci ai putea modifica valorea lui in functie si se va reflecta si in afara functiei, dar in <pre class='inline'><code class='language-cpp'>main</code></pre>, <var>y</var> este <pre class='inline'><code class='language-cpp'>const double</code></pre> si nu-i poti modifica valorea. La final se afiseaza:\n</div>\n<samp class='output'>2,\n5\n3.14, 3.14,\n4</samp></div>", "tags": ["easy", "incorrect", "const", "function overloading"]}, {"id": 20, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint myFunction(int A = 1, int B = 2, int C) {\n\tint temp = A;\n\tfor (int i = 0; i &lt; B; ++i)\n\t{\n\t\ttemp += C;\n\t\tC--;\n\t}\n\treturn temp;\n}\n\nint main() {\n\tint num = myFunction(1, 2, 3);\n\tcout &lt;&lt; num &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 4: <pre class='inline'><code class='language-cpp'>int myFunction(int A = 1, int B = 2, int C) {</code></pre>.\n</div>\n<samp class='error'>default argument not at end of parameter list</samp>\n<div>\nDaca ai o functie cu parametrii care au valori implicite, ei trebuie sa se afle la sfarsit, nu pot urma parametrii fara valori implicite dupa cei cu valori implicite.\nCa sa fie corect modifica linia 4 in <pre class='inline'><code class='language-cpp'>int myFunction(int A = 1, int B = 2, int C = 0) {</code></pre> sau in <pre class='inline'><code class='language-cpp'>int myFunction(int A, int B, int C) {</code></pre>. La final se afiseaza:\n</div>\n<samp class='output'>6</samp></div>", "tags": ["easy", "incorrect"]}, {"id": 21, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint f(double x)\n{\n\tint i = 1;\n\twhile (i * i &lt; x)\n\t{\n\t\ti++;\n\t\tcout &lt;&lt; &#39;*&#39;;\n\t}\n\tcout &lt;&lt; &#39;!&#39; &lt;&lt; endl;\n\treturn i;\n}\n\nint f(int x)\n{\n\tif (x % 2 == 0)\n\t\treturn x * 2;\n\telse\n\t\treturn x * 3 - 10;\n}\n\nint main()\n{\n\tshort a = 3;\n\tfloat b = 5.0f;\n\n\tint x = f(a);\n\tint y = f(b);\n\n\tcout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>**!\n-1 3</samp>\n<div>\nFunctia <var>f</var> este supraincarcata. La linia 29: <pre class='inline'><code class='language-cpp'>int x = f(a);</code></pre> se apeleaza functia <var>f</var> cu un <pre class='inline'><code class='language-cpp'>short int</code></pre>. Ambele variante ale functiei <var>f</var> fac o conversie deci nu ar trebui sa fie ambiguu apelul, adica sa nu se stie care functie se apeleaza? In cazul asta nu pentru ca, desi ambele functii fac o conversie, cea de la <pre class='inline'><code class='language-cpp'>short int</code></pre> la <pre class='inline'><code class='language-cpp'>int</code></pre> este mai speciala, se numeste &quot;promotie&quot; (adica valorile care se reprezinta cu un <pre class='inline'><code class='language-cpp'>short int</code></pre> se pot reprezenta la fel de exact si cu un <pre class='inline'><code class='language-cpp'>int</code></pre>). Cand se alege ce functie se apeleaza, promotiile sunt mai importante decat conversile obisnuite si de aceea se apeleaza a doua functie. \n</div>\n<div>\nLa linia 30: <pre class='inline'><code class='language-cpp'>int y = f(b);</code></pre> se apeleaza functia <var>f</var> cu un <pre class='inline'><code class='language-cpp'>float</code></pre>. Este aceeasi situatie de mai sus, din nou conversia din <pre class='inline'><code class='language-cpp'>float</code></pre> in <pre class='inline'><code class='language-cpp'>double</code></pre> este &quot;promotie&quot; deci se alege prima functie. Mai multe detalii <a href='./tips.html#function-overloading'>aici</a>.\n</div></div>", "tags": ["correct", "easy", "function overloading"]}, {"id": 22, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid multiply(int* v, int n, int x)\n{\n\tfor (int i = 0; i &lt; n; ++i)\n\t\tv[i] *= x;\n}\n\nvoid print(int* v, int n)\n{\n\tfor (int i = 0; i &lt; n; ++i)\n\t\tcout &lt;&lt; v[i] &lt;&lt; &#39; &#39;;\n\t\n\tcout &lt;&lt; endl;\n}\n\nint main()\n{\n\tint* i = new int[5]{ 1, 2, 3, 4, 5 }; \n\t// din C++11 https://www.geeksforgeeks.org/uniform-initialization-in-c/\n\n\tint* j = i;\n\n\tmultiply(i, 5, 2);\n\tprint(i, 5);\n\tprint(j, 5);\n\n\tdelete[] i;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>2 4 6 8 10\n2 4 6 8 10</samp>\n<div>\nSe creeaza un array alocat dinamic cu 5 elemente (1, 2, 3, 4 si 5). Se creeaza un pointer <var>j</var> care arata spre aceeasi zona de memorie ca <var>i</var> (primul element din array). Functia <pre class='inline'><code class='language-cpp'>void multiply(int* v, int n, int x)</code></pre> primeste ca argumente pointerul <var>i</var>, lungimea array-ului si un numar cu care inmulteste toate elementele. La linia 26: <pre class='inline'><code class='language-cpp'>print(i, 5);</code></pre> si linia 27: <pre class='inline'><code class='language-cpp'>print(j, 5);</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>void print(int* v, int n)</code></pre> care printeaza elementele array-ului. Se printeaza aceleasi valori de 2 ori pentru ca <var>i</var> si <var>j</var> arata spre aceeasi zona de memorie.\n</div>\n<div>\nCand scrii o functie <pre class='inline'><code class='language-cpp'>void f(int v[]) { /* ... */ }</code></pre> este acelasi lucru cu <pre class='inline'><code class='language-cpp'>void f(int *v) { /* ... */ }</code></pre> (nu conteaza ca returneaza <pre class='inline'><code class='language-cpp'>void</code></pre> sau array-ul/pointerul este <pre class='inline'><code class='language-cpp'>int</code></pre>). <pre class='inline'><code class='language-cpp'>v[i]</code></pre> este de fapt <pre class='inline'><code class='language-cpp'>*(v + i)</code></pre>.\n</div>\n<div>\nMereu array-urile sunt transmise prin &quot;referinta&quot; la o functie (de fapt cum este mai sus, se transmite pointerul la primul element prin valoare dar asta nu conteaza pentru ca arata spre aceeasi zona de memorie, adica array-ul initial).\n</div></div>", "tags": ["correct", "easy", "dynamic memory allocation", "pointers"]}, {"id": 23, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int x;\n\nconst int f(int x, int y)\n{\n\tint temp = x + y;\n\treturn temp;\n}\n\nint main()\n{\n\tint a = f(2, 3);\n\tcout &lt;&lt; a &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul nu e corect, avem eroare la linia 4: <pre class='inline'><code class='language-cpp'>const int x;</code></pre>\n</div>\n<samp class='error'>&#39;x&#39;: &#39;const&#39; object must be initialized if not &#39;extern&#39;</samp>\n<div>\nCand creezi o variabila <pre class='inline'><code class='language-cpp'>const</code></pre> trebuie sa-i dai si o valore neaparat, (daca nu e si <pre class='inline'><code class='language-cpp'>extern</code></pre>, <a href='https://stackoverflow.com/a/10422050'>vezi aici</a>) pentru ca nu este stocata in memorie. In cod, unde apare o variabila <pre class='inline'><code class='language-cpp'>const</code></pre> este inlocuita cu valorea ei. Ca sa fie corect modifica linia 4 in: <pre class='inline'><code class='language-cpp'>const int x = 0;</code></pre> de exemplu.\n</div>\n<pre class='block'><code>const int x; \n// gresit\n\nconst int x;\nx = 20;\n// gresit\n\nconst int x = 1;\n// corect</code></pre>\n<div>\nLa final se afiseaza 5 (poti initializa un <pre class='inline'><code class='language-cpp'>int</code></pre> cu valoarea unui <pre class='inline'><code class='language-cpp'>const int</code></pre>).\n</div></div>", "tags": ["incorrect", "const", "easy"]}, {"id": 24, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid f(int*&amp; t, int&amp; x)\n{\n\tcout &lt;&lt; &quot;in functia f&quot; &lt;&lt; endl;\n\tt = &amp;x;\n}\n\nint main()\n{\n\tint x = 20;\n\tint y = 30;\n\tint* p = &amp;x;\n\n\t(*p)++;\n\tf(p, y);\n\t(*p)--;\n\n\tcout &lt;&lt; *p &lt;&lt; &#39; &#39; &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>in functia f\n29 21 29</samp>\n<div>\nAvem doua variabile <var>x</var> si <var>y</var> cu valorile 20 si 30, si un pointer <var>p</var> la <var>x</var>, <var>p</var> arata spre zona de memorie unde se afla <var>x</var>. La linia 16: <pre class='inline'><code class='language-cpp'>(*p)++;</code></pre>, mai intai dereferentiezi pointerul ca sa ai acces la zona de memorie unde arata, adica la <var>x</var> si dupa incrementezi valoarea cu 1, deci practic inseamna <pre class='inline'><code class='language-cpp'>x++;</code></pre>(acum x e 21).\n</div>\n<div>\nCand transmiti parametrii prin referinta (la o functie) modificarile parametrilor se vor reflecta si in afara functiei. In cazul asta functia <var>f</var> primeste un pointer transmis prin referinta, deci il putem modifica in interiorul functiei si se va modifica si in locul unde este apelata functia (in cazul asta in <var>main</var>). La linia 17: <pre class='inline'><code class='language-cpp'>f(p, y)</code></pre> se apeleaza <var>f</var>, se afiseaza <pre class='inline'><code class='language-cpp'>&quot;in functia f&quot;</code></pre> si dupa, pointerul <var>t</var> din functie arata spre parametrul <var>x</var>. Dar pointerul <var>t</var> este practic pointerul <var>p</var> din <var>main</var>, deci acum <var>p</var> nu mai arata spre zona de memorie unde este <var>x</var>, ci unde este <var>y</var>. <pre class='inline'><code class='language-cpp'>(*p)--</code></pre> inseamna de fapt <pre class='inline'><code class='language-cpp'>y--;</code></pre> (y e 29 acum). La final <var>x</var> este 21, <var>y</var> este 29, iar <var>p</var> arata spre zona de memorie unde e <var>y</var>.\n</div></div>", "tags": ["easy", "correct", "pointers"]}, {"id": 25, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid f(int v[])\n{\n\tcout &lt;&lt; &quot;Prima functie&quot; &lt;&lt; endl;\n}\n\nvoid f(int* p)\n{\n\tcout &lt;&lt; &quot;A doua functie&quot; &lt;&lt; endl;\n}\n\nint main()\n{\n\tint v[] = { 1, 2, 3, 4, 5 };\n\tf(v);\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 9: <pre class='inline'><code class='language-cpp'>void f(int *p)</code></pre>\n</div>\n<samp class='error'>function &#39;void f(int [])&#39; already has a body</samp>\n<div>\nCand transmiti un array ca parametru isi pierde &quot;forma&quot; de array, devine un pointer la primul element. Acum, <pre class='inline'><code class='language-cpp'>void f(int v[])</code></pre> si <pre class='inline'><code class='language-cpp'>void f(int* v)</code></pre> par lucruri diferite dar <pre class='inline'><code class='language-cpp'>void f(int v[])</code></pre> este transformat de compilator in <pre class='inline'><code class='language-cpp'>void f(int* v)</code></pre> deci cele 2 functii au aceeasi signatura (nume, numar parametrii, ordine parametrii, tip paramterii).  Practic incerci sa definesti functia <var>f</var> din nou fara sa schimbi ceva la ea (in afara de corp). Ca sa functioneze corect ai variantele:\n</div>\n<div>\n1) schimbi linia 4 in <pre class='inline'><code class='language-cpp'>void(const int v[])</code></pre>, acum prima functie primeste ca parametru un array de <pre class='inline'><code class='language-cpp'>const int</code></pre>. Array-ul din main este de tip <pre class='inline'><code class='language-cpp'>int</code></pre> deci se apeleaza a doua functie.\n</div>\n<div>\n2) schimbi linia 9 in <pre class='inline'><code class='language-cpp'>void(const int* p)</code></pre>, acum a doua functie primeste ca parametru un pointer la un <pre class='inline'><code class='language-cpp'>const int</code></pre> (gandeste ca e identic cu <pre class='inline'><code class='language-cpp'>void(const int p[])</code></pre>). Array-ul din main este de tip <pre class='inline'><code class='language-cpp'>int</code></pre> deci se apeleaza prima functie.\n</div></div>", "tags": ["easy", "incorrect", "pointers"]}, {"id": 26, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\tint v[] = { 1, 2, 3, 4, 5 };\n\t\n\tint* p = v;\n\tp++;\n\n\tp[-1] = 10;\n\n\tfor (int i = 0; i &lt; 5; ++i)\n\t\tcout &lt;&lt; v[i] &lt;&lt; &#39; &#39;;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>10 2 3 4 5</samp>\n<div>\nDeci avem un vector <var>v</var> cu 5 elemente (nu mai trebuie sa pui intre <pre class='inline'><code class='language-cpp'>[]</code></pre> numarul de elemente daca spui care sunt, se deduce automat ca sunt 5). <pre class='inline'><code class='language-cpp'>int* p = v;</code></pre> pare ca initializeaza <var>p</var> cu array-ul <var>v</var> dar de fapt inseamna <pre class='inline'><code class='language-cpp'>int* p = &amp;v[0];</code></pre>. Acum <var>p</var> arata spre zona din memorie unde e primul element din array. <pre class='inline'><code class='language-cpp'>p++;</code></pre> inseamna ca <var>p</var> arata acum spre al doilea element. (intr-un array elementele sunt unele langa altele, in ordine, in memorie).\n</div>\n<div>\nPentru un array sau un pointer <var>v</var> si un indice <var>i</var>, expresia <pre class='inline'><code class='language-cpp'>v[i]</code></pre> inseamna <pre class='inline'><code class='language-cpp'>*(v + i)</code></pre>. Te gandesti ca <var>v</var> este un pointer, te duci in dreapta cu <var>i</var> pozitii si dupa dereferentiezi pointerul ca sa ai acces la elementul la care arata. (din cauza asta <pre class='inline'><code class='language-cpp'>v[i]</code></pre> este la fel ca <pre class='inline'><code class='language-cpp'>i[v]</code></pre> pentru ca <pre class='inline'><code class='language-cpp'>*(v + i)</code></pre> e la fel ca <pre class='inline'><code class='language-cpp'>*(i + v)</code></pre> ). Vezi <a href='https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c'>aici</a> despre array-uri pe SO.\n</div>\n<div>\nDeci <var>p</var> arata spre al doilea element si <pre class='inline'><code class='language-cpp'>p[-1] = 10;</code></pre> inseamna <pre class='inline'><code class='language-cpp'>*(p - 1) = 10;</code></pre> adica te duci in stanga cu o pozitie (la primul element) si modifici valoarea in 10. Deci primul element este 10 acum. La final elementele sunt <pre class='inline'><code class='language-cpp'>10, 2, 3, 4, 5</code></pre>\n</div></div>", "tags": ["correct", "easy", "pointers"]}, {"id": 27, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid afis(int v[], int n)\n{\n\tfor (int i = 0; i &lt; n; ++i)\n\t\tcout &lt;&lt; v[i] &lt;&lt; &#39; &#39;;\n\tcout &lt;&lt; endl;\n}\n\nint main()\n{\n\tint v[] = { 1, 2, 3, 4, 5 };\n\tint w[] = { 10, 20, 30, 40, 50 };\n\n\tv = w;\n\tafis(v, 5);\n\tafis(w, 5);\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 16: <pre class='inline'><code class='language-cpp'>v = w;</code></pre>\n</div>\n<samp class='error'>expression must be a modifiable lvalue</samp>\n<div>\nNu poti modifica un intreg array dupa ce l-ai creat, poti sa modifici elementele pe rand dar nu ceva de genul <pre class='inline'><code class='language-cpp'>v = w;</code></pre>. Ca sa functioneze corect programul trebuie stearsa linia 16: <pre class='inline'><code class='language-cpp'>v = w;</code></pre>. Daca vrei sa copiezi tot vectorul deodata poti folosi functia <pre class='inline'><code class='language-cpp'>memcpy</code></pre> care primeste ca parametrii: un pointer ca destinatie, un pointer ca sursa si dimensiunea in bytes. Poti inlocui linia 16 cu <pre class='inline'><code class='language-cpp'>memcpy(v, w, 5 * sizeof(int));</code></pre>. <pre class='inline'><code class='language-cpp'>sizeof</code></pre> e un operator care iti da dimensiunea in bytes, avem 5 numere deci in total 5 * dimensiunea unui <pre class='inline'><code class='language-cpp'>int</code></pre> bytes. Dar mai bine folosesti un <pre class='inline'><code class='language-cpp'>vector</code></pre> din STL si nu te mai complici cu <pre class='inline'><code class='language-cpp'>memcpy</code></pre>.\n</div></div>", "tags": ["easy", "incorrect"]}, {"id": 28, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid f(short x, double y)\n{\n\tfor (short i = 0; i &lt; x; ++i)\n\t\tcout &lt;&lt; y &lt;&lt; &quot;, &quot;;\n\tcout &lt;&lt; &quot;Gata!&quot; &lt;&lt; endl;\n}\n\nvoid f(int x, long double y)\n{\n\tint temp = y;\n\tcout &lt;&lt; x + temp &lt;&lt; endl;\n}\n\nint main()\n{\n\tshort x = 5;\n\tlong double y = 3.14;\n\tf(x, y);\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare la linia 21: <pre class='inline'><code class='language-cpp'>f(x, y);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nFunctia <var>f</var> este supraincarcata. In <var>main</var> se apeleaza <var>f</var> cu un <pre class='inline'><code class='language-cpp'>short int</code></pre> si un <pre class='inline'><code class='language-cpp'>long double</code></pre>. Luam argumentele pe rand si vedem care varianta a lui <var>f</var> se potriveste cel mai bine pentru fiecare (pot fi mai multe). Primul argument este <pre class='inline'><code class='language-cpp'>short int</code></pre> care se potriveste exact cu prima functie (merge si a doua functie dar acolo trebuie o conversie la <pre class='inline'><code class='language-cpp'>int</code></pre> iar aici nu trebuie). Al doilea argument este <pre class='inline'><code class='language-cpp'>long double</code></pre> care se potriveste exact cu a doua functie (la fel ar merge si o conversie la <pre class='inline'><code class='language-cpp'>double</code></pre> pentru prima functie dar la a doua nu trebuie).\n</div>\n<div>\nDaca ne gandim ca si cum am avea niste multimi, multimea de functii care se potrivesc cel mai bine pentru primul argument este { functia_1 }, iar pentru al doilea argument { functia_2 }. Intersectia dintre multimile astea este &empty;, deci nu se stie ce functie sa se apeleze. (mai multe detalii <a href=\"tips.html#function-overloading\">aici</a>).\n</div>\n<div>\nCa programul sa functioneze corect poti schimba linia 4: <pre class='inline'><code class='language-cpp'>void f(short x, double y)</code></pre> in <pre class='inline'><code class='language-cpp'>void f(short x,long double y)</code></pre> de exemplu. Acum la linia 22: <pre class='inline'><code class='language-cpp'>f(x, y);</code></pre> al doilea argument se potriveste si la prima functie. Deci multimea de functii care se potrivesc cel mai bine pentru argumentul <var>y</var> (care este de tip <pre class='inline'><code class='language-cpp'>long double</code></pre>) este { functia_1, functia_2 }, iar pentru argumentul <var>x</var> ramane { functia_1 }. Intersectia dintre multimile astea este prima functie (<pre class='inline'><code class='language-cpp'>void f(short x,long double y)</code></pre>), deci ea se apeleaza.\nLa final se afiseaza:\n</div>\n<samp class='output'>3.14, 3.14, 3.14, 3.14, 3.14, Gata!</samp></div>", "tags": ["easy", "incorrect", "function overloading"]}, {"id": 29, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\tint a = 500;\n\tint b = 250;\n\tint* const p1 = &amp;a;\n\tconst int* p2 = &amp;b;\n\tp2 = p1;\n\tcout &lt;&lt; *p1 &lt;&lt; &#39; &#39; &lt;&lt; *p2;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>500 500</samp>\n<div>\n<pre class='inline'><code class='language-cpp'>int* const p1 = &amp;a;</code></pre> inseamna ca se creeaza un pointer <pre class='inline'><code class='language-cpp'>const</code></pre> cu numele <var>p1</var> la un <pre class='inline'><code class='language-cpp'>int</code></pre>. Deci pointerul este <pre class='inline'><code class='language-cpp'>const</code></pre>, nu valoarea la care arata (adica <pre class='inline'><code class='language-cpp'>*p1 = 100;</code></pre> e corect pentru ca modifici valorea de la zona de memorie la care arata, dar <pre class='inline'><code class='language-cpp'>p1 = &amp;b;</code></pre> nu e corect pentru ca nu ai voie sa modifici spre ce zona de memorie arata <var>p1</var>).\n</div>\n<div>\n In schimb <var>p2</var> este un pointer simplu la un <pre class='inline'><code class='language-cpp'>const int</code></pre>. Deci acum pointerul NU mai este <pre class='inline'><code class='language-cpp'>const</code></pre> dar arata spre un <pre class='inline'><code class='language-cpp'>const int</code></pre> ( <pre class='inline'><code class='language-cpp'>p2 = &amp;a;</code></pre> e corect pentru ca poti schimba zona de memorie la care arata, dar <pre class='inline'><code class='language-cpp'>*p2 = 100;</code></pre> nu e corect pentru ca modifici ceva ce este <pre class='inline'><code class='language-cpp'>const int</code></pre>). Deci este corect <pre class='inline'><code class='language-cpp'>p2 = p1;</code></pre>, acum <var>p2</var> arata spre aceeasi zona de memorie ca <var>p1</var>, adica acolo unde este variabila <var>a</var>.\n</div>\n<div>\nLa final se dereferentiaza pointerii (cu <pre class='inline'><code class='language-cpp'>*</code></pre>) ca sa ai acces la variabila de la zona de memorie la care arata (adica la <var>a</var>).\n</div></div>", "tags": ["easy", "correct", "pointers"]}, {"id": 30, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid swap(int* const x, int* const y)\n{\n\tint temp = *x;\n\t*x = *y;\n\t*y = temp;\n}\n\nint main()\n{\n\tint a = 500;\n\tint b = 45;\n\tint c = 1000;\n\tswap(&amp;a, &amp;b);\n\tswap(&amp;b, &amp;c);\n\n\tcout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>45 1000 500</samp>\n<div>\nFunctia <var>swap</var> are ca parametrii 2 pointeri <pre class='inline'><code class='language-cpp'>const</code></pre> la <pre class='inline'><code class='language-cpp'>int</code></pre>. (adica pointerii sunt constanti nu valorile de la zona de memorie la care arata). Poti modifica ce se afla la adresa la care arata pointerii dar nu poti schimba la ce adresa arata pointerii. Functia <var>swap</var> practic interschimba valorile a 2 variabile, folosindu-se de adresa lor din memorie (adica prin pointerii <var>x</var> si <var>y</var>). Variabila <var>temp</var> tine minte ce valoare este la adresa la care arata pointerul <var>x</var> (cu <pre class='inline'><code class='language-cpp'>*</code></pre> dereferentiezi pointerul ca sa ai acces la ce se afla la adresa de memorie la care arata). Apoi variabila de la adresa unde arata <var>x</var> ia valoarea variabilei de la adresa unde arata <var>y</var>. La final variabila de la adresa unde arata <var>y</var> ia valorea lui <var>temp</var>.\n</div>\n<div>\nIn <var>main</var> se apeleaza <var>swap</var> cu adresele variabilelor, nu cu ele direct, pentru ca functia <var>swap</var> se asteapta sa primeasca niste adrese (ca sa aiba la ce sa arate pointerii). Mai intai se interschimba <var>a</var> cu <var>b</var> si dupa <var>b</var> cu <var>c</var>. La final <var>a</var> e 45, <var>b</var> e 1000 si <var>c</var> e 500.\n</div></div>", "tags": ["correct", "easy", "pointers"]}, {"id": 31, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\n\nint main() {\n\tint v[] = { 1, 2, 3, 4, 5 };\n\tint s = 0;\n\tfor (int n : v)\t\t// din C++11\n\t{\n\t\ts += n;\n\t\tn *= 2;\n\t}\n\n\tcout &lt;&lt; s &lt;&lt; endl;\n\n\tfor (int i = 0; i &lt; 5; ++i)\n\t\tcout &lt;&lt; v[i] &lt;&lt; &#39; &#39;;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>15\n1 2 3 4 5</samp>\n<div>\n<pre class='inline'><code class='language-cpp'>for(int n : v) { /* ... */ }</code></pre> se numeste <a href=\"https://www.geeksforgeeks.org/range-based-loop-c/\">range-based for loop</a>. De obicei se foloseste cu containerele din STL dar merge si cu array-uri simple (dar nu merge cu pointeri).\n</div>\n<pre class='block'><code>void f(int v[])\n{\n\tfor (int i : v)\n\t\tcout &lt;&lt; i &lt;&lt; &#39; &#39;;\n\n\t// eroare, v nu este array, este de fapt un pointer.\n\t// Cand transmiti un array ca parametru, se transforma in pointer\n\t// la primul element, se pierde informatia despre dimensiunea si tipul\n\t// array-ului (acum v e doar int* in loc de int[100] de exemplu)\n\t// asta se numeste &#39;array to pointer decay&#39; \n\t// Functia este identica cu:\n\t//\n\t// void f(int *v) { ... }\n}\n\nvoid g( int(&amp;v)[5] )\n{\n\tfor (int i : v)\n\t\tcout &lt;&lt; i &lt;&lt; &#39; &#39;;\n\n\t// aici merge, se transmite array-ul prin &#39;referinta&#39;\n\t// adica se pastreaza &#39;forma&#39; (dimensiunea adica) nu se\n\t// mai transforma in pointer. Range based for loop are nevoie\n\t// de dimensiunea intreg array-ului, !! deci trebuie sa specifici, aici e 5 !!\n\t// (de asta nu merge cu pointeri, se pierde informatia despre dimensiune)\n}</code></pre>\n\n<pre class='block'><code>for(int n : v)\n{\n\ts += n;\n\tn *= 2;\n}\n\n// este ca si cum ai scrie:\n\nfor(int i = 0; i &lt; 5; ++i)\n{\n\tint n = v[i]; // n este o copie !! \n\n\ts += n;\n\tn *= 2;\t\t  // NU se modifica si elementul din array\n}</code></pre>\n\n<div>\nDaca vrei sa si modifici elementele:\n</div>\n<pre class='block'><code>for(int&amp; n : v)\n{\n\ts += n;\n\tn *= 2; \n}\n\n// este ca si cum ai scrie:\n\nfor(int i = 0; i &lt; 5; ++i)\n{\n\tint&amp; n = v[i]; // n este o referinta !! \n\n\ts += n;\n\tn *= 2;        // se modifica si elementul din array\n}</code></pre>\n<div>\nRevenind la problema, parcurgi toate elementele din <var>v</var> cu un range for loop, aduni in <var>s</var> fiecare element si modifici o copie a elementului din array (deci array-ul nu se modifica). Dupa se afiseaza suma, si pe alta linie elementele din array-ul <var>v</var>, care nu s-au schimbat.\n</div></div>", "tags": ["easy", "correct"]}, {"id": 32, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid f(int x, int y, double z, char w)\n{\n\tcout &lt;&lt; &quot;Prima functie.&quot;;\n}\n\nvoid f(int x, long y, double z, int w)\n{\n\tcout &lt;&lt; &quot;A doua functie.&quot;;\n}\n\nvoid f(short x, int y, float z, char w)\n{\n\tcout &lt;&lt; &quot;A treia functie.&quot;;\n}\n\nint main() {\n\tf(3, 4, 5.0, &#39;a&#39;);\n\t\n\tshort int x = 10;\n\tf(x, 50, 1.0f, 2);\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare la linia 23: <pre class='inline'><code class='language-cpp'>f(x, 50, 1.0f, 2);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nCum spune si eroarea, mai multe functii se potrivesc pentru <pre class='inline'><code class='language-cpp'>f(x, 50, 1.0f, 2);</code></pre> si niciuna nu e mai buna ca celelalte deci nu se stie care sa se apeleze.\n</div>\n<div>\nSa incepem mai intai cu <pre class='inline'><code class='language-cpp'>f(3, 4, 5.0, &#39;a&#39;);</code></pre> care e ok. Ne uitam la fiecare argument pe rand si vedem care varianta a functiei <var>f</var> (care e supraincarcata) se potriveste cel mai bine. Mai intai <pre class='inline'><code class='language-cpp'>3</code></pre>, se potrivesc primele 2 functii pentru ca avem un <pre class='inline'><code class='language-cpp'>int</code></pre> si nu trebuie nicio conversie (trebuie la ultima functie). Sa zicem ca punem functiile astea in o multime: { functia_1, functia_2 }. Acum pentru urmatorul argument: <pre class='inline'><code class='language-cpp'>4</code></pre>, este un <pre class='inline'><code class='language-cpp'>int</code></pre> si functiile care se potrivesc sunt prima si ultima, pentru ca nu fac vreo conversie, deci multimea asta este { functia_1, functia_3 }. Pentru al treilea argument, <pre class='inline'><code class='language-cpp'>5.0</code></pre>, care este un <pre class='inline'><code class='language-cpp'>double</code></pre> se potrivesc primele doua functii, la fel pentru ca nu trebuie conversii, deci multimea asta este { functia_1, functia_2 }. Aceeasi logica si pentru ultimul argument, <pre class='inline'><code class='language-cpp'>&#39;a&#39;</code></pre>, care este <pre class='inline'><code class='language-cpp'>char</code></pre>, multimea asta este { functia_1, functia_3 }. Ca sa vedem ce functie se apeleaza luam multimile astea si le intersectam. { functia_1, functia_2 } &cap; { functia_1, functia_3 } &cap; { functia_1, functia_2 } &cap; { functia_1, functia_3 } = { functia_1 }, deci se apeleaza prima functie.\n</div>\n<div>\nAcum, sa ne uitam la <pre class='inline'><code class='language-cpp'>f(x, 50, 1.0f, 2);</code></pre>, unde <var>x</var> este un <pre class='inline'><code class='language-cpp'>short int</code></pre>:\n</div>\n<div class='table-responsive'>\n<table class=\"table table-sm align-middle table-bordered border-altdark\">\n\t<thead class='align-middle'>\n\t\t<tr>\n\t\t\t<th scope=\"col\" class='text-center'>Arg.</th>\n\t\t\t<th scope=\"col\" class='text-center'>Functii care se potrivesc</th>\n\t\t\t<th scope=\"col\" class='text-center'>Functii care nu se potrivesc</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<th class='text-center' scope=\"row\"><pre class='inline'><code class='language-cpp'>x (short)</code></pre></th>\n\t\t\t<td>\n\t\t\t\t<b>Functia 3:</b> <i class='text-nowrap'>void f(<pre class='inline'><code class='language-cpp'>short x</code></pre>, int y, float z, char w)</i> (pentru ca se potriveste exact, e deja <pre class='inline'><code class='language-cpp'>short int</code></pre>)\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<b>Functia 1:</b> <i class='text-nowrap'>void f(<pre class='inline'><code class='language-cpp'>int x</code></pre>, int y, double z, char w)</i> (pentru ca face conversie la <pre class='inline'><code class='language-cpp'>int</code></pre>)\n\t\t\t\t<br>\n\t\t\t\t<b>Functia 2:</b> <i class='text-nowrap'>void f(<pre class='inline'><code class='language-cpp'>int x</code></pre>, long y, double z, int w)</i> (pentru ca face conversie la <pre class='inline'><code class='language-cpp'>int</code></pre>)\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th class='text-center' scope=\"row\"><pre class='inline'><code class='language-cpp'>50 (int)</code></pre></th>\n\t\t\t<td>\n\t\t\t\t<b>Functia 1:</b> <i class='text-nowrap'>void f(int x, <pre class='inline'><code class='language-cpp'>int y</code></pre>, double z, char w)</i> (pentru ca nu trebuie sa se faca conversie)\n\t\t\t\t<br>\n\t\t\t\t<b>Functia 3:</b> <i class='text-nowrap'>void f(short x, <pre class='inline'><code class='language-cpp'>int y</code></pre>, float z, char w)</i> (pentru ca nu trebuie sa se faca conversie)\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<b>Functia 2:</b> <i class='text-nowrap'>void f(int x, <pre class='inline'><code class='language-cpp'>long y</code></pre>, double z, int w)</i> (pentru ca face conversie la <pre class='inline'><code class='language-cpp'>long</code></pre>)\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th class='text-center' scope=\"row\"><pre class='inline'><code class='language-cpp'>1.0f (float)</code></pre></th>\n\t\t\t<td>\n\t\t\t\t<b>Functia 3:</b> <i class='text-nowrap'>void f(short x, int y, <pre class='inline'><code class='language-cpp'>float z</code></pre>, char w)</i> (pentru ca nu trebuie sa se faca conversie)\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<b>Functia 1:</b> <i class='text-nowrap'>void f(int x, int y, <pre class='inline'><code class='language-cpp'>double z</code></pre>, char w)</i> (pentru ca face conversie (promotie) la <pre class='inline'><code class='language-cpp'>double</code></pre>)\n\t\t\t\t<br>\n\t\t\t\t<b>Functia 2:</b> <i class='text-nowrap'>void f(int x, long y, <pre class='inline'><code class='language-cpp'>double z</code></pre>, int w)</i> (pentru ca face conversie (promotie) la <pre class='inline'><code class='language-cpp'>double</code></pre>)\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th class='text-center' scope=\"row\"><pre class='inline'><code class='language-cpp'>2 (int)</code></pre></th>\n\t\t\t<td>\n\t\t\t\t<b>Functia 2:</b> <i class='text-nowrap'>void f(int x, long y, double z, <pre class='inline'><code class='language-cpp'>int w</code></pre>)</i> (pentru ca nu trebuie sa se faca conversie)\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<b>Functia 1:</b> <i class='text-nowrap'>void f(int x, int y, double z, <pre class='inline'><code class='language-cpp'>char w</code></pre>)</i> (pentru ca face conversie la <pre class='inline'><code class='language-cpp'>char</code></pre>)\n\t\t\t\t<br>\n\t\t\t\t<b>Functia 3:</b> <i class='text-nowrap'>void f(short x, int y, float z, <pre class='inline'><code class='language-cpp'>char w</code></pre>)</i> (pentru ca face conversie la <pre class='inline'><code class='language-cpp'>char</code></pre>)\n\t\t\t</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n<div>\nDeci avem:\n<br>\n<pre class='inline'><code class='language-cpp'>x</code></pre> -> { functia_3 }\n<br>\n<pre class='inline'><code class='language-cpp'>50</code></pre> -> { functia_1, functia_3 }\n<br>\n<pre class='inline'><code class='language-cpp'>1.0f</code></pre> -> { functia_3 }\n<br>\n<pre class='inline'><code class='language-cpp'>2</code></pre> -> { functia_2 }\n<br>\nIntersectia dintre multimile astea este: &#xD8;. Rezulta ca nu se stie care functie sa se apeleaze (trebuie ca intersectia sa contina exact 1 functie ca sa nu fie ambiguu apelul de functie).\n</div>\n<div>\nCa programul sa fie corect trebuie modificata a treia functie (linia 14: <pre class='inline'><code class='language-cpp'>void f(short x, int y, float z, char w)</code></pre>) in <pre class='inline'><code class='language-cpp'>void f(short x, int y, float z, int w)</code></pre> si acum la linia 23: <pre class='inline'><code class='language-cpp'>f(x, 50, 1.0f, 2);</code></pre> se apeleaza a treia functie.\n</div></div>", "tags": ["easy", "incorrect", "function overloading"]}, {"id": 33, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n\tint* const p = new int(2);\n\tint&amp; x = *p;\n\n\tint y = *p;\n\n\tx = 20;\n\t*p = x;\n\tcout &lt;&lt; *p &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;\n\tdelete p;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>20 2</samp>\n<div>\n<pre class='inline'><code class='language-cpp'>int* const p = new int(2);</code></pre> se creeaza un pointer constant <var>p</var> catre un <pre class='inline'><code class='language-cpp'>int</code></pre> alocat dinamic cu valoarea <pre class='inline'><code class='language-cpp'>2</code></pre>. Pointerul este constant asta inseamna ca nu poti schimba spre ce zona de memorie arata dar poti modifica ce se afla la zona aceea de memorie la care arata. <pre class='inline'><code class='language-cpp'>int&amp; x = *p;</code></pre> se creeaza o referinta (un alias) la ce se afla in zona de memorie la care arata <var>p</var> (cu <pre class='inline'><code class='language-cpp'>*p</code></pre> accesezi ce se afla la zona de memorie la care arata <var>p</var>). Dupa se creeaza o variabila <var>y</var> de tip <pre class='inline'><code class='language-cpp'>int</code></pre> cu valorea <pre class='inline'><code class='language-cpp'>2</code></pre>, adica ce se afla la zona de memorie la care arata <var>p</var>. <pre class='inline'><code class='language-cpp'>x = 20;</code></pre> inseamna practic <pre class='inline'><code class='language-cpp'>*p = 20;</code></pre> pentru ca <var>x</var> este o referinta. <pre class='inline'><code class='language-cpp'>*p = x;</code></pre> inseamna practic <pre class='inline'><code class='language-cpp'>*p = p;</code></pre> deci nu face nimic. La final <pre class='inline'><code class='language-cpp'>*p</code></pre> este <pre class='inline'><code class='language-cpp'>20</code></pre> si <var>y</var> ramane neschimbat, adica 2. De asemenea se elibereaza zona de memorie alocata mai sus. (ce se aloca cu <pre class='inline'><code class='language-cpp'>new</code></pre> se sterge cu <pre class='inline'><code class='language-cpp'>delete</code></pre>, ce se aloca cu <pre class='inline'><code class='language-cpp'>new[]</code></pre> se sterge cu <pre class='inline'><code class='language-cpp'>delete[]</code></pre>).\n</div></div>", "tags": ["easy", "correct", "pointers", "references"]}, {"id": 34, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint f(int x)\n{\n    int y = x * x;\n    return y++;\n}\n\n\nint main()\n{\n    int a = f(2);\n    cout &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; f(++a) &lt;&lt; endl;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>4\n25</samp>\n<div>\nLa linia 13: <pre class='inline'><code class='language-cpp'>int a = f(2);</code></pre>, se apeleaza functia <var>f</var> cu valorea <pre class='inline'><code class='language-cpp'>2</code></pre>: <var>y</var> ia valorea 2*2 adica 4 si acum la <pre class='inline'><code class='language-cpp'>return y++;</code></pre>, pentru ca <pre class='inline'><code class='language-cpp'>++</code></pre> este <b>dupa</b> <var>y</var>, inseamna ca mai intai se returneaza valorea lui <var>y</var> (adica <pre class='inline'><code class='language-cpp'>4</code></pre>) si dupa se adauga <pre class='inline'><code class='language-cpp'>1</code></pre> la <var>y</var>, dar pentru ca functia s-a terminat si <var>y</var> e o simpla variabila locala, nu mai are nici un efect.(ar fi avut daca <var>y</var> era o variabila statica)\n</div>\n<div>\nDeci in <var>main</var> <var>a</var> ia valorea <pre class='inline'><code class='language-cpp'>4</code></pre>. La linia urmatoare <pre class='inline'><code class='language-cpp'>cout &lt;&lt; f(++a) &lt;&lt; endl;</code></pre>, <pre class='inline'><code class='language-cpp'>++</code></pre> este <b>inainte</b> de <var>a</var>, deci mai intai se mareste valoarea lui <var>a</var> si dupa se evalueaza expresia, in cazul asta se apeleaza functia <var>f</var> si dupa <pre class='inline'><code class='language-cpp'>cout</code></pre>.\n</div></div>", "tags": ["easy", "correct"]}, {"id": 35, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint f(int x)\n{\n    int y = x++;\n    return ++y + x;\n}\n\n\nint main()\n{\n    int a = f(2);\n    int x = a++ + 1;\n    cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; endl;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>7 7</samp>\n<div>\nLa linia 13: <pre class='inline'><code class='language-cpp'>int a = f(2);</code></pre> se apeleaza functia <var>f</var> cu valorea <pre class='inline'><code class='language-cpp'>2</code></pre>. In functie, <pre class='inline'><code class='language-cpp'>int y = x++;</code></pre> inseamna ca mai intai <var>y</var> ia valorea lui <var>x</var> si <b>dupa</b> <var>x</var> se mareste cu 1 (pentru ca <pre class='inline'><code class='language-cpp'>++</code></pre> este dupa <var>x</var>). La <pre class='inline'><code class='language-cpp'>return ++y + x;</code></pre>, <var>x</var> este <pre class='inline'><code class='language-cpp'>3</code></pre> (s-a marit mai sus), iar pentru ca <pre class='inline'><code class='language-cpp'>++</code></pre> este <b>inainte</b> de <var>y</var> mai intai se mareste <var>y</var> cu 1 (acum e 3), abia apoi se face suma si se returneaza (3 + 3 adica 6).\n</div>\n<div>\nDeci in <var>main</var>, <var>a</var> ia valorea 6. La linia 14: <pre class='inline'><code class='language-cpp'>int x = a++ + 1;</code></pre>, <pre class='inline'><code class='language-cpp'>a++</code></pre> mareste valorea lui <var>a</var> cu 1 dupa ce se evalueaza expresia (adica dupa ce <var>x</var> ia valorea nu stiu cat). Deocamdata <var>a</var> ramane 6, iar <var>x</var> este 6 + 1 adica 7. La final nu uita ca se mareste si <var>a</var> cu 1.\n</div>\n<div>\n<b>Totusi nu scrie niciodata ceva de genul </b> <pre class='inline'><code class='language-cpp'>int x = a++ + a;</code></pre> <b>, este <a href=\"https://stackoverflow.com/a/7812241\">unspecified behaviour</a>.</b>\n</div></div>", "tags": ["easy", "correct"]}, {"id": 36, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint x = 0;\n\nint a() {\n    x = 100;\n    return 1;\n}\n\nint b(){\n    x = 200;\n    return 2;\n}\n\nint c(){\n    x = 300;\n    return 3;\n}\n\nvoid print(int x, int y, int z){\n    cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; &#39; &#39; &lt;&lt; z &lt;&lt; endl;\n}\n\nint main()\n{\n    print(a(), b(), c());\n    cout &lt;&lt; x &lt;&lt; endl;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul compileaza dar output-ul nu este sigur. Daca rulezi programul asta probabil o sa se afiseze :\n</div>\n<samp class='output'>1 2 3\n100</samp>\n<div>\nDar ideea este ca la linia 15: <pre class='inline'><code class='language-cpp'>print(a(), b(), c());</code></pre> nu se garanteaza o ordine in care sa se evalueze functiile <var>a</var>, <var>b</var> si <var>c</var>. (de obicei e de la dreapta la stanga dar nu e o regula). Deci cum <var>x</var> este o variabila globala si este modificata in fiecare functie la final poate fi ori 100 ori 200 ori 300. (in cazul asta pentru ca functiile sunt prea simple probabil ca compilatorul face ceva optimizari fara sa stim si e posibil ca <var>x</var> sa fie mereu <pre class='inline'><code class='language-cpp'>100</code></pre>). Oricum nu te baza pe ordinea in care se evalueaza o partiile unei expresii pentru ca <a href=\"https://stackoverflow.com/questions/38501587/what-are-the-evaluation-order-guarantees-introduced-by-c17\">nu e specificat</a>.\n</div></div>", "tags": ["easy", "incorrect", "runtime"]}, {"id": 37, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\n    static int x;\n\npublic:\n    A (int i = 0) { x = i; }\n    \n    int getX() { return x; }\n    int&amp; setX(int i) { x = i; }\n    \n    A operator=(A other){\n        setX(other.getX());\n        return other;\n    }\n};\n\nint main()\n{\n    A a(100), b;\n    cout &lt;&lt; (b = a).getX();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare la compilare (mai exact linking error)\n</div>\n<samp class='error'>unresolved external symbol &quot;private: static int A::x&quot; (?x@A@@0HA)</samp>\n<div>\nVariabilele statice dintr-o clasa trebuie definite <b>in afara</b> ei. <var>x</var> este declarata in clasa dar nu este definita. De obicei cand declari ceva tot atunci si definesti in acelasi timp, dar variabilele statice intr-o clasa sunt o <a href=\"https://stackoverflow.com/a/1411005\">exceptie</a>. Daca nu declari o variabila ai probleme la compilare, daca nu definesti o variabila ai probleme la linkare.\n</div>\n<pre class='block'><code>class A{\n\tint x;\t\t   // declari si definesti x\n\tstatic int y;  // declari y\n};\n\nint A::y = 0;\t   // definesti y</code></pre>\n<div>\nCa sa fie corect, poti schimba linia 5: <pre class='inline'><code class='language-cpp'>static int x;</code></pre> in <pre class='inline'><code class='language-cpp'>int x;</code></pre> si acum <var>x</var> nu mai e <pre class='inline'><code class='language-cpp'>static</code></pre>.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>A a(100), b;</code></pre> se apeleaza constructorul pentru <var>a</var> cu valorea <pre class='inline'><code class='language-cpp'>100</code></pre>, si <var>x</var> ia valorea 100. Pentru <var>b</var> se apeleaza constructorul cu parametrul implicit si <var>x</var> ia valorea 0. La linia <pre class='inline'><code class='language-cpp'>cout &lt;&lt; (b = a).getX();</code></pre> se apeleaza mai intai operatorul <pre class='inline'><code class='language-cpp'>=</code></pre> (<var>b</var> apeleaza si <var>a</var> este argumentul).\n</div>\n<div>\n<var>a</var> se transmite prin valoare in functie (<pre class='inline'><code class='language-cpp'>A operator=(A other)</code></pre>) deci <var>other</var> e o copie al lui <var>a</var>. <pre class='inline'><code class='language-cpp'>setX(other.getX());</code></pre> seteaza <var>x</var>-ul din obiectul in care suntem (<var>b</var> din main) la valorea returnata de <pre class='inline'><code class='language-cpp'>other.getX()</code></pre> (<var>other</var> este o copie a lui <var>a</var> din main deci se returneaza 100). Acum <var>x</var>-ul din <var>b</var> este 100. Functia <pre class='inline'><code class='language-cpp'>operator=</code></pre> returneaza o copie (nu referinta la obiectul curent, cum se face de obicei) a lui <var>other</var> care e neschimbat (care e o copie al lui <var>a</var> din main). Revenind in main, <pre class='inline'><code class='language-cpp'>(b = a)</code></pre> este un obiect temporar (adica ce returneaza <pre class='inline'><code class='language-cpp'>operator=</code></pre>) cu <var>x</var>-ul egal cu 100. Deci <pre class='inline'><code class='language-cpp'>getX()</code></pre> intoarce <pre class='inline'><code class='language-cpp'>100</code></pre> si asta se afiseaza.\n</div>\n<div>\nLa linia 11: <pre class='inline'><code class='language-cpp'>int&amp; setX(int i) { x = i; }</code></pre> nu e tocmai gresit dar n-are sens sa ai o functie care intoarce ceva si sa nu intorci nimic (poate pe visual studio da eroare la linia asta)\n</div></div>", "tags": ["medium", "incorrect", "static"]}, {"id": 38, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\n    int i;\npublic:\n    A(int x = 2) : i(x + 1) {}\n    virtual int get_i() { return i; }\n};\nclass B : public A\n{\n    int j;\npublic:\n    B(int x = 20) : j(x - 2) {}\n    virtual int get_j() { return A::get_i() + j; }\n};\nint main()\n{\n    A o1(5);\n    B o2;\n    cout &lt;&lt; o1.get_i() &lt;&lt; &quot; &quot;;\n    cout &lt;&lt; o2.get_j() &lt;&lt; &quot; &quot;;\n    cout &lt;&lt; o2.get_i();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>6 21 3</samp>\n<div>\n<pre class='inline'><code class='language-cpp'>A o1(5);</code></pre> se creeaza un obiect <var>o1</var> de tip <pre class='inline'><code class='language-cpp'>A</code></pre>, se apeleaza constructorul din clasa <var>A</var> cu valorea <pre class='inline'><code class='language-cpp'>5</code></pre>, deci <var>i</var>-ul din obiectul <var>o1</var> ia valoarea 5+1 adica <pre class='inline'><code class='language-cpp'>6</code></pre>.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>B o2;</code></pre> se creeaza un obiect <var>o2</var> de tip <pre class='inline'><code class='language-cpp'>B</code></pre>. clasa <pre class='inline'><code class='language-cpp'>B</code></pre> este derivata din <pre class='inline'><code class='language-cpp'>A</code></pre> deci mai intai se executa constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> pentru <var>o2</var>. In lista de initializarea a constructorului din <pre class='inline'><code class='language-cpp'>B</code></pre> nu este apelat explicit constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> deci se apeleaza cu parametrul implicit 2. <var>i</var>-ul (din clasa <pre class='inline'><code class='language-cpp'>A</code></pre>) pentru obiectul <var>o2</var> este 2+1 adica <pre class='inline'><code class='language-cpp'>3</code></pre>. Se continua cu constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre>, care seteaza <var>j</var> la 20-2 adica <pre class='inline'><code class='language-cpp'>18</code></pre> (pentru ca in main nu este specificata o valoarea pentru constructor (<pre class='inline'><code class='language-cpp'>B o2;</code></pre>), parametrul <var>x</var> ramane 20).\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; o1.get_i() &lt;&lt; &quot; &quot;;</code></pre>, <pre class='inline'><code class='language-cpp'>o1.get_i()</code></pre> returneaza valorea lui <var>i</var> pentru obiectul <var>o1</var> adica 6 deci se afiseaza <pre class='inline'><code class='language-cpp'>6</code></pre>\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; o2.get_j() &lt;&lt; &quot; &quot;;</code></pre>, <pre class='inline'><code class='language-cpp'>o2.get_j()</code></pre> returneaza <pre class='inline'><code class='language-cpp'>A::get_i() + j</code></pre> (<var>j</var> este 18 de mai sus). Prin <pre class='inline'><code class='language-cpp'>A::get_i()</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> din clasa <pre class='inline'><code class='language-cpp'>A</code></pre> (nu conteaza ca functiile astea sunt <pre class='inline'><code class='language-cpp'>virtual</code></pre>, nici macar nu au acelasi nume si nici nu lucram cu pointeri). Pentru ca nu exista confuzii de nume, <pre class='inline'><code class='language-cpp'>A::get_i()</code></pre> este la fel cu <pre class='inline'><code class='language-cpp'>get_i()</code></pre>(daca in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> era o functie <pre class='inline'><code class='language-cpp'>get_i()</code></pre> atunci cu <pre class='inline'><code class='language-cpp'>A::</code></pre> te referi la cea din clasa <pre class='inline'><code class='language-cpp'>A</code></pre>). <pre class='inline'><code class='language-cpp'>get_i()</code></pre> returneaza valorea lui <var>i</var>, care pentru obiectul <var>o2</var> este 3 (de mai sus). Deci <pre class='inline'><code class='language-cpp'>o2.get_j()</code></pre> returneza 3 + 18 adica <pre class='inline'><code class='language-cpp'>21</code></pre> si se afiseaza <pre class='inline'><code class='language-cpp'>21</code></pre>.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; o2.get_i();</code></pre>, <pre class='inline'><code class='language-cpp'>o2.get_i()</code></pre> returneza valoarea lui <var>i</var> pentru obiectul <var>o2</var> adica <pre class='inline'><code class='language-cpp'>3</code></pre> si asta se si afiseaza.\n</div></div>", "tags": ["medium", "correct", "inheritance", "virtual", "public inheritance", "constructors"]}, {"id": 39, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Cerc {\n    double raza;\npublic:\n    Cerc(double r = 5.0) { raza = r; }\n    void afis() { cout &lt;&lt; &quot;Raza este &quot; &lt;&lt; raza &lt;&lt; endl; }\n    void schimba(double r) { raza = r; }\n};\n\nCerc construieste(double x) { return Cerc(x); }\n\nvoid verifica(Cerc&amp; c)\n{\n    c.afis();\n    c.schimba(2.0);\n    c.afis();\n}\n \nint main()\n{\n    verifica(construieste(1.5));\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul are eroare de compilare la linia 23: <pre class='inline'><code class='language-cpp'>verifica(construieste(1.5));</code></pre>.\n</div>\n<samp class='error'>initial value of reference to non-const must be an lvalue</samp>\n<div>\nFunctia <pre class='inline'><code class='language-cpp'>Cerc construieste(double x)</code></pre> returneaza un obiect de tip <pre class='inline'><code class='language-cpp'>Cerc</code></pre> temporar, nu este stocat in memorie deci nu ii poti lua adresa. La linia 23: <pre class='inline'><code class='language-cpp'>verifica(construieste(1.5));</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>void verifica(Cerc&amp; c)</code></pre> care primeste o referinta la un obiect de tip <pre class='inline'><code class='language-cpp'>Cerc</code></pre>, dar functia se apeleaza cu obiectul temporar intors de functia <var>construieste</var>. De aici si eroarea, nu poti avea o referinta la ceva temporar.\n</div>\n<div>\nCa programul sa fie corect, trebuie eliminata referinta, linia 15 devine: <pre class='inline'><code class='language-cpp'>void verifica(Cerc c)</code></pre>. Acum cand se apeleaza functia <var>verifica</var>, obiectul temporar este transmis prin valoare (se copiaza) deci nu mai sunt probleme, dar acum modificarile din functia <var>verifica</var> nu se vor mai reflecta in afara functiei pentru ca parametrul nu mai e referinta (aici nu e cazul).\n</div>\n<div>\nPoate esti tentat sa schimbi linia 15 in: <pre class='inline'><code class='language-cpp'>void verifica(const Cerc&amp; c)</code></pre> pentru ca asa functia poate primi ca parametrii si valori temporare (totusi nu poti avea referinte la obiecte temporare, poti avea din C++11 dar se noteaza cu && in loc de &). Nu este corect pentru ca in functia <var>verifica</var> se apeleaza niste metode care nu sunt <pre class='inline'><code class='language-cpp'>const</code></pre>, dar parametrul e de tip <pre class='inline'><code class='language-cpp'>const</code></pre> si ai eroare. \n</div>\n<div class=\"text-center\">\n<button class=\"btn btn-altdark mt-4\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#collapseCode\">Arata programul corect.</button>\n\t<div class=\"collapse\" id=\"collapseCode\">\n<pre class='block'><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Cerc {\n    double raza;\npublic:\n    Cerc(double r = 5.0) { raza = r; }\n    void afis() { cout &lt;&lt; &quot;Raza este &quot; &lt;&lt; raza &lt;&lt; endl; }\n    void schimba(double r) { raza = r; }\n};\n\nCerc construieste(double x) { return Cerc(x); }\n\nvoid verifica(Cerc c) // linia schimbata\n{\n    c.afis();\n    c.schimba(2.0);\n    c.afis();\n}\n \nint main()\n{\n    verifica(construieste(1.5));\n    return 0;\n}</code></pre>\n\t</div>\n</div></div>", "tags": ["medium", "incorrect", "references", "rvalue"]}, {"id": 40, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\n    int i;\npublic:\n    B() { i = 1; }\n    virtual int get_i() { return i; }\n};\n\nclass D : virtual public B {\n    int j;\npublic:\n    D() { j = 2; }\n    int get_i() { return B::get_i() + j; }\n};\n\nclass D2 : virtual public B {\n    int j2;\npublic:\n    D2() { j2 = 3; }\n    int get_i() { return B::get_i() + j2; }\n};\n\nclass MM : public D, public D2 {\n    int x;\npublic:\n    MM() { x = D::get_i() + D2::get_i(); }\n    int get_i() { return x; }\n};\n\nint main()\n{\n    B* o = new MM();\n    cout &lt;&lt; o-&gt;get_i() &lt;&lt; &quot; &quot;;\n    \n    MM* p = dynamic_cast&lt;MM*&gt;(o);\n    if (p)\n        cout &lt;&lt; p-&gt;get_i() &lt;&lt; &quot; &quot;;\n    \n    D* p2 = dynamic_cast&lt;D*&gt;(o);\n    if (p2)\n        cout &lt;&lt; p2-&gt;get_i();\n    \n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>7 7 7</samp>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>B* o = new MM();</code></pre> se aloca dinamic spatiu pentru un obiect de tip <pre class='inline'><code class='language-cpp'>MM</code></pre> iar pointerul de tip <pre class='inline'><code class='language-cpp'>B</code></pre> arata spre el. (upcasting pentru ca MM mosteneste B). Se executa constructorii in ordinea: B, D, D2, MM. Constructorii din B, D, D2 seteaza variabila membra la o anumita valoare iar in MM, <var>x</var> ia valoarea 3 + 4 adica <pre class='inline'><code class='language-cpp'>7</code></pre>.\n</div>\n<div>\nLa linia urmatoare: <pre class='inline'><code class='language-cpp'>cout &lt;&lt; o-&gt;get_i() &lt;&lt; &quot; &quot;</code></pre>, pentru ca <var>o</var> este un pointer de tip <pre class='inline'><code class='language-cpp'>B*</code></pre>, nu uitam in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> la functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> care este <pre class='inline'><code class='language-cpp'>virtual</code></pre>. Cum <var>o</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>MM</code></pre> si in clasa <pre class='inline'><code class='language-cpp'>MM</code></pre> functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> este supradefinita, ea se va apela si va returna valorea lui <var>x</var> adica 7 de mai sus. Deci se afiseaza <pre class='inline'><code class='language-cpp'>7</code></pre>.\n</div>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>MM* p = dynamic_cast&lt;MM*&gt;(o);</code></pre>, se face un dynamic cast la un pointer de tip <pre class='inline'><code class='language-cpp'>MM*</code></pre> si cum <var>o</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>MM</code></pre> va fi ok cast-ul. <var>p</var> este diferit de <pre class='inline'><code class='language-cpp'>nullptr</code></pre> deci se executa ce este in <pre class='inline'><code class='language-cpp'>if</code></pre> adica <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p-&gt;get_i() &lt;&lt; &quot; &quot;;</code></pre>. <var>p</var> este de tip <pre class='inline'><code class='language-cpp'>MM*</code></pre>, se apeleaza functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> din clasa <pre class='inline'><code class='language-cpp'>MM</code></pre> care intoarce 7, deci se afiseaza tot <pre class='inline'><code class='language-cpp'>7</code></pre>.\n</div>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>D* p2 = dynamic_cast&lt;D*&gt;(o);</code></pre>, se face un dynamic cast la un pointer de tip <pre class='inline'><code class='language-cpp'>D*</code></pre>. Clasa <pre class='inline'><code class='language-cpp'>MM</code></pre> mosteneste clasa <pre class='inline'><code class='language-cpp'>D</code></pre> deci merge cast-ul. La fel se executa ce este in <pre class='inline'><code class='language-cpp'>if</code></pre> adica <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p2-&gt;get_i();</code></pre>. <var>p2</var> este pointer de tip <pre class='inline'><code class='language-cpp'>D*</code></pre> si functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> din clasa <pre class='inline'><code class='language-cpp'>D</code></pre>, desi nu are cuvantul <pre class='inline'><code class='language-cpp'>virtual</code></pre> in fata, <b>este virtuala</b>. De ce? <a href=\"https://stackoverflow.com/a/58042469\">Pentru ca proprietatea unei functii din clasa de baza de a fi virtuala e valabila si pentru functia supradefinita din clasa derivata.</a> Pentru ca <var>p2</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>MM</code></pre> si functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> din <pre class='inline'><code class='language-cpp'>D</code></pre> este virtuala se apeleaza <pre class='inline'><code class='language-cpp'>get_i()</code></pre> din <pre class='inline'><code class='language-cpp'>MM</code></pre>, care intoarce 7 si se afiseaza <pre class='inline'><code class='language-cpp'>7</code></pre>.\n</div></div>", "tags": ["hard", "correct", "virtual", "inheritance", "polymorphism", "multiple inheritance", "pointers", "dynamic cast"]}, {"id": 41, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\n    int x;\n\npublic:\n    B(int i = 7) { x = i; }\n    int get_x() { return x; }\n    operator int() { return x; }\n};\nclass D : public B {\npublic:\n    D(int i = -12)\n        : B(i) {}\n\n    D operator+(D a) { return get_x() + a.get_x() + 1; }\n};\nint main()\n{\n    D a;\n    int b = 18;\n    b += a;\n    cout &lt;&lt; b;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>6</samp>\n<div>\nLa linia 21: <pre class='inline'><code class='language-cpp'>D a;</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre>, se executa constructorii in ordinea <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre>. Cand se apeleaza in main, constructorul <pre class='inline'><code class='language-cpp'>D(int i = -12) : B(i) {}</code></pre> nu primeste niciun argument deci <var>i</var> ramane -12. In lista de initializare se apeleaza constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> cu valorea <pre class='inline'><code class='language-cpp'>-12</code></pre>, el se executa primul si seteaza <var>x</var>-ul din <pre class='inline'><code class='language-cpp'>B</code></pre> la -12. Apoi se continua cu constructorul din <pre class='inline'><code class='language-cpp'>D</code></pre> care nu mai face nimic.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>b += a;</code></pre>, <var>b</var> este de tip <pre class='inline'><code class='language-cpp'>int</code></pre> deci trebuie o conversie de la <pre class='inline'><code class='language-cpp'>D</code></pre> la <pre class='inline'><code class='language-cpp'>int</code></pre>. Clasa <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>operator int()</code></pre> din clasa <pre class='inline'><code class='language-cpp'>B</code></pre> deci o sa fie folosit acum. In clasa <pre class='inline'><code class='language-cpp'>B</code></pre> <pre class='inline'><code class='language-cpp'>operator int()</code></pre> returneaza valorea lui <var>x</var> adica <pre class='inline'><code class='language-cpp'>-12</code></pre>. Deci <pre class='inline'><code class='language-cpp'>b += a;</code></pre> este <pre class='inline'><code class='language-cpp'>b += -12;</code></pre>, adica <var>b</var> devine 18 - 12 = <pre class='inline'><code class='language-cpp'>6</code></pre>.\n</div></div>", "tags": ["medium", "correct", "cast", "inheritance"]}, {"id": 42, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\nusing namespace std;\n\nclass A {\n    const int x;\npublic:\n\n    A(int y = 10) : x(y) {}\n    int getX() const { return x; }\n};\n\nclass B : A {\n    int y;\npublic:\n    B() { y = 20; }\n    int getY() const { return y; }\n};\n\nint main()\n{\n    A* p = new B;\n    cout &lt;&lt; p-&gt;getX();\n    if (typeid((A*)p).name() == &quot;B*&quot;)\n        cout &lt;&lt; ((B*)p)-&gt;getY();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, eroare de compilare la linia 22: <pre class='inline'><code class='language-cpp'>A* p = new B;</code></pre>\n</div>\n<samp class='error'>conversion to inaccessible base class &quot;A&quot; is not allowed</samp>\n<div>\nClasa <pre class='inline'><code class='language-cpp'>B</code></pre> mosteneste <b>privat</b> clasa <pre class='inline'><code class='language-cpp'>A</code></pre>, pentru ca modificatorul de access default la mostenire e <pre class='inline'><code class='language-cpp'>private</code></pre>. Cand mostenesti privat, din exterior nu stie nimeni ca ai derivat. La linia <pre class='inline'><code class='language-cpp'>A* p = new B;</code></pre> vrei sa faci upcasting, deci presupui ca <pre class='inline'><code class='language-cpp'>B</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>A</code></pre> dar nu stie nimeni asta aici in <var>main</var> (doar cand esti in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> stii asta) deci nu e valabil. E ca si cum ai vrea sa faci upcasting dar fara mostenire, nu merge.\n</div>\n<div>\nCa sa fie corect, trebuie sa mostenesti public, deci linia 13 sa devina <pre class='inline'><code class='language-cpp'>class B : public A {</code></pre>.\n</div>\n<div>\nDupa modificari, la <pre class='inline'><code class='language-cpp'>A* p = new B;</code></pre> se executa constructorii in ordinea <pre class='inline'><code class='language-cpp'>A</code></pre>, <pre class='inline'><code class='language-cpp'>B</code></pre>. In lista de initializare a constructorului din <pre class='inline'><code class='language-cpp'>B</code></pre> nu este apelat constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> cu o valoare, deci se apeleaza ca parametrul implicit 10. Se seteaza <var>x</var> la 10 (<var>x</var> e <pre class='inline'><code class='language-cpp'>const int</code></pre> deci trebuie initializat in lista de initializare a constructorului, nu merge facut asta in corpul constructorului), dupa se continua cu constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre>, care seteaza <var>y</var> la 20.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p-&gt;getX();</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>getX()</code></pre> din <pre class='inline'><code class='language-cpp'>A</code></pre> (care e <pre class='inline'><code class='language-cpp'>const</code></pre> deci nu poate modifica starea obiectului, gen variabile sau sa apeleze functii neconst, dar oricum nu face asta) si se afiseaza <pre class='inline'><code class='language-cpp'>10</code></pre>.\n</div>\n<div>\n<var>p</var> este de tip <pre class='inline'><code class='language-cpp'>A*</code></pre> deja deci nu are sens vreun cast la <pre class='inline'><code class='language-cpp'>A*</code></pre>, deci <pre class='inline'><code class='language-cpp'>typeid((A*)p).name()</code></pre> e la fel ca <pre class='inline'><code class='language-cpp'>typeid(p).name();</code></pre>. <pre class='inline'><code class='language-cpp'>typeid</code></pre> returneaza un obiect de tip <pre class='inline'><code class='language-cpp'>type_info</code></pre> ce reprezinta informatii despre tipul de date, are si o metoda <pre class='inline'><code class='language-cpp'>name()</code></pre> care returneaza numele tipului de date dar depinde de compilator numele exact. Tipul lui <var>p</var> este <pre class='inline'><code class='language-cpp'>A*</code></pre> (ne intereseaza pointerul, nu obiectul la care arata) deci in numele returnat de <pre class='inline'><code class='language-cpp'>typeid(p).name()</code></pre> nu are de ce sa apara <pre class='inline'><code class='language-cpp'>&quot;B*&quot;</code></pre>. In plus sirurile de caractere nu se compara cu <pre class='inline'><code class='language-cpp'>==</code></pre>, asa compari doar pointerii deci ar trebui sa fie exact acelasi sir de caractere (in memorie), nu 2 siruri de caractere cu acelasi continut ca sa se execute if-ul. <b>Daca vrei sa compari 2 siruri de caractere folosesti functia <pre class='inline'><code class='language-cpp'>strcmp</code></pre>, nu <pre class='inline'><code class='language-cpp'>==</code></pre>.</b> (pe visual studio, typeid(p).name() intoarce <pre class='inline'><code class='language-cpp'>&quot;class A * __ptr64&quot;</code></pre>)\n</div></div>", "tags": ["medium", "incorrect", "typeinfo", "RTTI", "inheritance", "access modifiers"]}, {"id": 43, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Locuinta {\nprotected:\n    int camere;\npublic:\n    Locuinta(int c = 10) { camere = c; }\n    virtual Locuinta upgrade(Locuinta other) { \n  \t\treturn other.camere + 2; \n    }\n    void print() const { \n    \tcout &lt;&lt; &quot;Locuinta are &quot; &lt;&lt; camere &lt;&lt; &quot; camere&quot;; \n    }\n};\n\nclass Casa : public Locuinta {\nprivate:\n    int etaje;\npublic:\n    Casa(int e = 0) : Locuinta(4) { etaje = e; }\n\n    Locuinta upgrade(Locuinta other) { \n    \treturn camere + other.camere * 2; \n\t}\n};\n\nint main()\n{\n    Locuinta* p1 = new Casa(5);\n    Locuinta* p2 = new Locuinta();\n    Locuinta* p3 = new Locuinta(p1-&gt;upgrade(*p2));\n    p3-&gt;print();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, eroare de compilare la linia 24 <pre class='inline'><code class='language-cpp'>return camere + other.camere * 2;</code></pre>\n</div>\n<samp class='error'>protected member &quot;Locuinta::camere&quot; (declared at line 6) is not accessible through a &quot;Locuinta&quot; pointer or object</samp>\n<div>\nMembrii <pre class='inline'><code class='language-cpp'>protected</code></pre> dintr-o clasa de baza poti fi accesati intr-o clasa derivata doar de obiecte (sau pointeri) de tipul clasei derivate. \n</div>\n<pre class='block'><code>class Base {\nprotected:\n    int x;\n};\n\nclass Derived : public Base {\n    void f(Base ob) { cout &lt;&lt; ob.x; }         // eroare, accesezi x-ul prin ceva de tip Base\n    void f(Base* ob) { cout &lt;&lt; ob-&gt;x; }       // eroare\n    void f(const Base&amp; ob) { cout &lt;&lt; ob.x; }  // eroare\n\n    void f(Derived ob) { cout &lt;&lt; ob.x; }          // ok, ob e Derived si ai acces la x\n    void f(Derived* ob) { cout &lt;&lt; ob-&gt;x; }        // ok\n    void f(const Derived&amp; ob) { cout &lt;&lt; ob.x; }   // ok\n\n    void g() { x = 100; }  // ok, ai acces la x-ul pentru obiectul curent\n};</code></pre>\n<div>\nProblema e la <pre class='inline'><code class='language-cpp'>other.camere</code></pre>, <var>other</var> e de tip <pre class='inline'><code class='language-cpp'>Locuinta</code></pre>, nu <pre class='inline'><code class='language-cpp'>Casa</code></pre>. Cum tu esti in clasa <pre class='inline'><code class='language-cpp'>Casa</code></pre> si <var>other</var> nu e de tip <pre class='inline'><code class='language-cpp'>Casa</code></pre>, nu ai acces la <var>other.camere</var> (care e <pre class='inline'><code class='language-cpp'>protected</code></pre> in clasa <pre class='inline'><code class='language-cpp'>Locuinta</code></pre>). Ai acess la <var>camere</var>, cand esti in clasa <pre class='inline'><code class='language-cpp'>Casa</code></pre>, doar prin ceva de tip <pre class='inline'><code class='language-cpp'>Casa</code></pre>, nu <pre class='inline'><code class='language-cpp'>Locuinta</code></pre>.\nCa programul sa fie corect, poti modifica functia <pre class='inline'><code class='language-cpp'>Locuinta upgrade(Locuinta other)</code></pre> din clasa <pre class='inline'><code class='language-cpp'>Casa</code></pre> in <pre class='inline'><code class='language-cpp'>Locuinta upgrade(Casa other)</code></pre>, acum primeste un obiect de tip <pre class='inline'><code class='language-cpp'>Casa</code></pre> si poti accesa variabila <var>camere</var>.\n</div>\n<div>\nDupa modificari, <pre class='inline'><code class='language-cpp'>Locuinta* p1 = new Casa(5);</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>Casa</code></pre>, se apeleaza constructorii in ordinea <pre class='inline'><code class='language-cpp'>Locuinta</code></pre>, <pre class='inline'><code class='language-cpp'>Casa</code></pre>. In lista de initializare din constructorul din <pre class='inline'><code class='language-cpp'>Casa</code></pre> este apelat constructorul din <pre class='inline'><code class='language-cpp'>Locuinta</code></pre> cu valoarea 4, si dupa se continua cu constructorul din <pre class='inline'><code class='language-cpp'>Casa</code></pre> (etaje = 5). Dupa ce se creeaza se face upcast (pointerul <var>p1</var> de tip <pre class='inline'><code class='language-cpp'>Locuinta</code></pre> arata spre ceva de tip <pre class='inline'><code class='language-cpp'>Casa</code></pre>). \n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>Locuinta* p2 = new Locuinta();</code></pre>, se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>Locuinta</code></pre>, nu este transmis vreun argument pentru constructor deci ramane cel default adica in obiectul la care arata <var>p2</var>, <var>camere</var> este 10.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>p1-&gt;upgrade(*p2)</code></pre> se apeleaza metoda <pre class='inline'><code class='language-cpp'>upgrade</code></pre> din clasa <pre class='inline'><code class='language-cpp'>Locuinta</code></pre>, pentru ca <var>p1</var> este de tip <pre class='inline'><code class='language-cpp'>Locuinta</code></pre> si functia <pre class='inline'><code class='language-cpp'>upgrade</code></pre> din <pre class='inline'><code class='language-cpp'>Casa</code></pre> difera prin tipul parametrului, se ignora faptul ca metoda e <pre class='inline'><code class='language-cpp'>virtual</code></pre>. Obiectul la care arata <var>p2</var> (are <var>camere</var> egal cu 10 de mai sus) este transmis ca parametru in functia <pre class='inline'><code class='language-cpp'>upgrade</code></pre>. Se returneaza 10 + 2 adica <pre class='inline'><code class='language-cpp'>12</code></pre>. Deci <pre class='inline'><code class='language-cpp'>p3 = new Locuinta(12);</code></pre>.\n</div></div>", "tags": ["incorrect", "medium", "virtual", "pointers", "inheritance", "protected"]}, {"id": 44, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\n    int x;\nprotected:\n    static int cnt;\npublic:\n    B(int i = 0) : x(i) { cnt++; }\n    \n    static int getCnt() { return cnt; }\n\n    ~B() { cnt--; }\n};\n\nint B::cnt;\n\nclass D : public B {\npublic:\n    D() { cnt++; }\n    ~D() { cnt--; }\n};\n\nvoid f(B* p) {\n    cout &lt;&lt; p-&gt;getCnt() + 1 &lt;&lt; &#39; &#39;;\n}\n\nint main()\n{\n    B* p = new B[10];\n    f(p);\n    delete[] p;\n    p = new D;\n    f(p);\n    delete p;\n    cout &lt;&lt; D::getCnt();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu are erori, se afiseaza:\n</div>\n<samp class='output'>11 3 1</samp>\n<div>\nLa <pre class='inline'><code class='language-cpp'>B* p = new B[10];</code></pre> se creeaza un array alocat dinamic cu 10 elemente de tip <pre class='inline'><code class='language-cpp'>B</code></pre>, pentru fiecare se apeleaza constructorul fara vreun parametru deci ramane cel default adica 0. <pre class='inline'><code class='language-cpp'>B(int i = 0) : x(i) { cnt++; }</code></pre> in lista de initializare a constructorului <var>x</var> ia valorea 0 si dupa in corpul constructorului variabila statica <var>cnt</var> se mareste cu 1. Pentru ca <var>cnt</var> a fost definita global (<pre class='inline'><code class='language-cpp'>int B::cnt;</code></pre>) a avut valoarea 0 la inceput. Acum <var>cnt</var> este <pre class='inline'><code class='language-cpp'>10</code></pre>, pentru ca s-a apelat constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> de 10 ori (pentru <pre class='inline'><code class='language-cpp'>new B[10]</code></pre>).\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>f(p);</code></pre> se apeleaza functia <var>f</var> cu pointerul <var>p</var> din main si se afiseaza valoarea variabilei statice <var>cnt</var> + 1 adica <pre class='inline'><code class='language-cpp'>11</code></pre> (un obiect de tip <pre class='inline'><code class='language-cpp'>B</code></pre> poate apela metoda statica <pre class='inline'><code class='language-cpp'>static int getCnt()</code></pre>).\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>delete[] p;</code></pre> se sterge array-ul alocat dinamic, deci pentru fiecare element se apeleaza destructorul <pre class='inline'><code class='language-cpp'>~B()</code></pre> care de fiecare data scade 1 din <var>cnt</var>. Acum <var>cnt</var> e 0.\n</div>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>p = new D;</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre>, se apeleaza constructorii in ordinea <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre>. In lista de initializare din constructorul din <pre class='inline'><code class='language-cpp'>D</code></pre> nu este specificat vreun parametru pentru constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre>, deci se apeleaza cu parametrul implicit 0 care mareste <var>cnt</var> cu 1 (tot aici se seteaza si <var>x</var> la 0). Dupa se continua cu constructorul din <pre class='inline'><code class='language-cpp'>D</code></pre>, care mareste si el <var>cnt</var> cu 1, acum e 2 (are acces la <var>cnt</var> pentru ca e <pre class='inline'><code class='language-cpp'>protected</code></pre> in clasa de baza). \n</div>\n<div>\nAcum cand se apeleaza <pre class='inline'><code class='language-cpp'>f(p);</code></pre> , se afiseaza 2+1 adica <pre class='inline'><code class='language-cpp'>3</code></pre> pentru ca <var>cnt</var> este 2 acum.\n</div>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>delete p;</code></pre> pentru ca <var>p</var> este de tip <pre class='inline'><code class='language-cpp'>B*</code></pre> ne uitam in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> la destructor <b>care nu e <pre class='inline'><code class='language-cpp'>virtual</code></pre></b> deci doar el se apeleaza (NU se mai apeleaza destructorul din <pre class='inline'><code class='language-cpp'>D</code></pre> chiar daca <var>p</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre>). <var>cnt</var> scade cu 1 si devine 1. In final la <pre class='inline'><code class='language-cpp'>cout &lt;&lt; D::getCnt();</code></pre> se afiseaza valorea lui <var>cnt</var> adica <pre class='inline'><code class='language-cpp'>1</code></pre>.\n</div></div>", "tags": ["medium", "correct", "dynamic memory allocation", "static", "destructors", "upcast", "inheritance"]}, {"id": 45, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Persoana {\n    char nume[20];\npublic:\n    Persoana(const char* n) { strcpy(nume, n); }\n    void afis() const { cout &lt;&lt; nume; }\n};\n\nvoid f(Persoana* p){ p.afis(); }\n\nint main()\n{\n    Persoana p = &quot;Ion&quot;;\n    f(&amp;p);\n\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, are o eroare de compilare la linia 12 <pre class='inline'><code class='language-cpp'>void f(Persoana* p){ p.afis(); }</code></pre>\n</div>\n<samp class='error'>request for member &#39;afis&#39; in &#39;p&#39;, which is of pointer type &#39;Persoana*&#39; (maybe you meant to use &#39;-&gt;&#39; ?)</samp>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>void f(Persoana* p){ p.afis(); }</code></pre>, <var>p</var> este un pointer, pointerul nu are metoda <pre class='inline'><code class='language-cpp'>afis()</code></pre>, obiectul la care arata o are. Deci pointerul trebuie dereferentiat mai intai cu <pre class='inline'><code class='language-cpp'>*p</code></pre> si dupa apelata functia <pre class='inline'><code class='language-cpp'>(*p).afis()</code></pre> dar pentru ca e incomod de scris mereu <pre class='inline'><code class='language-cpp'>(*p)</code></pre> poti folosi <pre class='inline'><code class='language-cpp'>-&gt;</code></pre> si nu mai dereferentiezi pointerul (<pre class='inline'><code class='language-cpp'>p-&gt;afis()</code></pre>).\n</div>\n<div>\nCa programul sa fie corect, trebuie schimbata linia 12 in <pre class='inline'><code class='language-cpp'>void f(Persoana* p){ p-&gt;afis(); }</code></pre>.\n</div>\n<div>\nAcum, pentru ca constructorul din clasa <pre class='inline'><code class='language-cpp'>Persoana</code></pre> are un singur parametru, poti scrie <pre class='inline'><code class='language-cpp'>Persoana p = &quot;Ion&quot;;</code></pre> care este totuna cu <pre class='inline'><code class='language-cpp'>Persoana p(&quot;Ion&quot;);</code></pre>. In C++ ceva de genul <pre class='inline'><code class='language-cpp'>&quot;Ion&quot;</code></pre> este un array de caractere const. (<pre class='inline'><code class='language-cpp'>const char[4]</code></pre> mai exact, 3 litere + caracterul de sfarsit). Daca ai o functie <pre class='inline'><code class='language-cpp'>void f(const char v[])</code></pre> este exact la fel cu <pre class='inline'><code class='language-cpp'>void f(const char* v)</code></pre> pentru ca un array transmis intr-o functie se transforma intr-un pointer la primul element din array.\n</div></div>", "tags": ["medium", "incorrect", "pointers", "constructors"]}, {"id": 46, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;class T, class U&gt;\nT f(T x, U y)\n{\n    return x + y;\n}\n\nint f(int x, int y)\n{\n    return x - y;\n}\n\nint main()\n{\n    int* a = new int(20), b(5);\n    cout &lt;&lt; *f(a, b) &lt;&lt; endl;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu are erori, (poate uneori la runtime ca accesezi memorie la intamplare) se afiseaza o valoare random din memorie.\n</div>\n<div>\nDaca scrii <pre class='inline'><code class='language-cpp'>int* a, b</code></pre> este de fapt <pre class='inline'><code class='language-cpp'>int* a; int b;</code></pre>. In plus, poti initializa un <pre class='inline'><code class='language-cpp'>int</code></pre> de exemplu folosind <pre class='inline'><code class='language-cpp'>()</code></pre>, adica <pre class='inline'><code class='language-cpp'>int x = 20;</code></pre> este la fel cu <pre class='inline'><code class='language-cpp'>int x(20);</code></pre>.\n</div>\n<pre class='block'><code>int* a;    // a este pointer la int\nint *a;    // a este pointer la int\nint * a;   // a este pointer la int\n\n/////////////////////////\n\nint* a, b; \t// | \nint *a, b;\t// |---- a este pointer la int, b este int \nint * a, b;\t// |\n\n// liniile de mai sus sunt echivalente cu\nint* a;\nint b;\n\n/////////////////////////\n\nint *a, *b; // a,b pointeri la int\nint* a,* b; // a,b pointeri la int</code></pre>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>int* a = new int(20), b(5);</code></pre> se aloca dinamic un <pre class='inline'><code class='language-cpp'>int</code></pre> cu valoarea 20 cu pointerul <var>a</var> care arata spre el, si un <pre class='inline'><code class='language-cpp'>int</code></pre> <var>b</var> care primeste valorea 5.\n</div>\n<div>\nCand se apeleaza functia <var>f</var> la linia <pre class='inline'><code class='language-cpp'>cout &lt;&lt; *f(a, b) &lt;&lt; endl;</code></pre>, <var>a</var> este de tip <pre class='inline'><code class='language-cpp'>int*</code></pre> si <var>b</var> este de tip <pre class='inline'><code class='language-cpp'>int</code></pre>. Sigur nu se potriveste cu functia <pre class='inline'><code class='language-cpp'>int f(int x, int y)</code></pre> dar se potriveste cu prima pentru ca e template. In cazul asta <pre class='inline'><code class='language-cpp'>T = int*</code></pre> si <pre class='inline'><code class='language-cpp'>U = int</code></pre>. Deci prima functie devine:\n</div>\n<pre class='block'><code>int* f(int* x, int y)\n{\n    return x + y;\n    // aici intervine aritmetica cu pointeri, x+y e un pointer\n    // care o sa arate cu y*4 bytes spre dreapta (sau spre stanga daca y &lt; 0)\n    // pentru ca 4 bytes e dimensiunea unui int si p este de tip int*\n    // deci x+y o sa arate spre o zona de memorie nefolosita (sau folosita, eroare la runtime)\n}</code></pre>\n<div>\nDeci functia asta intoarce un pointer care arata undeva in memorie (sa speram ca nu foloseste nimeni zona aia ca altfel eroare la runtime,Segmentation fault) dupa care este dereferentiat ( <pre class='inline'><code class='language-cpp'>*f(a, b)</code></pre> ) ca sa vedem valoare de acolo, care e un garbage value, si asta e afisat.\n</div>\n<div>\n<b>Sa accesezi o zona din memorie care nu iti apartine este undefined behaviour, personal nu cred ca te poti baza pe faptul ca o sa gasesti o valoare random acolo, nu consider ca programul e corect in practica.</b>\n</div></div>", "tags": ["medium", "correct", "pointers", "template", "function overloading"]}, {"id": 47, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\n    int x;\n\npublic:\n    A(int i = 0) { x = i; }\n    A operator+(const A&amp; a) { return x + a.x; }\n    template &lt;class T&gt;\n    ostream&amp; operator&lt;&lt;(ostream&amp;);\n};\ntemplate &lt;class T&gt;\nostream&amp; A::operator&lt;&lt;(ostream&amp; o)\n{\n    o &lt;&lt; x;\n    return o;\n}\nint main()\n{\n    A a1(33), a2(-21);\n    cout &lt;&lt; a1 + a2;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 22: <pre class='inline'><code class='language-cpp'>cout &lt;&lt; a1 + a2;</code></pre>\n</div>\n<samp class='error'>no operator &quot;&lt;&lt;&quot; matches these operands</samp>\n<div>\nProblema este ca operatorul <pre class='inline'><code class='language-cpp'>&lt;&lt;</code></pre> este supraincarcat ca membru al clasei <pre class='inline'><code class='language-cpp'>A</code></pre>. <pre class='inline'><code class='language-cpp'>cout &lt;&lt; a1 + a2;</code></pre> este ca si cum ai avea <pre class='inline'><code class='language-cpp'>cout.operator&lt;&lt;(a1 + a2);</code></pre>, nu are sens pentru ca <pre class='inline'><code class='language-cpp'>operator&lt;&lt;</code></pre> este in clasa <pre class='inline'><code class='language-cpp'>A</code></pre> (nu este functie prieten). Deci ar trebui sa fie invers, <pre class='inline'><code class='language-cpp'>(a1 + a2) &lt;&lt; cout;</code></pre> dar nu o sa mearga asa pentru ca metoda este template si nu stie cu ce sa inlocuiasca <pre class='inline'><code class='language-cpp'>T</code></pre>. Ar trebui ceva de genul <pre class='inline'><code class='language-cpp'>(a1 + a2) &lt;&lt; &lt;int&gt; cout</code></pre> doar ca nici asa nu merge, trebuie sa apelezi efectiv metoda cu <pre class='inline'><code class='language-cpp'>operator&lt;&lt;</code></pre> adica <pre class='inline'><code class='language-cpp'>(a1 + a2).operator&lt;&lt; &lt;int&gt;(cout)</code></pre>. Nu conteaza de tip pui intre <pre class='inline'><code class='language-cpp'>&lt;&gt;</code></pre>, poti pune orice tip pentru ca in metoda nici nu apare <pre class='inline'><code class='language-cpp'>T</code></pre>, eu am pus <pre class='inline'><code class='language-cpp'>int</code></pre>.\n</div>\n<div>\nCa programul sa fie corect ori stergi linia 22 ori o inlocuiesti cu <pre class='inline'><code class='language-cpp'>(a1 + a2).operator&lt;&lt; &lt;int&gt;(cout);</code></pre>. Alta varianta este sa schimbi linia 9 in: <pre class='inline'><code class='language-cpp'>int operator+(const A&amp; a) { return x + a.x; }</code></pre> si acum returneaza <pre class='inline'><code class='language-cpp'>int</code></pre> deci merge <pre class='inline'><code class='language-cpp'>cout &lt;&lt; a1 + a2;</code></pre>.\n</div></div>", "tags": ["incorrect", "medium", "operator overloading", "template"]}, {"id": 48, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\n    int n;\npublic:\n    B(int x) : n(x) {}\n\n    int getN() const { return n; }\n\n    int setN(int newN) {\n        int old = n;\n        n = newN;\n        return old;\n    }\n};\n\nint main()\n{\n    B* p = new B[8];\n\n    for (int i = 0; i &lt; 8; ++i)\n        p[i].setN(i*2);\n\n    for (int i = 0; i &lt; 8; ++i)\n        cout &lt;&lt; p[i].getN() &lt;&lt; &quot; &quot;;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 20: <pre class='inline'><code class='language-cpp'>B* p = new B[8];</code></pre>.\n</div>\n<samp class='error'>no default constructor exists for class &quot;B&quot;</samp>\n<div>\nCum spune si eroarea la linia 20 se aloca spatiu dinamic si se creeaza 8 obiecte de tip <pre class='inline'><code class='language-cpp'>B</code></pre>. Cand se creeaza cele 8 obiecte pentru fiecare se apeleaza constructorul fara vreun parametru dar in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> nu exista vreun constructor fara parametrii sau cu parametrii impliciti deci nu se pot crea obiectele.\n</div>\n<div>\nCa programul sa fie corect poti schimba linia 7 in <pre class='inline'><code class='language-cpp'>B(int x = 0) : n(x) {}</code></pre> sau in <pre class='inline'><code class='language-cpp'>B() : n(0) {}</code></pre>. In primul caz avem parametru cu o valoare implicita, in al doilea avem constructor fara parametrii (nu trebuie neaparat 0 poti pune alte valori).\n</div>\n<div>\nCu modificarile de mai sus, se creeaza 8 obiecte de tip <pre class='inline'><code class='language-cpp'>B</code></pre>. Dupa, in primul <pre class='inline'><code class='language-cpp'>for</code></pre>, se seteaza valoarea lui <var>n</var> din fiecare obiect la <pre class='inline'><code class='language-cpp'>i * 2</code></pre> prin metoda <pre class='inline'><code class='language-cpp'>setN</code></pre>. Chiar daca metoda intoarce ceva, rezultatul nu trebuie neaparat folosit. La al doilea <pre class='inline'><code class='language-cpp'>for</code></pre> se apeleaza metoda <pre class='inline'><code class='language-cpp'>getN</code></pre> (de obicei un getter e functie <pre class='inline'><code class='language-cpp'>const</code></pre> pentru ca nu ar trebui sa modifice obiectul, doar returneaza ceva) si se afiseaza:\n</div>\n<samp class='output'>0 2 4 6 8 10 12 14</samp></div>", "tags": ["medium", "incorrect", "dynamic memory allocation", "constructor"]}, {"id": 49, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint f(int x){\n\treturn ++x;\n}\n\nint f(int&amp; x, int y)\n{\n\ttry{\n\t\tif (x &lt; y)throw x--;\n\t\treturn x + y;\n\t}\n\tcatch (...){\n\t\tthrow;\n\t}\n\treturn y - x;\n}\n\nint f(double&amp; y){\n\tcout &lt;&lt; &quot;!&quot; &lt;&lt; y &lt;&lt; &quot;!&quot; &lt;&lt; endl;\n\treturn y / 2;\n}\n\nint main()\n{ \n    int x;\n\ttry{\n\t\tx = 123;\n\t\tif (x % 3 == 0) {\n\t\t    x = f(x, 125);\n\t\t\tcout &lt;&lt; &quot;Imi place &quot; &lt;&lt; x;\n\t\t}\n\t\telse {\n\t\t\tx = f(x);\n\t\t\tcout &lt;&lt; &quot;Nu prea imi place &quot; &lt;&lt; x;\n\t\t}\n\t}\n\tcatch (int i){\n\t\tcout &lt;&lt; &quot;Nu imi place numarul &quot; &lt;&lt; i &lt;&lt; endl;\n\t}\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza: \n</div>\n<samp class='output'>Nu imi place numarul 123</samp>\n<div>\nIn blocul <pre class='inline'><code class='language-cpp'>try</code></pre> din <var>main</var>, <var>x</var> ia valoarea 123. Cum 123 se imparte la 3, se executa codul in <pre class='inline'><code class='language-cpp'>if</code></pre>, <pre class='inline'><code class='language-cpp'>x = f(x, 125);</code></pre>. Se apeleaza functia <pre class='inline'><code class='language-cpp'>int f(int&amp; x, int y)</code></pre>. <var>x</var> este transmis prin referinta in functie si este 123, <var>y</var> este 125. Acum intram in blocul <pre class='inline'><code class='language-cpp'>try</code></pre> din functia <var>f</var>. <var>x</var> este mai mic ca <var>y</var> deci se executa <pre class='inline'><code class='language-cpp'>throw x--;</code></pre>, care arunca valoarea lui <var>x</var> si dupa scade 1 din <var>x</var>. Nu mai continuam si sarim in blocul de <pre class='inline'><code class='language-cpp'>catch</code></pre> (care prinde orice, in cazul asta prinde valoarea 123 aruncata de mai sus). Aici avem <pre class='inline'><code class='language-cpp'>throw;</code></pre> care arunca ce a primit mai departe (deci se arunca iar 123). Iesim din functia <var>f</var> ca nu mai avem ce sa prindem si revenim in <var>main</var>.\n</div>\n<div>\nIn <var>main</var> ramasesem la linia 31: <pre class='inline'><code class='language-cpp'>x = f(x, 125);</code></pre>. Functia a aruncat o exceptie deci nu mai continuam, trecem in blocul de <pre class='inline'><code class='language-cpp'>catch</code></pre>. Acolo prindem numarul 123, aruncat de functia <var>f</var>, pentru este de tip <pre class='inline'><code class='language-cpp'>int</code></pre> la fel ca <pre class='inline'><code class='language-cpp'>i</code></pre> (acum <var>i</var> e 123). La final se afiseaza mesajul si numarul 123.\n</div></div>", "tags": ["correct", "medium", "try catch", "function overloading"]}, {"id": 50, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Copac {\n    int varsta;\npublic:\n    Copac(int x) : varsta(x) {}\n    int f() const { return varsta + 1; }\n    int g(int x) { varsta = x; }\n\n    Copac operator= (Copac other) {\n        g(other.f());\n        return other;\n    }\n};\n\nclass Brad : public Copac {\n    int conuri;\npublic:\n    Brad(int c) : Copac(100) { conuri = c; }\n\n    void print() const { cout &lt;&lt; conuri &lt;&lt; endl; }\n};\n\nint main()\n{\n    Brad a(50), b, *c;\n    cout &lt;&lt; (b = a).f() &lt;&lt; endl;\n    (c = &amp;a)-&gt;print();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, eroare de compilare la linia 27: <pre class='inline'><code class='language-cpp'>Brad a(50), b, *c;</code></pre>.\n</div>\n<samp class='error'>no default constructor exists for class &quot;Brad&quot;</samp>\n<div>\nLa linia 27: <pre class='inline'><code class='language-cpp'>Brad a(50), b, *c;</code></pre> se creeaza o variabila de tip <pre class='inline'><code class='language-cpp'>Brad</code></pre> cu numele <var>b</var>, dar fara sa fie specificata vreo valoare pentru constructor. In clasa <pre class='inline'><code class='language-cpp'>Brad</code></pre> nu exista constructor fara parametrii sau cu parametrii impliciti si de aici vine eroarea.\n</div>\n<div>\nCa programul sa fie corect poti da o valoare cand construiesti obiectul <var>b</var>, <pre class='inline'><code class='language-cpp'>Brad a(50), b(10), *c;</code></pre> sau sa schimbi constructorul din <pre class='inline'><code class='language-cpp'>Brad</code></pre> in <pre class='inline'><code class='language-cpp'>Brad(int c = 0) : Copac(100) { conuri = c; }</code></pre>.\n</div>\n<div>\nDupa modificari (sa zicem a doua varianta, cu constructorul), la linia <pre class='inline'><code class='language-cpp'>Brad a(50), b, *c</code></pre> se creeaza 2 obiecte si un pointer. Pentru <var>a</var>, se apeleaza mai intai constructorul din clasa <pre class='inline'><code class='language-cpp'>Copac</code></pre> cu valorea 100 (deci <var>varsta</var> e 100) apoi <var>conuri</var> ia valoarea 50. Pentru <var>b</var>, la fel se apeleaza constructorul din <pre class='inline'><code class='language-cpp'>Copac</code></pre> cu 100 si dupa <var>conuri</var> ia valorea 0, pentru ca nu a fost transmis vreun argument pentru constructor.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>b = a</code></pre> pentru ca <pre class='inline'><code class='language-cpp'>b</code></pre> si <pre class='inline'><code class='language-cpp'>a</code></pre> sunt de tip <pre class='inline'><code class='language-cpp'>Brad</code></pre> (NU de tip <pre class='inline'><code class='language-cpp'>Copac</code></pre> !!) se apeleaza operatorul <pre class='inline'><code class='language-cpp'>operator=</code></pre> din clasa <pre class='inline'><code class='language-cpp'>Brad</code></pre>, care nu exista, este generat automat de compilator. Acum operatorul asta generat de compilator arata cam asa:\n</div>\n<pre class='block'><code>// definit in afara clasei\nBrad&amp; Brad::operator=(const Brad&amp; other) {\n    if (this != &amp;other) // se verifica daca ai ceva gen: b = b\n    {\n        Copac::operator=(other); // trebuie Copac:: ca sa ne referim la metoda din clasa Copac\n        conuri = other.conuri;\n    }\n    return *this;\n\n    // ideea e ca apeleaza operator= din clasa de baza,\n    // dupa copiaza membrii din clasa derivata si\n    // returneaza o referinta la obiectul care a apelat operator=\n}</code></pre>\n<div>\nAcum, la <pre class='inline'><code class='language-cpp'>Copac::operator=(other);</code></pre> se apeleaza <pre class='inline'><code class='language-cpp'>operator=</code></pre> din clasa <pre class='inline'><code class='language-cpp'>Copac</code></pre>, <var>other</var> fiind de fapt <var>a</var> din main iar obiectul care apeleaza este <var>b</var>. \n</div>\n<div>\nIn <pre class='inline'><code class='language-cpp'>operator=</code></pre> din clasa <pre class='inline'><code class='language-cpp'>Copac</code></pre>, <pre class='inline'><code class='language-cpp'>other.f()</code></pre> este practic <pre class='inline'><code class='language-cpp'>a.f()</code></pre> adica intoarce 100 + 1 adica 101. Acum, <pre class='inline'><code class='language-cpp'>g(other.f())</code></pre> inseamna <pre class='inline'><code class='language-cpp'>g(101);</code></pre>, nu uita ca suntem in obiectul <var>b</var> acum, deci se functia <var>g</var> schimba <var>varsta</var> din obiectul <var>b</var> in 101. Se returneaza o copie a parametrului <var>other</var>. Revenim la <pre class='inline'><code class='language-cpp'>operator=</code></pre> generat de compilator. O sa ignore valoarea asta returnata de celalalt <pre class='inline'><code class='language-cpp'>operator=</code></pre> si continua sa modifice si <var>conuri</var> din <var>b</var> la 50 (pentru ca <var>other</var> este <var>a</var> si <var>conuri</var> din <var>a</var> este 50). La final se intoarce o referina la obiectul <pre class='inline'><code class='language-cpp'>*this</code></pre> care este obiectul care a apelat <pre class='inline'><code class='language-cpp'>operator=</code></pre> adica <var>b</var>.\n</div>\n<div>\nConcluzia? <pre class='inline'><code class='language-cpp'>cout &lt;&lt; (b = a).f();</code></pre> este practic:\n</div>\n<pre class='block'><code>b = a;\ncout &lt;&lt; b.f();</code></pre>\n<div>\n<pre class='inline'><code class='language-cpp'>(b = a)</code></pre> returneaza o referinta la <var>b</var> modificat (cu <var>varsta</var> egal cu 101). Deci <pre class='inline'><code class='language-cpp'>(b = a).f()</code></pre> returneaza 101 + 1 adica <pre class='inline'><code class='language-cpp'>102</code></pre>.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>c = &amp;a</code></pre> aici <var>c</var> e pointer si doar arata spre <var>a</var> acum. La fel ca sus, <pre class='inline'><code class='language-cpp'>(c = &amp;a)</code></pre> returneaza o referinta la pointerul <var>c</var> modificat. La <pre class='inline'><code class='language-cpp'>(c = &amp;a)-&gt;print()</code></pre>, pointerul <var>p</var>, care arata spre <var>a</var> acum, apeleaza metoda <pre class='inline'><code class='language-cpp'>print</code></pre> care afiseaza <pre class='inline'><code class='language-cpp'>50</code></pre> (pentru ca <var>conuri</var> din <var>a</var> e 50). Deci, in final se afiseaza:\n</div>\n<samp class='output'>102\n50</samp></div>", "tags": ["incorrect", "medium", "pointers", "operator overloading", "constructor"]}, {"id": 51, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Base {\n    int x;\npublic:\n    Base(int y = 0) : x(y) {}\n    operator int() { return x; }\n\n    int operator=(Base other) { return 100; }\n};\n\nclass Derived : public Base {\n\tint y;\npublic:\n    Derived(int x = 0) : Base(x), y(10) {}\n};\n\nint main()\n{\n    Derived a(123), b;\n    Base c;\n\n    cout &lt;&lt; (c = a) &lt;&lt; &quot; &quot; &lt;&lt; (b = a) &lt;&lt; endl;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu contine erori, se afiseaza:\n</div>\n<samp class='output'>100 0</samp>\n<div>\nDaca nu definesti tu operatorul de atribuire <pre class='inline'><code class='language-cpp'>operator=</code></pre> pentru o clasa, o sa fie generat de compilator. In cazul clasei <pre class='inline'><code class='language-cpp'>Derived</code></pre> nu este definit, deci o sa fie generat automat:\n</div>\n<pre class='block'><code>class Derived : public Base {\n    int y;\npublic:\n    Derived(int x = 0) : Base(x), y(10) {}\n\n    Derived&amp; operator=(const Derived&amp;);\n};\n\nDerived&amp; Derived::operator=(const Derived&amp; other) {\n    if (this != &amp;other) {  // testam pentru chestii de genul a = a\n        \n        Base::operator=(other); // apelam operator= din clasa de baza\n                                // el stie sa copieze datele membre din clasa de baza\n\n        y = other.y;    // copiem ce e in clasa asta\n    }\n    return *this;   // returnam referinta la obiectul (modificat) care a apelat operator=\n}</code></pre>\n<div>\n<pre class='inline'><code class='language-cpp'>Derived a(123)</code></pre>, creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>Derived</code></pre>, se apeleaza constructorii in ordinea <pre class='inline'><code class='language-cpp'>Base</code></pre>, <pre class='inline'><code class='language-cpp'>Derived</code></pre>. In lista de initializare din constructorul din clasa <pre class='inline'><code class='language-cpp'>Derived</code></pre> este apelat constructorul din <pre class='inline'><code class='language-cpp'>Base</code></pre> cu argumentul pe care l-a primit din main (123). Deci se executa constructorul din <pre class='inline'><code class='language-cpp'>Base</code></pre> cu valoarea 123, care seteaza <var>x</var>-ul la 123. Se continua cu constructorul din <pre class='inline'><code class='language-cpp'>Derived</code></pre> care seteaza <var>y</var> la 10. Acelasi lucru se intampla si cu obiectul <var>b</var> doar ca nu este transmisa vreo valoarea constructorului din <pre class='inline'><code class='language-cpp'>Derived</code></pre> deci pentru obiectul <var>b</var>, <var>x</var>-ul este 0 si <var>y</var>-ul este 10. Obiectul <var>c</var> de tip <pre class='inline'><code class='language-cpp'>Base</code></pre> are <pre class='inline'><code class='language-cpp'>x</code></pre>-ul 0.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>c = a</code></pre>, <var>c</var> este de tip <pre class='inline'><code class='language-cpp'>Base</code></pre> si <var>a</var> este de tip <pre class='inline'><code class='language-cpp'>Derived</code></pre>. Este ca si cum ai scrie <pre class='inline'><code class='language-cpp'>c.operator=(a);</code></pre>, deci se apeleaza <pre class='inline'><code class='language-cpp'>operator=</code></pre> din clasa <pre class='inline'><code class='language-cpp'>Base</code></pre> care de fapt nu copiaza obiectul, ci returneaza <pre class='inline'><code class='language-cpp'>100</code></pre>.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>b = a;</code></pre>, <var>b</var> si <var>a</var> sunt de tip <pre class='inline'><code class='language-cpp'>Derived</code></pre>. Deci <pre class='inline'><code class='language-cpp'>b.operator=(a)</code></pre> inseamna ca mergem la <pre class='inline'><code class='language-cpp'>operator=</code></pre> din clasa <pre class='inline'><code class='language-cpp'>Derived</code></pre> (ala generat de compilator). Aici se apeleaza <pre class='inline'><code class='language-cpp'>operator=</code></pre> din clasa de baza (<pre class='inline'><code class='language-cpp'>Base::operator=(other);</code></pre>) care practic e o functie care intoarce 100, nu face nimic. Dupa se copiaza <var>y</var>-ul din obiectul <var>a</var> in obiectul <var>b</var> (care oricum avea aceeasi valoare, 10).\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>cout &lt;&lt; (c = a);</code></pre> afiseaza 100. <pre class='inline'><code class='language-cpp'>cout &lt;&lt; (b = a);</code></pre> este echivalent cu <pre class='inline'><code class='language-cpp'>b = a; cout &lt;&lt; b;</code></pre>, deci mai intai se modifica <var>b</var> si dupa se afiseaza. Ce se afiseaza? Clasa <pre class='inline'><code class='language-cpp'>Derived</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>operator int()</code></pre> din clasa <pre class='inline'><code class='language-cpp'>Base</code></pre>, deci o sa fie folosit ca obiectul <var>b</var> sa fie convertit implicit la un <pre class='inline'><code class='language-cpp'>int</code></pre> si dupa sa fie afisat. <pre class='inline'><code class='language-cpp'>operator int()</code></pre> returneaza valorea lui <var>x</var> din obiectul <var>b</var> adica <pre class='inline'><code class='language-cpp'>0</code></pre> de mai sus. In concluzie se afiseaza <pre class='inline'><code class='language-cpp'>100 0</code></pre>.\n</div></div>", "tags": ["medium", "correct", "constructor", "operator overloading", "cast", "inheritance"]}, {"id": 52, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct MyStruct {\n    int foo;\npublic:\n    int get() const { return foo; }\n    int set(int newFoo) {\n        int temp = foo;\n        foo = newFoo;\n        return temp;\n    }\n};\n\n\nint main()\n{\n    MyStruct* s = new MyStruct[200];\n    for (int i = 0; i &lt; 100; ++i) {\n        s[i].set(i * 2);\n    }\n\n    for (int i = 0; i &lt; 10; ++i) {\n        cout &lt;&lt; s[i].get() &lt;&lt; &#39; &#39;;\n    }\n\n    delete[] s;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>0 2 4 6 8 10 12 14 16 18</samp>\n<div>\nIntr-un <pre class='inline'><code class='language-cpp'>struct</code></pre> modificatorul de acces implicit este <pre class='inline'><code class='language-cpp'>public</code></pre>, deci tot din struct-ul <pre class='inline'><code class='language-cpp'>MyStruct</code></pre> este <pre class='inline'><code class='language-cpp'>public</code></pre>.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>MyStruct* s = new MyStruct[200];</code></pre> sunt create 200 de obiecte cu <pre class='inline'><code class='language-cpp'>new</code></pre>. Pentru ca nu am definit vreun constructor, <var>foo</var> din fiecare obiect va avea o valoare random care era in memorie. In primul <pre class='inline'><code class='language-cpp'>for</code></pre>, se seteaza <var>foo</var>-ul din primele 100 de obiecte la valoarea <pre class='inline'><code class='language-cpp'>i*2</code></pre>. Chiar daca metoda <pre class='inline'><code class='language-cpp'>set</code></pre> intoarce ceva, nu trebuie neaparat sa folosim valoarea returnata. La al doilea <pre class='inline'><code class='language-cpp'>for</code></pre>, se apeleaza metoda <pre class='inline'><code class='language-cpp'>get</code></pre> pentru primele 10 obiecte, care intoarce valorea lui <var>foo</var> pentru fiecare obiect.\n</div>\n<div>\nMetoda <pre class='inline'><code class='language-cpp'>get</code></pre> este <pre class='inline'><code class='language-cpp'>const</code></pre>, deci nu poate modifica starea obiectului (adica date membre) si nici nu se pot apela in interiorul ei alte functii care nu sunt <pre class='inline'><code class='language-cpp'>const</code></pre>.\n</div></div>", "tags": ["medium", "correct", "dynamic memory allocation", "struct"]}, {"id": 53, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Angajat {\nprotected:\n    int salariu;\npublic:\n    Angajat(int _salariu) : salariu(_salariu){}\n};\n\nclass Sef : Angajat {\npublic:\n    Sef() : Angajat(1000) {}\n    Sef(Sef&amp; o) { salariu = 2 * o.salariu; }\n    int get() const { return salariu; }\n};\n\nint main()\n{\n    Sef a, b(a);\n    cout &lt;&lt; b.get();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 14: <pre class='inline'><code class='language-cpp'>Sef(Sef&amp; o) { salariu = 2 * o.salariu; }</code></pre>\n</div>\n<samp class='error'>no default constructor exists for class &quot;Angajat&quot;</samp>\n<div>\nCum spune si eroarea nu exista un constructor default pentru clasa <pre class='inline'><code class='language-cpp'>Angajat</code></pre>. Primul constructor din clasa <pre class='inline'><code class='language-cpp'>Sef</code></pre> e ok, <pre class='inline'><code class='language-cpp'>Sef() : Angajat(1000) {}</code></pre>, cand creezi un obiect nu uita si de clasa de baza, trebuie cumva apelat constructorul din clasa de baza (in lista de initializare a constructorului din clasa derivata). Daca nu il apelezi tu, il va apela compilatorul, dar nu il va apela cu nicio valoare deci se asteapta sa gaseasca un constructor fara parametrii (sau cu toti parametrii default). \n</div>\n<div>\nLinia 14: <pre class='inline'><code class='language-cpp'>Sef(Sef&amp; o) { salariu = 2 * o.salariu; }</code></pre> este completata de compilator cu <pre class='inline'><code class='language-cpp'>Sef(Sef&amp; o) : Angajat() { salariu = 2 * o.salariu; }</code></pre>, dar constructorul <pre class='inline'><code class='language-cpp'>Angajat()</code></pre> nu exista (avem doar <pre class='inline'><code class='language-cpp'>Angajat(int)</code></pre>). Ca programul sa fie corect trebuie schimbata linia 8 in <pre class='inline'><code class='language-cpp'>Angajat(int _salariu = 0) : salariu(_salariu){}</code></pre>. Acum se poate apela constructorul din clasa <pre class='inline'><code class='language-cpp'>Angajat</code></pre> si fara argumente.\n</div>\n<div>\nClasa <pre class='inline'><code class='language-cpp'>Sef</code></pre> mosteneste privat clasa <pre class='inline'><code class='language-cpp'>Angajat</code></pre>, doar clasa <pre class='inline'><code class='language-cpp'>Angajat</code></pre> stie ca este clasa derivata, in rest e secret pentru toata lumea. Deci in main nu ar merge un upcast (gen <pre class='inline'><code class='language-cpp'>Angajat* p = new Sef();</code></pre>).\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>Sef a, b(a);</code></pre> creaza un obiect de tip <pre class='inline'><code class='language-cpp'>Sef</code></pre>, <var>a</var>, care va avea <var>salariu</var> egal cu 1000. Constructorul din clasa <pre class='inline'><code class='language-cpp'>Angajat</code></pre> este executat primul cu valoarea primita in lista de initializare a constructorului din <pre class='inline'><code class='language-cpp'>Sef</code></pre>. <var>b</var> este creat cu constructorul de copiere din clasa <pre class='inline'><code class='language-cpp'>Sef</code></pre>, care ii seteaza <var>salariu</var>-ul la dublul lui <var>a</var> adica 2000. La sfarsit functia <pre class='inline'><code class='language-cpp'>get</code></pre> returneaza <var>salariu</var> din <var>b</var> adica <pre class='inline'><code class='language-cpp'>2000</code></pre>.\n</div></div>", "tags": ["medium", "incorrect", "copy constructor", "inheritance", "private inheritance"]}, {"id": 54, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\nprotected:\n    static int x;\n\npublic:\n    B(int y = 0) { x = y; }\n    virtual B f() { return 1-x; }\n};\nclass D : public B {\npublic:\n    D(int y = 0) { x = y; }\n    void print() { cout &lt;&lt; x; }\n};\n\nint B::x = 5;\n\nint main()\n{\n    B* p1 = new D(10);\n    *p1 = p1-&gt;f();\n    ((D*)p1)-&gt;print();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nEu nu consider ca programul asta este corect, da probabil daca il rulezi nu o sa ai probleme si se afiseaza <pre class='inline'><code class='language-cpp'>-9</code></pre> dar ce se intampla aici este undefined behaviour.\n</div>\n<div>\nAvem clasa <pre class='inline'><code class='language-cpp'>D</code></pre> care este derivata din <pre class='inline'><code class='language-cpp'>B</code></pre>. <pre class='inline'><code class='language-cpp'>B* p1 = new B(10);</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre> si un pointer <var>p1</var> de tip <pre class='inline'><code class='language-cpp'>B</code></pre> care arata spre el (upcast). Se apeleaza mai intai constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> care seteaza variabila statica <var>x</var> la 0, dupa se continua cu constructorul din <pre class='inline'><code class='language-cpp'>D</code></pre> si variabila statica <var>x</var> devine 10.\n</div>\n<div>\nAcum la <pre class='inline'><code class='language-cpp'>*p1 = p1-&gt;f();</code></pre>, <pre class='inline'><code class='language-cpp'>p1-&gt;f();</code></pre> intoarce un obiect de tip <pre class='inline'><code class='language-cpp'>B</code></pre> (cu <var>x</var>-ul setat la 1-10 adica -9). Acum obiectul la care arata <var>p1</var> este de tip <pre class='inline'><code class='language-cpp'>B</code></pre>. <var>x</var> este variabila statica, nu uita.\n</div>\n<div>\nAcum la <pre class='inline'><code class='language-cpp'>((D*)p1)-&gt;print();</code></pre> se face un downcast <pre class='inline'><code class='language-cpp'>(D*)p1</code></pre> si se apeleaza metoda <pre class='inline'><code class='language-cpp'>f</code></pre> care cauzeaza undefined behaviour, pentru ca <var>p1</var> NU arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre> si functia <pre class='inline'><code class='language-cpp'>f</code></pre> este in <pre class='inline'><code class='language-cpp'>D</code></pre>. Ok, este adevarat ca in metoda <pre class='inline'><code class='language-cpp'>f</code></pre> nu apare pointerul <pre class='inline'><code class='language-cpp'>this</code></pre> deci nu este accesat obiectul, doar variabila statica <var>x</var> dar totusi asa spune standard-ul c++.\n</div>\n<div>\nEu as sterge linia <pre class='inline'><code class='language-cpp'>((D*)p1)-&gt;print();</code></pre>.\n</div></div>", "tags": ["medium", "incorrect", "inheritance", "cast", "pointers"]}, {"id": 55, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint functie(int x, int y) {\n    return x * y;\n}\n\ntemplate&lt;class T, class U&gt;\nT functie(T x, U y) {\n    return x + y;\n}\n\nint functie(int x, int* y) {\n    return *y + x;\n}\n\nint main()\n{\n    int* a = new int(10), b(4);\n\n    cout &lt;&lt; functie(a, b);\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza o adresa de memorie, un numar natural (in baza 16 probabil) care o sa difere de fiecare data cand rulezi programul:\n</div>\n<samp class='output'>000001F9297D2DD0</samp>\n<pre class='block'><code>int* a;    // a este pointer la int\nint *a;    // a este pointer la int\nint * a;   // a este pointer la int\n\n/////////////////////////\n\nint* a, b; \t// | \nint *a, b;\t// |---- a este pointer la int, b este int !!\nint * a, b;\t// |\n\n// liniile de mai sus sunt echivalente cu\nint* a;\nint b;\n\n/////////////////////////\n\nint *a, *b; // a,b pointeri la int\nint* a,* b; // a,b pointeri la int</code></pre>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>int* a = new int(10), b(4);</code></pre> avem un pointer la <pre class='inline'><code class='language-cpp'>int</code></pre>, <var>a</var>, si un <pre class='inline'><code class='language-cpp'>int</code></pre>, <var>b</var>.\n</div>\n<div>\n<var>a</var> arata spre un <pre class='inline'><code class='language-cpp'>int</code></pre> cu valorea 10, <var>b</var> are valoarea 4 ( poti initializa un <pre class='inline'><code class='language-cpp'>int</code></pre>, <pre class='inline'><code class='language-cpp'>float</code></pre>, <pre class='inline'><code class='language-cpp'>string</code></pre> etc. folosind <pre class='inline'><code class='language-cpp'>()</code></pre> ).\n</div>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>cout &lt;&lt; functie(a, b);</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>functie</code></pre> cu un <pre class='inline'><code class='language-cpp'>int*</code></pre> un <pre class='inline'><code class='language-cpp'>int</code></pre> ca argumente. Prima functie <pre class='inline'><code class='language-cpp'>int functie(int x, int y)</code></pre> nu se potriveste pentru ca primeste 2 <pre class='inline'><code class='language-cpp'>int</code></pre>. Nici ultima functie nu se potriveste pentru ca primeste un <pre class='inline'><code class='language-cpp'>int</code></pre> si un <pre class='inline'><code class='language-cpp'>int*</code></pre> (noi avem <pre class='inline'><code class='language-cpp'>int*</code></pre> si <pre class='inline'><code class='language-cpp'>int</code></pre>). Deci ramane functia template <pre class='inline'><code class='language-cpp'>T functie(T x, U y)</code></pre> unde <pre class='inline'><code class='language-cpp'>T</code></pre> devine <pre class='inline'><code class='language-cpp'>int*</code></pre> si <pre class='inline'><code class='language-cpp'>U</code></pre> devine <pre class='inline'><code class='language-cpp'>int</code></pre>. Deci avem functia:\n</div>\n<pre class='block'><code>int* functie(int* x, int y) {\n    return x + y;\n}</code></pre>\n<div>\nFunctia returneaza un pointer. Un pointer este pur si simplu un <pre class='inline'><code class='language-cpp'>unsigned long long</code></pre>, un numar natural care reprezinta un loc efectiv din memorie (in bytes). Ce valoare are pointerul? Cand se aduna un pointer cu un <pre class='inline'><code class='language-cpp'>int</code></pre>, de exemplu <var>y</var>, pointerul isi va mari valoarea (sau micsora, daca y < 0) cu y * [dimensiunea tipului pointerului]. In cazul asta dimensiunea unui <pre class='inline'><code class='language-cpp'>int</code></pre> este 4 bytes. Deci daca in main pointerul <var>a</var> avea valorea 1000, in baza 10, (arata spre ceva din memorie care se afla la adresa 1000) si <var>b</var> este 4, atunci cand se apeleaza functia <pre class='inline'><code class='language-cpp'>functie(a, b)</code></pre>, se returneaza un pointer cu valoarea 1000 + 4 * 4 adica 1016 (in baza 10).\n</div></div>", "tags": ["medium", "correct", "template", "function overloading", "pointers"]}, {"id": 56, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\nprotected:\n    int x;\n\npublic:\n    B(int y = 5) : x(y) {}\n    virtual B f(B ob) { return x + ob.x + 1; }\n    void afis() { cout &lt;&lt; x; }\n};\n\nclass D : public B {\npublic:\n    D(int i = -15) : B(i - 1) {\n        x++;\n    }\n    B f(B ob) { return x - 2; }\n};\nint main()\n{\n    B *p1 = new D, *p2 = new B, *p3 = new B(p1-&gt;f(*p2));\n    p3-&gt;afis();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza: \n</div>\n<samp class='output'>-17</samp>\n<div>\nLa <pre class='inline'><code class='language-cpp'>B* p1 = new D</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre>, se apeleaza constructorii in ordinea <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre>. In lista de initializare a constructorului din <pre class='inline'><code class='language-cpp'>D</code></pre> este apelat constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> cu valorea -16 (<var>i</var> este -15 pentru ca in main nu s-a transmis vreun argument constructorului). Constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> seteaza <var>x</var> la -16 si dupa se continua cu constructorul din <pre class='inline'><code class='language-cpp'>D</code></pre> care mareste pe <var>x</var> cu 1 deci <var>x</var> din obiectul la care arata <var>p1</var> este -15.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>B* p2 = new B</code></pre> se apeleaza constructorul din clasa <pre class='inline'><code class='language-cpp'>B</code></pre> cu parametrul implicit <pre class='inline'><code class='language-cpp'>5</code></pre>, deci <var>x</var>-ul din obiectul la care arata <var>p2</var> este 5.\n</div>\n<div>\nFunctia <pre class='inline'><code class='language-cpp'>B f(B ob)</code></pre> este <pre class='inline'><code class='language-cpp'>virtual</code></pre> si este <b>redefinita</b> in clasa derivata (daca nu era degeaba era virtual). Asta inseamna ca daca ai un pointer de tip <pre class='inline'><code class='language-cpp'>B*</code></pre> care arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre> (upcast) si apelezi functia <pre class='inline'><code class='language-cpp'>f</code></pre>, chiar daca pointerul este de tip <pre class='inline'><code class='language-cpp'>B*</code></pre> nu se va apela functia din <pre class='inline'><code class='language-cpp'>B</code></pre> ci functia din <pre class='inline'><code class='language-cpp'>D</code></pre>.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>p1-&gt;f(*p2)</code></pre> se va apela functia <pre class='inline'><code class='language-cpp'>f</code></pre> din clasa <pre class='inline'><code class='language-cpp'>D</code></pre> (pentru ca <var>p1</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre> si functia <pre class='inline'><code class='language-cpp'>f</code></pre> este virtuala). Functia <pre class='inline'><code class='language-cpp'>B f(B ob) { return x - 2; }</code></pre> primeste ca parametru obiectul la care arata <var>p2</var> (si nu face nimic cu el) si returneaza valoarea lui <var>x</var> din obiectul la care arata <var>p1</var>, adica -15, minus 2 adica -17. Acum functia functia trebuie sa intoarca un obiect temporar de tip <pre class='inline'><code class='language-cpp'>B</code></pre>, nu <pre class='inline'><code class='language-cpp'>int</code></pre>, deci se va apela constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> si se construieste un obiect de tip <pre class='inline'><code class='language-cpp'>B</code></pre> cu <var>x</var> egal cu -17.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>B* p3 = new B(p1-&gt;f(*p2))</code></pre> inseamna <pre class='inline'><code class='language-cpp'>B* p3 = new B(temp)</code></pre>, unde <var>temp</var> este obiectul temporar de tip <pre class='inline'><code class='language-cpp'>B</code></pre>, intors de metoda <pre class='inline'><code class='language-cpp'>f</code></pre>. Se apeleaza constructorul de copiere (care e generat automat pentru ca nu e definit) si acum pointerul <var>p3</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>B</code></pre> cu <var>x</var>-ul egal cu -17.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>p3-&gt;afis();</code></pre>, <var>p3</var> este de tip <pre class='inline'><code class='language-cpp'>B*</code></pre>, se apeleaza metoda <pre class='inline'><code class='language-cpp'>afis</code></pre> (care nu e virtuala, daca ar fi fost virtuala si redefinita in clasa <pre class='inline'><code class='language-cpp'>D</code></pre> tot cea din clasa <pre class='inline'><code class='language-cpp'>B</code></pre> e apelata ca obiectul la care arata <var>p3</var> este de tip <pre class='inline'><code class='language-cpp'>B</code></pre> nu <pre class='inline'><code class='language-cpp'>D</code></pre>). Functia <pre class='inline'><code class='language-cpp'>afis</code></pre> afiseaza pe ecran valoarea lui <var>x</var> adica -17.\n</div></div>", "tags": ["medium", "correct", "inheritance", "virtual", "pointers", "upcast"]}, {"id": 57, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\nprotected:\n    int x;\npublic:\n    A(int a = 10) { x = a; }\n};\n\nclass B : virtual public A {\npublic:\n    B(int a = 20) { x = a; }\n};\n\nclass C : virtual public A {\npublic:\n    C(int a = 30) { x = a; }\n};\n\nclass D : virtual public A {\npublic:\n    D(int a = 40) { x = a; }\n};\n\nclass E : public B, public D, public C {\nprivate:\n    int y;\npublic:\n    E(int i, int j)\n        : D(i), B(i) \n    {\n        y = i * j - 2;\n    }\n\n    int getY()const { return y; }\n    int getX() const { return x; }\n    E(const E&amp; other) { y = other.x + other.y - 10; }\n};\nint main()\n{\n    E a(3, 7), b = a;\n    cout &lt;&lt; b.getY() &lt;&lt; &#39; &#39; &lt;&lt; b.getX();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>39 30</samp>\n<div>\nClasele <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>C</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre> mostenesc virtual clasa <pre class='inline'><code class='language-cpp'>A</code></pre>. Asta inseamna ca in clasa <pre class='inline'><code class='language-cpp'>E</code></pre>, care mosteneste clasele <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>C</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre>, are o singura copie a clasei <pre class='inline'><code class='language-cpp'>A</code></pre>. Deci un obiect de tip <pre class='inline'><code class='language-cpp'>E</code></pre> are o singura variabila <var>x</var> si o variabila <var>y</var>.\n</div>\n<div>\nCand ai mostenire virtuala si creezi un obiect de tip <pre class='inline'><code class='language-cpp'>E</code></pre> in cazul asta, mai intai se initializeaza subobiectele din clasele de baza virtuale (in cazul asta <pre class='inline'><code class='language-cpp'>A</code></pre>) deci mai intai constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> se apeleaza. Asta inseamna ca constructorii din clasele <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>C</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre> nu apeleaza constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre>. Este treaba clasei cea mai derivata sa apeleze constructorii din clasa de baza virtuala (adica <pre class='inline'><code class='language-cpp'>A</code></pre>). Vezi <a href=\"https://en.cppreference.com/w/cpp/language/derived_class#Virtual_base_classes\">aici</a> mai multe.\n</div>\n<pre class='block'><code>struct B {\n    int n;\n    B(int x) : n(x) {}\n};\n\nstruct X : virtual B { \n\tX() : B(1) {} \n};\n\nstruct Y : virtual B { \n\tY() : B(2) {} \n};\nstruct AA : X, Y     { \n\tAA() : B(3), X(), Y() {}\n};\n// constructorul default din AA apeleaza constructorii din X si Y\n// dar acei constructori NU mai apeleaza constructorul din B\n// pentru ca B este clasa de baza virtuala\n// constructorul din AA trebuie sa apeleze cumva constructorul din B \n// (ori o faci tu, ori compilatorul automat)\n\nAA a; // a.n == 3\n\n// in cazul asta daca nu apelezi tu constructorul din B in constructorul din AA\n// o sa fie apelat constructorul default(fara parametrii) din B care nu exista, deci eroare.\n\n\n\n\nX x; // x.n == 1\n// in cazul asta constructorul din X apeleaza constructorul din B</code></pre>\n<div>\nLa <pre class='inline'><code class='language-cpp'>E a(3, 7)</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>E</code></pre>. Desi constructorul din <pre class='inline'><code class='language-cpp'>E</code></pre> arata asa: <pre class='inline'><code class='language-cpp'>E(int i, int j) : D(i), B(i)</code></pre> mai intai se apeleaza constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre>, dupa, in ordinea in care s-a mostenit adica <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre>, <pre class='inline'><code class='language-cpp'>C</code></pre> (pentru ca <pre class='inline'><code class='language-cpp'>class E : public B, public D, public C</code></pre>). Deci constructorul din E arata teoretic asa: <pre class='inline'><code class='language-cpp'>E(int i, int j) : A(), B(i), D(i), C()</code></pre>.\n</div>\n<div>\nNe ducem in constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> care seteaza <var>x</var> la 10. Continuam cu constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> (care nu-l mai apeleaza pe cel din <pre class='inline'><code class='language-cpp'>A</code></pre>) care este apelat cu valoarea 3 (pt ca <var>i</var> e 3) si seteaza <var>x</var> la 3. Continuam cu constructorul din D care face acelasi lucru ca cel din <pre class='inline'><code class='language-cpp'>B</code></pre>. Acum ajungem la constructorul din <pre class='inline'><code class='language-cpp'>C</code></pre> care nu primeste vreun argument deci ramane parametrul default 30 si seteaza <var>x</var> la 30. \n</div>\n<div>\nIn final se executa si constructorul din <pre class='inline'><code class='language-cpp'>E</code></pre> care seteaza <var>y</var> la 19 (<var>i</var> e 3, <var>j</var> e 7, deci 3*7-2 adica 19). Deci obiectul <var>a</var> din main are <var>x</var>-ul 30 si <var>y</var>-ul 19.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>b = a</code></pre> nu se apeleaza operatorul de atribuire ci constructorul de copiere\n</div>\n<pre class='block'><code>E a;\n\nE b = a; \n// echivalent cu\nE b(a);\n\n// dar nu cu urmatorea chestie\n\nE b;   // constructor default\nb = a; // si aici operator=</code></pre>\n<div>\nAvem definit constructorul de copiere din <pre class='inline'><code class='language-cpp'>E</code></pre> , <pre class='inline'><code class='language-cpp'>E(const E&amp; other) { y = other.x + other.y - 10; }</code></pre> nu uita ca si asta e un constructor deci trebuie apelati si constructorii din celelate clase (aici sunt apelati automat) deci practic avem:\n<pre class='inline'><code class='language-cpp'>E(const E&amp; other) : A(), B(), D(), C() { y = other.x + other.y - 10; }</code></pre>. Se executa constructorii in ordinea <pre class='inline'><code class='language-cpp'>A</code></pre>, <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre>, <pre class='inline'><code class='language-cpp'>C</code></pre>, la final cel din <pre class='inline'><code class='language-cpp'>C</code></pre> seteaza <var>x</var>-ul la 30. Se continua cu constructorul de copiere care seteaza <var>y</var> la 30+19-10 adica 39 (<var>other</var> este <var>a</var> din main care are <var>x</var>-ul 30 si <var>y</var>-ul 19). Deci obiectul <var>b</var> din main are <var>x</var>-ul 30 si <var>y</var>-ul 39.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>b.getY()</code></pre> si <pre class='inline'><code class='language-cpp'>b.getX()</code></pre> returneaza valorea lui <var>y</var> respectiv <var>x</var> din obiectul <var>b</var>, adica 39 si 30.\n</div></div>", "tags": ["hard", "correct", "multiple inheritance", "constructor", "virtual inheritance"]}, {"id": 58, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\nusing namespace std;\n\nclass A {\n    int x;\npublic:\n    A(int _x) : x(_x + 1) {}\n    int getX() const { return x; }\n};\n\nclass B : public A {\n    int y;\npublic:\n    B(int _y = 0) : A(10) {\n        y = _y + x;\n    }\n    int getY() const { return y; }\n};\n \nint main()\n{\n    const A* p = new B[10];\n    cout &lt;&lt; p-&gt;getX() &lt;&lt; endl;\n\n    if (typeid((A*)p).name() == &quot;B*&quot;) {\n        cout &lt;&lt; ((B*)p)-&gt;getY();\n    }\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 16: <pre class='inline'><code class='language-cpp'>y = _y + x;</code></pre>.\n</div>\n<samp class='error'>member &quot;A::x&quot; (declared at line 6) is inaccessible</samp>\n<div>\nIntr-o clasa modificatorul de acces default este <pre class='inline'><code class='language-cpp'>private</code></pre>. \nClasa <pre class='inline'><code class='language-cpp'>B</code></pre> mosteneste clasa <pre class='inline'><code class='language-cpp'>A</code></pre> iar <var>x</var> din clasa <pre class='inline'><code class='language-cpp'>A</code></pre> este <pre class='inline'><code class='language-cpp'>private</code></pre> deci este accesibil doar in clasa <pre class='inline'><code class='language-cpp'>A</code></pre>. La linia 16 incerci sa accesezi <var>x</var>, care este <pre class='inline'><code class='language-cpp'>private</code></pre> in clasa de baza, de aici eroarea.\n</div>\n<div>\nCa programul sa fie corect il poti inlocui pe <var>x</var> din linia 16 <pre class='inline'><code class='language-cpp'>y = _y + x;</code></pre> cu metoda <pre class='inline'><code class='language-cpp'>getX()</code></pre> care returneaza valorea lui <var>x</var>. Linia 16 devine: <pre class='inline'><code class='language-cpp'>y = _y + getX();</code></pre>.\n</div>\n<div>\nAlta varianta este sa il faci pe <var>x</var> <pre class='inline'><code class='language-cpp'>protected</code></pre> in clasa de baza (acum au acces si clasele derivate). Clasa <pre class='inline'><code class='language-cpp'>A</code></pre> ar arata asa:\n</div>\n<pre class='block'><code>class A {\nprotected: // &lt;---\n    int x;\npublic:\n    A(int _x) : x(_x + 1) {}\n    int getX() const { return x; }\n};</code></pre>\n<div>\nDupa modificari, la linia <pre class='inline'><code class='language-cpp'>const A* p = new B[10];</code></pre> se creeaza un array cu 10 elemente de tip <pre class='inline'><code class='language-cpp'>B</code></pre>. Pentru fiecare se apeleaza constructorii in ordinea <pre class='inline'><code class='language-cpp'>A</code></pre>, <pre class='inline'><code class='language-cpp'>B</code></pre>. In lista de initializare a constructorului din <pre class='inline'><code class='language-cpp'>B</code></pre> este apelat cel din <pre class='inline'><code class='language-cpp'>A</code></pre> cu valorea 10, deci <var>x</var>-ul pentru fiecare obiect este 10+1 adica <pre class='inline'><code class='language-cpp'>11</code></pre>. Continuam cu constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre>, care nu a primit vreun argument, deci ramane cel default (0) si <var>y</var> este setat la 0 + 11 adica <pre class='inline'><code class='language-cpp'>11</code></pre>. Pointerul <var>p</var> este un pointer la obiect constant (nu pointer constant), asta inseamna nu putem modifica obiectele folosind pointerul <var>p</var> (deci nu se pot apela metode care nu sunt <pre class='inline'><code class='language-cpp'>const</code></pre>).\n</div>\n<div>\nPointerul <var>p</var> arata spre adresa primului element din array, deci <pre class='inline'><code class='language-cpp'>p-&gt;getX()</code></pre> este practic <pre class='inline'><code class='language-cpp'>p[0].getX()</code></pre>, functia <pre class='inline'><code class='language-cpp'>getX()</code></pre> este <pre class='inline'><code class='language-cpp'>const</code></pre> deci se poate apela (pentru ca <var>p</var> e pointer la ceva <pre class='inline'><code class='language-cpp'>const</code></pre>). La <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p-&gt;getX() &lt;&lt; endl;</code></pre> se afiseaza <pre class='inline'><code class='language-cpp'>11</code></pre> (pentru ca <var>x</var>-ul din toate obiectele e 11).\n</div>\n<div>\nPointerul <var>p</var> este de tip <pre class='inline'><code class='language-cpp'>A*</code></pre> deja, deci nu are sens vreun cast la <pre class='inline'><code class='language-cpp'>A*</code></pre>. <pre class='inline'><code class='language-cpp'>typeid((A*)p).name()</code></pre> e la fel ca <pre class='inline'><code class='language-cpp'>typeid(p).name();</code></pre>. <pre class='inline'><code class='language-cpp'>typeid</code></pre> returneaza un obiect de tip <pre class='inline'><code class='language-cpp'>type_info</code></pre> ce reprezinta informatii despre tipul de date, are si o metoda <pre class='inline'><code class='language-cpp'>name()</code></pre> care returneaza numele tipului de date dar depinde de compilator numele exact. Tipul lui <var>p</var> este <pre class='inline'><code class='language-cpp'>A*</code></pre> (ne intereseaza pointerul, nu obiectul la care arata pentru ca nu dereferentiem pointerul) deci in numele returnat de <pre class='inline'><code class='language-cpp'>typeid(p).name()</code></pre> nu are de ce sa apara <pre class='inline'><code class='language-cpp'>&quot;B*&quot;</code></pre>. In plus sirurile de caractere nu se compara cu <pre class='inline'><code class='language-cpp'>==</code></pre>, asa compari doar pointerii deci ar trebui sa fie exact acelasi sir de caractere (in memorie), nu 2 siruri de caractere cu acelasi continut ca sa se execute if-ul. <b>Daca vrei sa compari 2 siruri de caractere folosesti functia <pre class='inline'><code class='language-cpp'>strcmp</code></pre>, nu <pre class='inline'><code class='language-cpp'>==</code></pre>.</b>. (pe visual studio, typeid(p).name() intoarce <pre class='inline'><code class='language-cpp'>&quot;class A * __ptr64&quot;</code></pre>)\n</div></div>", "tags": ["medium", "incorrect", "inheritance", "pointers", "const"]}, {"id": 59, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n \nclass B {\nprotected:\n    static int i;\n    int x;\npublic:\n    B(int _x = 5) : x(_x) { i++; }\n    ~B() { i--; }\n    int f() const { return x; }\n    static int count() { return i; }\n};\nint B::i;\nclass D : public B {\npublic:\n    D() { i++; }\n    ~D() { i--; }\n    int f1(B ob) const { return 2 * f(); }\n};\n\nvoid f(B* p1) { \n    cout &lt;&lt; p1-&gt;count() + 1 &lt;&lt; &quot;,&quot;;\n}\n\nint main()\n{\n    B* p = new B[20];\n    f(p);\n    delete[] p;\n    p = new D;\n    cout &lt;&lt; p-&gt;f1(p) &lt;&lt; &quot;,&quot;;\n    delete p;\n    cout &lt;&lt; D::count();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 32: <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p-&gt;f1(p) &lt;&lt; &quot;,&quot;;</code></pre>.\n</div>\n<samp class='error'>class &quot;B&quot; has no member &quot;f1&quot;</samp>\n<div>\nPointerul <var>p</var> este de tip <pre class='inline'><code class='language-cpp'>B*</code></pre>. In clasa <pre class='inline'><code class='language-cpp'>B</code></pre> nu exista metoda <pre class='inline'><code class='language-cpp'>f1</code></pre> deci nu poti apela functia <pre class='inline'><code class='language-cpp'>f1</code></pre> cu pointerul <var>p</var>.\n</div>\n<div>\nCa programul sa fie corect sunt mai multe variante:\n</div>\n<div>\n<b>1)</b> Poti modifica linia 32 in <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p-&gt;f() &lt;&lt; &quot;,&quot;;</code></pre>, acum se apeleaza metoda <pre class='inline'><code class='language-cpp'>f</code></pre>, care nu primeste niciun argument, din clasa <pre class='inline'><code class='language-cpp'>B</code></pre>. Chiar daca functia <pre class='inline'><code class='language-cpp'>f</code></pre> din <pre class='inline'><code class='language-cpp'>B</code></pre> este <pre class='inline'><code class='language-cpp'>const</code></pre> si pointerul <var>p</var> arata spre ceva neconst nu conteaza, faptul ca functia e <pre class='inline'><code class='language-cpp'>const</code></pre> ne asigura ca nu se modifica obiectul.\n</div>\n<div>\n<b>2)</b> Poti modifica linia 32 in <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p-&gt;count() &lt;&lt; &quot;,&quot;;</code></pre> sau <pre class='inline'><code class='language-cpp'>cout &lt;&lt; B::count() &lt;&lt; &quot;,&quot;;</code></pre> sau <pre class='inline'><code class='language-cpp'>cout &lt;&lt; D::count() &lt;&lt; &quot;,&quot;;</code></pre>. Metoda <pre class='inline'><code class='language-cpp'>count</code></pre> din clasa <pre class='inline'><code class='language-cpp'>B</code></pre> este <pre class='inline'><code class='language-cpp'>static</code></pre>, asta inseamna ca metoda nu corespunde unui obiect ci intregii clase. Totusi poti apela o metoda <pre class='inline'><code class='language-cpp'>static</code></pre> cu un obiect/pointer (<pre class='inline'><code class='language-cpp'>p-&gt;count()</code></pre>). Pentru ca corespunde intregii clase poti apela si asa <pre class='inline'><code class='language-cpp'>B::count()</code></pre> iar pentru ca clasa <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste clasa <pre class='inline'><code class='language-cpp'>B</code></pre> si motoda <pre class='inline'><code class='language-cpp'>count</code></pre> din <pre class='inline'><code class='language-cpp'>B</code></pre> este <pre class='inline'><code class='language-cpp'>protected</code></pre> o poti accesa si prin clasa derivata (<pre class='inline'><code class='language-cpp'>D::count()</code></pre>).\n</div>\n<div>\n<b>3)</b> Poti modifica linia 32 in <pre class='inline'><code class='language-cpp'>cout &lt;&lt; ((D*)p)-&gt;f1(*p) &lt;&lt; &quot;,&quot;;</code></pre> (asta e cea mai complicata varianta). Ok deci metoda <pre class='inline'><code class='language-cpp'>f1</code></pre> este in clasa <pre class='inline'><code class='language-cpp'>D</code></pre> si <var>p</var> este de tip <pre class='inline'><code class='language-cpp'>B*</code></pre>. De la linia de mai sus stim sigur ca <var>p</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre> (upcast). Asadar putem face un downcast, in loc de <pre class='inline'><code class='language-cpp'>p</code></pre> avem <pre class='inline'><code class='language-cpp'>(D*)p</code></pre>. Acum mai trebuie niste paranteze: <pre class='inline'><code class='language-cpp'>((D*)p)-&gt;f1(p)</code></pre>, dar daca ne uitam la metoda <pre class='inline'><code class='language-cpp'>f1</code></pre> din <pre class='inline'><code class='language-cpp'>D</code></pre>, primeste ca parametru un obiect de tip <pre class='inline'><code class='language-cpp'>B</code></pre>. Noi avem aici pointerul <var>p</var> ca argument, deci trebuie dereferentiat mai intai (cu <pre class='inline'><code class='language-cpp'>*</code></pre>) si ajungem la <pre class='inline'><code class='language-cpp'>cout &lt;&lt; ((D*)p)-&gt;f1(*p) &lt;&lt; &quot;,&quot;;</code></pre>. <var>p</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre> dar totusi se poate apela metoda care accepta ceva de tip <pre class='inline'><code class='language-cpp'>B</code></pre> pentru ca <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>B</code></pre> (asta se numeste <a href=\"https://www.geeksforgeeks.org/object-slicing-in-c/\">slicing</a>). <b class=\"text-warning\">Cand se apeleaza metoda <pre class='inline'><code class='language-cpp'>f1</code></pre>, se transmite obiectul la care arata <var>p</var> prin valoare, deci se copiaza, asadar se foloseste constructorul de copiere ca sa se creeze obiectul temporar <var>ob</var>, iar cand se iese din functie se apeleaza destructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> pentru <var>ob</var></b>.\n</div>\n<div>\nDupa modificari, la <pre class='inline'><code class='language-cpp'>B* p = new B[20];</code></pre> se creeaza 20 de obiecte de tip <pre class='inline'><code class='language-cpp'>B</code></pre> si un pointer care arata spre ele (spre primul element, de fapt) Pentru fiecare element din array se apeleaza constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> (fara argumente, deci ramane cel implict adica 5). Fiecare element are <var>x</var>-ul setat la <pre class='inline'><code class='language-cpp'>5</code></pre> si in fiecare constructor se mareste variabila statica <var>i</var> cu 1 deci la sfarsit e <pre class='inline'><code class='language-cpp'>20</code></pre>. (<var>i</var> e definita in afara clasei, asa trebuie pentru variabile statice, si pentru ca e definita global e initializata cu 0).\n</div>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>f(p);</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>void f(B* p1)</code></pre> avand ca argument pointerul <var>p</var>. In functie, la <pre class='inline'><code class='language-cpp'>p1-&gt;count()</code></pre>, se apeleaza metoda <pre class='inline'><code class='language-cpp'>count</code></pre> care intoarce valorea lui <var>i</var> (<pre class='inline'><code class='language-cpp'>20</code></pre>) si se afiseaza 20+1 adica <pre class='inline'><code class='language-cpp'>21,</code></pre>.\n</div>\n<div>\nDupa se sterge array-ul alocat dinamic, pentru fiecare element se apeleaza destructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> (ne uitam la tipul pointer-ului, daca destructorul era <pre class='inline'><code class='language-cpp'>virtual</code></pre> atunci ne uitam si la tipul obiectelor la care arata <var>p</var>). Fiecare destructor scade 1 din <var>i</var>, deci la final <var>i</var> e 0.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>p = new D;</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre>. Se apeleaza constructorii in ordinea <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre>. In lista de initializare a constructorului din <pre class='inline'><code class='language-cpp'>D</code></pre> nu se apeleaza cel din <pre class='inline'><code class='language-cpp'>B</code></pre> cu vreo valoare, deci ramane argumentul default (5), deci <pre class='inline'><code class='language-cpp'>x</code></pre>-ul este <pre class='inline'><code class='language-cpp'>5</code></pre>. Constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> mareste si pe <var>i</var> la <pre class='inline'><code class='language-cpp'>1</code></pre>. Continuam cu constructorul din <pre class='inline'><code class='language-cpp'>D</code></pre> care mareste si el pe <var>i</var> la <pre class='inline'><code class='language-cpp'>2</code></pre>.\n</div>\n<div>\nIn functie de modificari la linia 32:\n<br>\n<pre class='inline'><code class='language-cpp'>p-&gt;f()</code></pre> intoarce valoarea lui <var>x</var>, din obiectul la care arata <var>p</var>, adica <pre class='inline'><code class='language-cpp'>5</code></pre>.\n<br>\n<pre class='inline'><code class='language-cpp'>p-&gt;count()</code></pre> (sau <pre class='inline'><code class='language-cpp'>B::count()</code></pre> sau <pre class='inline'><code class='language-cpp'>C::count()</code></pre>) intoarce valoarea lui <var>i</var> adica <pre class='inline'><code class='language-cpp'>2</code></pre>.\n<br>\n<pre class='inline'><code class='language-cpp'>((D*)p)-&gt;f1(*p)</code></pre> intoarce valoarea lui <var>x</var>, din obiectul la care arata <var>p</var>, inmultit cu 2 adica 5*2 deci <pre class='inline'><code class='language-cpp'>10</code></pre>. <b>Atentie aici, ca sa se creeze obiectul temporar <var>ob</var> (parametrul metodei <pre class='inline'><code class='language-cpp'>f1</code></pre>) se apeleaza constructorul de copiere deci <var>i</var> nu se modifica, in schimb cand se iese din functie se apeleaza destructorul pentru <var>ob</var> si <var>i</var> scade cu 1</b>.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>delete p;</code></pre> pentru ca <var>p</var> este pointer de tip <pre class='inline'><code class='language-cpp'>B*</code></pre> si destructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> NU este <pre class='inline'><code class='language-cpp'>virtual</code></pre>, NU se apeleaza destructorul din <pre class='inline'><code class='language-cpp'>D</code></pre> (chiar daca <var>p</var> arata spre ceva de tip <pre class='inline'><code class='language-cpp'>D</code></pre>). Destructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> scade pe <var>i</var> cu 1 si <var>i</var> devine <pre class='inline'><code class='language-cpp'>1</code></pre> (<b>sau <pre class='inline'><code class='language-cpp'>0</code></pre>!! daca la linia 32 ai <pre class='inline'><code class='language-cpp'>((D*)p)-&gt;f1(*p)</code></pre>, pentru ca se mai apeleaza destructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> si in metoda <pre class='inline'><code class='language-cpp'>f1</code></pre> pentru parametrul <var>ob</var></b>).\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; D::count();</code></pre>, metoda <pre class='inline'><code class='language-cpp'>count</code></pre> returneaza valorea lui <var>i</var> adica <pre class='inline'><code class='language-cpp'>1</code></pre> (<b>sau <pre class='inline'><code class='language-cpp'>0</code></pre>!! daca la linia 32 ai <pre class='inline'><code class='language-cpp'>((D*)p)-&gt;f1(*p)</code></pre>, pentru ca se mai apeleaza destructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> si in metoda <pre class='inline'><code class='language-cpp'>f1</code></pre> pentru parametrul <var>ob</var></b>).\n</div></div>", "tags": ["medium", "incorrect", "inheritance", "destructor", "constructor", "static", "pointers", "dynamic memory allocation"]}, {"id": 60, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint f(int x) {\n\treturn ++x;\n}\n\nint f(int&amp; x, int y)\n{\n\tif (x % 2 == 0 &amp;&amp; y % 3 == 0)\n\t\tthrow x;\n\treturn y - x;\n}\n\nfloat f(int&amp; y) {\n\tcout &lt;&lt; &quot;!&quot; &lt;&lt; y &lt;&lt; &quot;!&quot; &lt;&lt; endl;\n\treturn (float)y / 2;\n}\n\nint main()\n{\n\tint x;\n\ttry {\n\t\tx = 7;\n\t\tif (x % 2 == 0) {\n\t\t\tx = f(x, 5);\n\t\t\tcout &lt;&lt; &quot;Imi place &quot; &lt;&lt; x;\n\t\t}\n\t\telse {\n\t\t\tx = f(x);\n\t\t\tcout &lt;&lt; &quot;Nu prea imi place &quot; &lt;&lt; x;\n\t\t}\n\t}\n\tcatch (int i) {\n\t\tcout &lt;&lt; &quot;Nu imi place numarul &quot; &lt;&lt; i &lt;&lt; endl;\n\t}\n\treturn 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 31: <pre class='inline'><code class='language-cpp'>x = f(x);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nFunctia <pre class='inline'><code class='language-cpp'>f</code></pre> este supraincarcata. Cand supraincarci o functie nu se tine cont de tipul returnat, doar de tipul, numarul si ordinea (daca ai parametrii de mai multe tipuri) parametriilor. In cazul asta avem <pre class='inline'><code class='language-cpp'>f(x)</code></pre>, <var>x</var> este o variabila in memorie, deci ii putem lua adresa cu <pre class='inline'><code class='language-cpp'>&amp;</code></pre>. Concluzia? Pentru <pre class='inline'><code class='language-cpp'>f(x)</code></pre> se potriveste si <pre class='inline'><code class='language-cpp'>int f(int x)</code></pre> si <pre class='inline'><code class='language-cpp'>float f(int&amp; x)</code></pre>.\n</div>\n<div>\nCa sa fie corect poti modifica a doua functie sa primeasca un <pre class='inline'><code class='language-cpp'>float</code></pre> in loc de <pre class='inline'><code class='language-cpp'>int&amp;</code></pre> ca parametru (<pre class='inline'><code class='language-cpp'>float f(float y)</code></pre>)\n</div>\n<div>\nDupa modificare, intram in block-ul de <pre class='inline'><code class='language-cpp'>try</code></pre>, <var>x</var> ia valorea <pre class='inline'><code class='language-cpp'>7</code></pre>, nu se executa <pre class='inline'><code class='language-cpp'>if</code></pre> pentru ca 7 e impar si ajungem in <pre class='inline'><code class='language-cpp'>else</code></pre>. Acolo <var>x</var> ia valorea returnata de <pre class='inline'><code class='language-cpp'>f(x)</code></pre>. Se apeleaza prima functie (doar ea se potriveste) care returneaza <pre class='inline'><code class='language-cpp'>8</code></pre> (in functie parametrul <var>x</var> e 7, iar <pre class='inline'><code class='language-cpp'>++x</code></pre> inseamna ca mai intai adaugi 1 la <var>x</var> si dupa continui, in cazul asta se intoarce noua valoare). Functia nu a aruncat nimic deci continuam cu ce este in <pre class='inline'><code class='language-cpp'>else</code></pre> si se afiseaza.\n</div>\n<samp class='output'>Nu prea imi place 8</samp>\n<div>\nPentru ca functia <pre class='inline'><code class='language-cpp'>f</code></pre> nu a aruncat nimic, nu se mai executa blocul <pre class='inline'><code class='language-cpp'>catch</code></pre> (din main).\n</div></div>", "tags": ["medium", "try catch", "incorrect", "function overloading"]}, {"id": 61, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\n    static int x;\n\npublic:\n    A(int i = 2) { x = i; }\n\n    int getX() { return x; }\n    int&amp; setX(int i) { x = i; }\n\n    A operator=(A other) {\n        setX(other.getX());\n        return other;\n    }\n};\nint A::x = 5;\n\nint main()\n{\n    A a(50), b;\n    cout &lt;&lt; (b = a).getX();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>2</samp>\n<div>\nS-ar putea ca unele compilatoare sa se planga ca functia <pre class='inline'><code class='language-cpp'>int&amp; setX(int i)</code></pre> nu returneaza nimic dar nu este neaparat o eroare.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>A a(50), b;</code></pre> se apeleaza constructorul pentru <var>a</var> cu valorea <pre class='inline'><code class='language-cpp'>50</code></pre>, si variabila statica <var>x</var> ia valorea 50. Pentru <var>b</var> se apeleaza constructorul cu parametrul implicit (2) si <var>x</var> ia valorea 2. La linia <pre class='inline'><code class='language-cpp'>cout &lt;&lt; (b = a).getX();</code></pre> se apeleaza mai intai operatorul <pre class='inline'><code class='language-cpp'>=</code></pre> (<var>b</var> apeleaza si <var>a</var> este argumentul).\n</div>\n<div>\n<var>a</var> se transmite prin valoare in functie (<pre class='inline'><code class='language-cpp'>A operator=(A other)</code></pre>) deci <var>other</var> e o copie al lui <var>a</var>. <pre class='inline'><code class='language-cpp'>setX(other.getX());</code></pre> seteaza <var>x</var>-ul la valorea returnata de <pre class='inline'><code class='language-cpp'>other.getX()</code></pre> (pentru ca <var>x</var> este <pre class='inline'><code class='language-cpp'>static</code></pre> se returneaza tot 2). Acum <var>x</var>-ul ramane tot 2. Functia <pre class='inline'><code class='language-cpp'>operator=</code></pre> returneaza un obiect temporar, o copie (nu referinta la obiectul curent, cum se face de obicei) a lui <var>other</var> care e neschimbat (care e o copie al lui <var>a</var> din main). Revenind in main, <pre class='inline'><code class='language-cpp'>(b = a)</code></pre> este un obiect temporar (adica ce returneaza <pre class='inline'><code class='language-cpp'>operator=</code></pre>) cu <var>x</var>-ul egal cu 2 (oricum <var>x</var> nu depinde de vreun obiect, pentru ca e <pre class='inline'><code class='language-cpp'>static</code></pre> corespunde intregii clase). Deci <pre class='inline'><code class='language-cpp'>getX()</code></pre> intoarce <pre class='inline'><code class='language-cpp'>2</code></pre> (valorea lui <var>x</var>) si asta se afiseaza.\n</div></div>", "tags": ["medium", "correct", "static", "operator overloading"]}, {"id": 62, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\nprotected:\n    int x;\n\npublic:\n    B(int i = 5) { x = i; }\n};\nclass D : B {\npublic:\n    D() : B(4) {}\n    D(D&amp; b) { x = b.x - 9; }\n    void afisare() { cout &lt;&lt; x; }\n};\nint main()\n{\n    D b1, b2(b1);\n    b2.afisare();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>-5</samp>\n<div>\nModificatorul de acces default este <pre class='inline'><code class='language-cpp'>private</code></pre> deci clasa <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste <b>privat</b> clasa <pre class='inline'><code class='language-cpp'>B</code></pre>. Cand mostenesti privat este secret faptul ca ai mostenit (ok nu e secret ca poti vedea codul), doar clasa derivata stie faptul ca ai derivat (deci nu poti face upcast).\n</div>\n<div>\nMembrii <pre class='inline'><code class='language-cpp'>protected</code></pre> dintr-o clasa de baza poti fi accesati intr-o clasa derivata doar de obiecte (sau pointeri) de tipul clasei derivate. \n</div>\n<pre class='block'><code>class Base {\nprotected:\n    int x;\n};\n\nclass Derived : public Base {\n    void f(Base ob) { cout &lt;&lt; ob.x; }         // eroare, accesezi x-ul prin ceva de tip Base\n    void f(Base* ob) { cout &lt;&lt; ob-&gt;x; }       // eroare\n    void f(const Base&amp; ob) { cout &lt;&lt; ob.x; }  // eroare\n\n    void f(Derived ob) { cout &lt;&lt; ob.x; }          // ok, ob e Derived si ai acces la x\n    void f(Derived* ob) { cout &lt;&lt; ob-&gt;x; }        // ok\n    void f(const Derived&amp; ob) { cout &lt;&lt; ob.x; }   // ok\n\n    void g() { x = 100; }  // ok, ai acces la x-ul pentru obiectul curent\n};</code></pre>\n<div>\nLa <pre class='inline'><code class='language-cpp'>D b1, b2(b1);</code></pre> se creeaza 2 obiecte de tip <pre class='inline'><code class='language-cpp'>D</code></pre>, pentru ambele constructorii se vor executa in ordinea <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre>. Pentru obiectul <var>b1</var>, in lista de initializare din constructorul din <pre class='inline'><code class='language-cpp'>D</code></pre> se apeleaza ma intai constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> cu valorea <pre class='inline'><code class='language-cpp'>4</code></pre>. <var>x</var>-ul din <var>b1</var> devine 4, dupa se continua cu constructorul din <pre class='inline'><code class='language-cpp'>D</code></pre> care nu mai face nimic.\n</div>\n<div>\nPentru obiectul <var>b2</var> se va apela constructorul de copiere, care primeste ca parametru obiectul <var>ob1</var>. Pentru ca si el este un constructor mai intai trebuie apelat si constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre>. In lista de initializare din constructorul de copiere din <pre class='inline'><code class='language-cpp'>D</code></pre> nu se apeleaza explicit constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> deci se va apela cu valorea implicita 5. Deocamdata <var>x</var>-ul din <var>ob2</var> e 5. Continuam cu constructorul de copiere din <pre class='inline'><code class='language-cpp'>D</code></pre>. Parametrul <var>b</var> este o referinta la <var>ob1</var> (un alt nume practic, acelasi obiect). Avem acces la <var>x</var> pentru obiectul curent (pentru ca <var>x</var> e <pre class='inline'><code class='language-cpp'>protected</code></pre>) si avem acess la <pre class='inline'><code class='language-cpp'>b.x</code></pre> pentru ca <var>b</var> este o referinta de tip <pre class='inline'><code class='language-cpp'>D&amp;</code></pre>. <pre class='inline'><code class='language-cpp'>x = b.x - 9</code></pre> seteaza <var>x</var> la 4-9 adica <pre class='inline'><code class='language-cpp'>-5</code></pre>. (<var>x</var> din <var>b1</var> e 4).\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>b2.afisare()</code></pre> afiseaza pe ecran valorea lui <var>x</var> din <var>b2</var> adica <pre class='inline'><code class='language-cpp'>-5</code></pre>.\n</div></div>", "tags": ["medium", "correct", "inheritance", "protected", "copy constructor", "private inheritance"]}, {"id": 63, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\nprotected:\n    int x;\npublic:\n    B(int i = 1) : x(i) {}\n    \n    void f(int x) { cout &lt;&lt; x &lt;&lt; &quot;!&quot;; }\n};\n\nvoid surpriza(B&amp; ob, int val) {\n    ob.f(val * val);\n}\n\nclass D : B {\npublic:\n    D() {\n        surpriza(*this, 5 + x);\n    }\n};\n\nint main()\n{\n    D ob;\n    surpriza(ob, 3);\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 27: <pre class='inline'><code class='language-cpp'>surpriza(ob, 3);</code></pre>\n</div>\n<samp class='error'>conversion to inaccessible base class &quot;B&quot; is not allowed</samp>\n<div>\nModificatorul de acces default este <pre class='inline'><code class='language-cpp'>private</code></pre> deci clasa <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste <b>privat</b> clasa <pre class='inline'><code class='language-cpp'>B</code></pre>. Cand mostenesti privat este secret faptul ca ai mostenit (ok nu e secret ca poti vedea codul), doar clasa derivata stie faptul ca ai derivat (deci nu poti face upcast).\n</div>\n<div>\nProblema este ca <var>ob</var> este de tip <pre class='inline'><code class='language-cpp'>D</code></pre> si apelezi functia <pre class='inline'><code class='language-cpp'>surpriza</code></pre> care primeste o referinta la un obiect de tip <pre class='inline'><code class='language-cpp'>B</code></pre>. In mod normal ai putea face asta (pentru ca e upcast) dar clasa <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste privat <pre class='inline'><code class='language-cpp'>B</code></pre> deci in <var>main</var> practic &quot;nu se stie&quot; ca <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>B</code></pre>.\n</div>\n<div>\nCa programul sa fie corect poti mosteni <pre class='inline'><code class='language-cpp'>public</code></pre>. Linia 17 trebuie schimbata in <pre class='inline'><code class='language-cpp'>class D : public B {</code></pre>.\n</div>\n<div>\nDupa modificari, la <pre class='inline'><code class='language-cpp'>D ob;</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre>. Se vor executa constructorii in ordinea <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre>. In lista de initializare din <pre class='inline'><code class='language-cpp'>D</code></pre> nu este apelat explicit constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> deci el se va apela cu argumentul default (1). Constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> seteaza <var>x</var>-ul la <pre class='inline'><code class='language-cpp'>1</code></pre>. Continuam cu constructorul din <pre class='inline'><code class='language-cpp'>D</code></pre>. El apeleaza functia <pre class='inline'><code class='language-cpp'>surpriza</code></pre> cu argumentele <pre class='inline'><code class='language-cpp'>*this</code></pre> si <pre class='inline'><code class='language-cpp'>5 + x</code></pre>.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>this</code></pre> este un pointer la obiectul care apeleaza metoda (in cazul asta pointer la obiectul curent <var>ob</var> din main). Functia <pre class='inline'><code class='language-cpp'>surpriza</code></pre> primeste o referinta ca parametru deci pointerul asta trebuie dereferentiat cu <pre class='inline'><code class='language-cpp'>*</code></pre>. Acum, pentru ca suntem intr-o metoda din clasa <pre class='inline'><code class='language-cpp'>D</code></pre> inseamna ca &quot;stim&quot; ca <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>B</code></pre>. Deci, cand se apeleaza functia <pre class='inline'><code class='language-cpp'>surpriza</code></pre>, merge transmis obiectul curent (<pre class='inline'><code class='language-cpp'>*this</code></pre>) de tip <pre class='inline'><code class='language-cpp'>D</code></pre> la o referinta la clasa de baza <pre class='inline'><code class='language-cpp'>B</code></pre> (adica upcast). Puteam face asta si daca mosteneam privat.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>5 + x</code></pre> inseamna 5+1 adica 6. <var>x</var> este 1 de mai sus.\n</div>\n<div>\nDeci se apeleaza <pre class='inline'><code class='language-cpp'>supriza</code></pre> cu obiectul curent si numarul 6. Functia <pre class='inline'><code class='language-cpp'>surpriza</code></pre> apeleaza metoda <pre class='inline'><code class='language-cpp'>f</code></pre> a parametrului transmis prin referinta (adica obiectul <var>ob</var> din main). Metoda <pre class='inline'><code class='language-cpp'>f</code></pre> primeste <pre class='inline'><code class='language-cpp'>6</code></pre> ca parametru si afiseaza <pre class='inline'><code class='language-cpp'>&quot;36!&quot;</code></pre>.\n</div>\n<div>\nAcum am terminat cu constructorul pentru <var>ob</var>. La <pre class='inline'><code class='language-cpp'>surpriza(ob, 3);</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>surpriza</code></pre>. Aici trebuie sa mostenim public, altfel nu merge pentru ca facem upcast. In functia <pre class='inline'><code class='language-cpp'>surpriza</code></pre> se apeleaza metoda <pre class='inline'><code class='language-cpp'>f</code></pre> a obiectului transmis prin referinta (adica <var>ob</var>). Metoda <pre class='inline'><code class='language-cpp'>f</code></pre> este apelata cu 3*3 adica 9, si ea afiseaza pe ecran <pre class='inline'><code class='language-cpp'>&quot;9!&quot;</code></pre>. La final se afiseaza:\n</div>\n<samp class='output'>36!9!</samp></div>", "tags": ["medium", "incorrect", "inheritance", "upcast", "private inheritance"]}, {"id": 64, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\npublic:\n    virtual void f(int x) {\n        cout &lt;&lt; &quot;Suntem in B: &quot; &lt;&lt; x &lt;&lt; endl;\n    }\n};\n\nclass D : public B{\npublic:\n    void f(double x) {\n        cout &lt;&lt; &quot;Suntem in D: &quot; &lt;&lt; x &lt;&lt; endl;\n    }\n};\n\nclass DD : public D {\npublic:\n    void f(int x) {\n        cout &lt;&lt; &quot;Suntem in DD: &quot; &lt;&lt; x &lt;&lt; endl;\n    }\n};\n\nint main()\n{\n    D b;\n    DD c;\n\n    B&amp; ref1 = c;\n    D&amp; ref2 = c;\n    B&amp; ref3 = b;\n\n    ref1.f(12);\n    ref2.f(5);\n    ref3.f(9);\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza: \n</div>\n<samp class='output'>Suntem in DD: 12\nSuntem in D: 5\nSuntem in B: 9</samp>\n<div>\nIn primul rand cand supradefinesti o functie care este <pre class='inline'><code class='language-cpp'>virtual</code></pre> trebuie sa: ai acelasi nume, ai acelasi numar parametri, tipurile parametriilor sa fie in aceeasi ordine, <b>acelasi tip returnat</b> (cu niste exceptii) si daca e cazul sa fie si <pre class='inline'><code class='language-cpp'>const</code></pre> sau <pre class='inline'><code class='language-cpp'>volatile</code></pre> (daca functia din clasa de baza e <pre class='inline'><code class='language-cpp'>const</code></pre> sau <pre class='inline'><code class='language-cpp'>volatile</code></pre>). Tipul returnat trebuie sa fie <b>identic</b> (daca metodele nu intorc pointeri sau referinte) sau &quot;covariant&quot;. Ce inseamna &quot;covariant&quot;? Are legatura cu pointeri si referinte, adica ce intoarce functia supradefinita sa poata fi folosit in aceleasi moduri ca ce intoarce metoda clasa de baza. (de exemplu daca metoda virtuala din clasa de baza <pre class='inline'><code class='language-cpp'>Base</code></pre> intoarce un pointer de tip <pre class='inline'><code class='language-cpp'>Base*</code></pre> atunci metoda supradefinita din clasa derivata <pre class='inline'><code class='language-cpp'>Derived</code></pre> poate returna un pointer de tip <pre class='inline'><code class='language-cpp'>Derived*</code></pre> in loc de un pointer de tip <pre class='inline'><code class='language-cpp'>Base*</code></pre>. Acelasi lucru se intampla si cu referinte) Vezi <a href=\"https://www.learncpp.com/cpp-tutorial/the-override-and-final-specifiers-and-covariant-return-types/\">aici</a> (da scroll mai jos la &quot;covariant return type&quot;). \n</div>\n<div>\nRevenind la problema, metoda <pre class='inline'><code class='language-cpp'>void f(double x)</code></pre> din clasa <pre class='inline'><code class='language-cpp'>D</code></pre> nu supradefineste metoda virtuala din clasa de baza. De fapt o ascunde (chiar asa se numeste in situatia asta). Clasa <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste metoda virtuala <pre class='inline'><code class='language-cpp'>f</code></pre> din clasa de baza. Clasa <pre class='inline'><code class='language-cpp'>DD</code></pre> mosteneste clasa <pre class='inline'><code class='language-cpp'>B</code></pre> (pentru ca <pre class='inline'><code class='language-cpp'>DD</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>D</code></pre> si <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>B</code></pre>) dar in clasa <pre class='inline'><code class='language-cpp'>DD</code></pre> metoda <pre class='inline'><code class='language-cpp'>f</code></pre> (din clasa <pre class='inline'><code class='language-cpp'>B</code></pre>, mostenita de <pre class='inline'><code class='language-cpp'>D</code></pre>) este supradefinita. Asta inseamna ca la linia <pre class='inline'><code class='language-cpp'>ref1.f(12);</code></pre> mergem in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> (pentru ca <var>ref1</var> este de tip <pre class='inline'><code class='language-cpp'>B&amp;</code></pre>) vedem ca metoda <pre class='inline'><code class='language-cpp'>f</code></pre> este <pre class='inline'><code class='language-cpp'>virtual</code></pre> asa ca ne uitam mai exact la ce obiect se refera <var>ref1</var>. Se refera la <var>c</var> care este de tip <pre class='inline'><code class='language-cpp'>DD</code></pre>, in clasa <pre class='inline'><code class='language-cpp'>DD</code></pre> este supradefinita metoda deci inseamna ca cea de acolo se va apela. Deci la <pre class='inline'><code class='language-cpp'>ref1.f(12);</code></pre> se apeleaza metoda din clasa <pre class='inline'><code class='language-cpp'>DD</code></pre>.\n</div>\n<div>\n<var>ref2</var> este o referinta de tip <pre class='inline'><code class='language-cpp'>D&amp;</code></pre>. La <pre class='inline'><code class='language-cpp'>ref2.f(5);</code></pre> mergem in clasa <pre class='inline'><code class='language-cpp'>D</code></pre> si acolo avem functia asta <pre class='inline'><code class='language-cpp'>void f(double x)</code></pre> care nu e virtuala. Se face o conversie la <pre class='inline'><code class='language-cpp'>double</code></pre> si ramanem cu metoda asta pentru ca o ascunde pe cea virtuala. Deci la <pre class='inline'><code class='language-cpp'>ref2.f(5);</code></pre> se apeleaza metoda din clasa <pre class='inline'><code class='language-cpp'>D</code></pre>.\n</div>\n<div>\n<var>ref3</var> este o referinta de tip <pre class='inline'><code class='language-cpp'>B&amp;</code></pre>. La <pre class='inline'><code class='language-cpp'>ref3.f(9);</code></pre> ne uitam in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> la metoda <pre class='inline'><code class='language-cpp'>f</code></pre> care este <pre class='inline'><code class='language-cpp'>virtual</code></pre>, deci ne uitam la obiectul la care <var>ref3</var>\tse refera. <var>ref3</var> se refera la un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre>. In clasa <pre class='inline'><code class='language-cpp'>D</code></pre> nu este redefinita metoda <pre class='inline'><code class='language-cpp'>void f(int x)</code></pre>, acolo este metoda <pre class='inline'><code class='language-cpp'>void f(double x)</code></pre> care seamana dar nu e la fel. Deci ramanem cu metoda din <pre class='inline'><code class='language-cpp'>B</code></pre>. Asadar la <pre class='inline'><code class='language-cpp'>ref3.f(9);</code></pre> se apeleaza prima metoda.\n</div></div>", "tags": ["medium", "inheritance", "correct", "references", "upcast", "virtual", "function overloading"]}, {"id": 65, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\n    int i;\n\npublic:\n    B() { i = 1; }\n    virtual int get_i() { return i; }\n};\nclass D : public B {\n    int j;\n\npublic:\n    D() { j = 2; }\n    int get_i() { return B::get_i() + j; }\n};\nint main()\n{\n    const int i = cin.get();\n    if (i % 3) {\n        D o;\n    }\n    else {\n        B o;\n    }\n    cout &lt;&lt; o.get_i();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 27: <pre class='inline'><code class='language-cpp'>cout &lt;&lt; o.get_i();</code></pre>\n</div>\n<samp class='error'>identifier &quot;o&quot; is undefined</samp>\n<div>\nEroarea spune ca practic nu exista obiectul <var>o</var> in main. Este adevarat ca in block-urile de <pre class='inline'><code class='language-cpp'>if</code></pre> si <pre class='inline'><code class='language-cpp'>else</code></pre> se creeaza niste obiecte cu numele <var>o</var> dar sunt accesibile doar in interiorul block-ului, nu in exterior (se creeaza local iar cand se iese din block se apeleaza destructorii)\n</div>\n<div>\nCa programul sa fie corect trebuie stearsa linia 27: <pre class='inline'><code class='language-cpp'>cout &lt;&lt; o.get_i()</code></pre>.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>cin.get()</code></pre> citeste un singur caracter si il intoarce (codul ASCII). Pentru ca <var>i</var> este <pre class='inline'><code class='language-cpp'>int</code></pre> va retine codul ASCII al caracterului.\n</div>\n<div>\nMetoda <pre class='inline'><code class='language-cpp'>get_i</code></pre> din clasa <pre class='inline'><code class='language-cpp'>B</code></pre> este <pre class='inline'><code class='language-cpp'>virtual</code></pre>, asta inseamna ca poate fi supradefinita in clasa derivata si putem folosi varianta din clasa derivata cu un pointer/referinta la clasa de baza (upcast). Daca in clasa <pre class='inline'><code class='language-cpp'>D</code></pre> in metoda <pre class='inline'><code class='language-cpp'>get_i</code></pre> supradefinita (sau in afara clasei) vrei sa folosesti metoda din clasa de baza, trebuie sa o apelezi explicit folosind numele clasei si operatorul de scop <pre class='inline'><code class='language-cpp'>::</code></pre> ( adica <pre class='inline'><code class='language-cpp'>B::get_i()</code></pre> )\n</div>\n<pre class='block'><code>B* p = new D; \t// obiect de tip D, cu i == 1 si j == 2\np-&gt;get_i(); \t// metoda din D, intoarce 1 + 2 == 3\np-&gt;B::get_i();  // metoda din B, intoarce 1</code></pre></div>", "tags": ["medium", "incorrect", "inheritance", "virtual"]}, {"id": 66, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Cerc {\n    double raza;\npublic:\n    Cerc(double r = 5.0) { raza = r; }\n    void afis() const { cout &lt;&lt; &quot;Raza este &quot; &lt;&lt; raza &lt;&lt; endl; }\n    void schimba(double r) { raza = r; }\n};\n\nCerc construieste(double x) { return 2 * x; }\n\nvoid verifica(Cerc c)\n{\n    c.afis();\n    c.schimba(2.0);\n    c.afis();\n}\n\nint main()\n{\n    verifica(construieste(1.5));\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>Raza este 3\nRaza este 2</samp>\n<div>\nFunctia <pre class='inline'><code class='language-cpp'>construieste</code></pre> primeste un <pre class='inline'><code class='language-cpp'>double</code></pre> ca parametru si intoarce un obiect de tip <pre class='inline'><code class='language-cpp'>Cerc</code></pre>. Pentru ca aici intoarce de fapt <pre class='inline'><code class='language-cpp'>2 * x</code></pre>, unde <var>x</var> este parametrul, se apeleaza constructorul din clasa <pre class='inline'><code class='language-cpp'>Cerc</code></pre> si se va creea un obiect temporar care se va returna.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>verifica(construieste(1.5));</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>verifica</code></pre> cu obiectul temporar returnat de <pre class='inline'><code class='language-cpp'>construieste</code></pre> (care ara <var>raza</var> egal cu 3). Parametrul este transmis prin valoare deci se copiaza. (probabil nu se va apela constructorul de copiere pentru ca se va face o optimizare, in loc sa se creeze obiectul temporar si dupa sa fie copiat in <var>c</var>, se va construi obiectul direct in <var>c</var>) Chestia asta se numeste <a href=\"https://www.fluentcpp.com/2016/11/28/return-value-optimizations/\">return value optimizations</a>.\n</div>\n<div>\nIn functia <pre class='inline'><code class='language-cpp'>verifica</code></pre> este apelata metoda <pre class='inline'><code class='language-cpp'>afis</code></pre> (care e <pre class='inline'><code class='language-cpp'>const</code></pre> deci nu are voie sa modifice obiectul). Dupa metoda <pre class='inline'><code class='language-cpp'>schimba</code></pre> schimba <var>raza</var> in <pre class='inline'><code class='language-cpp'>2.0</code></pre>. La final se mai apeleaza inca o data metoda <pre class='inline'><code class='language-cpp'>afis</code></pre>.\n</div></div>", "tags": ["medium", "correct", "constructor"]}, {"id": 67, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\nprotected:\n    int x;\npublic:\n    A(int _x = 1) : x(_x) {}\n    virtual int f() const { return x + 1; }\n};\n\nclass B : public A {\n    int y;\npublic:\n    B(int _y = 2) : y(_y) {}\n    int f() const { return x + y; }\n};\n\nclass C : public B {\npublic:\n    C() : B(3) {}\n    int f() const { return x + 100; }\n};\n\nint main()\n{\n    B* p = new C[100];\n    cout &lt;&lt; p-&gt;f();\n\n    delete[] p;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>101</samp>\n<div>\nMetodele care sunt <pre class='inline'><code class='language-cpp'>virtual</code></pre> in clasa de baza si sunt supradefinite in clasa derivata sunt <pre class='inline'><code class='language-cpp'>virtual</code></pre> <a href=\"https://stackoverflow.com/a/58042469\">si in clasa derivata</a>, chiar daca nu scrii cuvantul <pre class='inline'><code class='language-cpp'>virtual</code></pre> (intra si destructorii aici)\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>B* p = new C[100];</code></pre> se creeaza 100 obiecte de tip <pre class='inline'><code class='language-cpp'>C</code></pre>. Constructorii se executa in ordinea <pre class='inline'><code class='language-cpp'>A</code></pre>, <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>C</code></pre>. In cazul asta constructorul default din <pre class='inline'><code class='language-cpp'>C</code></pre> il apeleaza pe cel din <pre class='inline'><code class='language-cpp'>B</code></pre> cu valorea 3. Cel din <pre class='inline'><code class='language-cpp'>B</code></pre> nu il apeleaza explicit pe cel din <pre class='inline'><code class='language-cpp'>A</code></pre> (il apeleaza compilatorul automat) deci constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> ramane cu parametrul default 1 (deci <var>x</var>-ul e 1 pentru toate obiectele). Continuam cu constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> (nu uita ca a fost apelat mai sus cu valoarea 3). El seteaza <var>y</var>-ul la <pre class='inline'><code class='language-cpp'>3</code></pre>. Continuam cu constructorul din <pre class='inline'><code class='language-cpp'>C</code></pre> care nu mai face nimic.\n</div>\n<div>\nDeci toate cele 100 de obiecte au <var>x</var>-ul 1 si <var>y</var>-ul 3. Pointerul <var>p</var> arata spre primul element din array-ul cu 100 de obiecte.\n</div>\n<div>\nMetoda <pre class='inline'><code class='language-cpp'>f</code></pre> din clasa <pre class='inline'><code class='language-cpp'>B</code></pre> este virtuala (chiar daca nu apare cuvantul <pre class='inline'><code class='language-cpp'>virtual</code></pre>, pentru ca supradefineste o metoda care e virtuala).\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p-&gt;f();</code></pre>, pentru ca pointerul <var>p</var> este de tip <pre class='inline'><code class='language-cpp'>B*</code></pre>, ne uitam in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> la functia <pre class='inline'><code class='language-cpp'>f</code></pre> care e virtuala. Pointerul arata spre ceva de tip <pre class='inline'><code class='language-cpp'>C</code></pre> deci vedem daca acolo e supradefinita metoda <pre class='inline'><code class='language-cpp'>f</code></pre>. Este supradefinita si intoarce <pre class='inline'><code class='language-cpp'>x + 100</code></pre> (avem acces la <var>x</var> pentru ca e <pre class='inline'><code class='language-cpp'>protected</code></pre>) adica 101.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>delete[] p;</code></pre> se vor apela pentru fiecare obiect (din 100) destructorii din <pre class='inline'><code class='language-cpp'>B</code></pre> si <pre class='inline'><code class='language-cpp'>A</code></pre> (in ordinea asta, invers fata de constructori), nu din clasa <pre class='inline'><code class='language-cpp'>C</code></pre> deoarece destructorii din <pre class='inline'><code class='language-cpp'>B</code></pre> sau din <pre class='inline'><code class='language-cpp'>A</code></pre> nu sunt <pre class='inline'><code class='language-cpp'>virtual</code></pre>.\n</div></div>", "tags": ["medium", "correct", "inheritance", "virtual", "upcast", "dynamic memory allocation"]}, {"id": 68, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass A {\n    const int x;\npublic:\n\n    A(int y = 10) : x(y) {}\n    int getX() const { return x; }\n};\n\nclass B : public A {\n    int y;\npublic:\n    B() { y = 20; }\n    int getY() const { return y; }\n};\n\nint main()\n{\n    A* p = new B;\n    cout &lt;&lt; p-&gt;getX();\n    if (strcmp( typeid((A*)p).name(), &quot;class B * __ptr64&quot;) == 0)\n        cout &lt;&lt; ((B*)p)-&gt;getY();\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>10</samp>\n<div>\nLa <pre class='inline'><code class='language-cpp'>A* p = new B;</code></pre> se executa constructorii in ordinea <pre class='inline'><code class='language-cpp'>A</code></pre>, <pre class='inline'><code class='language-cpp'>B</code></pre>. In lista de initializare a constructorului din <pre class='inline'><code class='language-cpp'>B</code></pre> nu este apelat constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> cu o valoare, deci se apeleaza (automat) ca parametrul implicit 10. Se seteaza <var>x</var> la 10 (<var>x</var> e <pre class='inline'><code class='language-cpp'>const int</code></pre> deci trebuie initializat in lista de initializare a constructorului, nu merge facut asta in corpul constructorului), dupa se continua cu constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre>, care seteaza <var>y</var> la 20.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p-&gt;getX();</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>getX()</code></pre> din <pre class='inline'><code class='language-cpp'>A</code></pre> (care e <pre class='inline'><code class='language-cpp'>const</code></pre> deci nu poate modifica starea obiectului, gen variabile sau sa apeleze functii neconst, dar oricum nu face asta) si se afiseaza <pre class='inline'><code class='language-cpp'>10</code></pre>.\n</div>\n<div>\n<var>p</var> este de tip <pre class='inline'><code class='language-cpp'>A*</code></pre> deja deci nu are sens vreun cast la <pre class='inline'><code class='language-cpp'>A*</code></pre>, deci <pre class='inline'><code class='language-cpp'>typeid((A*)p).name()</code></pre> e la fel ca <pre class='inline'><code class='language-cpp'>typeid(p).name();</code></pre>. <pre class='inline'><code class='language-cpp'>typeid</code></pre> returneaza un obiect de tip <pre class='inline'><code class='language-cpp'>type_info</code></pre> ce reprezinta informatii despre tipul de date, are si o metoda <pre class='inline'><code class='language-cpp'>name()</code></pre> care returneaza numele tipului de date dar depinde de compilator numele exact. Tipul lui <var>p</var> este <pre class='inline'><code class='language-cpp'>A*</code></pre> (ne intereseaza pointerul, nu obiectul la care arata) deci in numele returnat de <pre class='inline'><code class='language-cpp'>typeid(p).name()</code></pre> nu are de ce sa apara <pre class='inline'><code class='language-cpp'>&quot;B*&quot;</code></pre>. (pe visual studio, typeid(p).name() intoarce <pre class='inline'><code class='language-cpp'>&quot;class A * __ptr64&quot;</code></pre>)\n</div>\n<div>\nFunctia <pre class='inline'><code class='language-cpp'>strcmp</code></pre> primeste ca parametrii 2 siruri de caractere si compara pe rand fiecare caracter. Daca returneaza <pre class='inline'><code class='language-cpp'>0</code></pre> inseamna ca sirurile sunt la fel. Daca returneaza ceva mai mic ca <pre class='inline'><code class='language-cpp'>0</code></pre> inseamna ca primul caracter unde nu se potrivesc sirurile este mai &quot;mic&quot; in primul sir decat in al doilea (adica primul sir e alfabetic inainte de al doilea). Daca returneaza ceva mai mare ca <pre class='inline'><code class='language-cpp'>0</code></pre> e invers.\n</div></div>", "tags": ["medium", "correct", "typeinfo", "RTTI", "inheritance", "access modifiers"]}, {"id": 69, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;class X, class Y&gt;\nX f(X x, Y y)\n{\n    return x + y;\n}\nint* f(int* x, int y)\n{\n    return x - y;\n}\nint main()\n{\n    int* a = new int(200), * b = a;\n \n    cout &lt;&lt; *f(a, b);\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 7: <pre class='inline'><code class='language-cpp'>return x + y;</code></pre>\n</div>\n<samp class='error'>&#39;+&#39;: cannot add two pointers</samp>\n<div>\nLa <pre class='inline'><code class='language-cpp'>int* a = new int(200), *b = a;</code></pre> se aloca spatiu pentru un <pre class='inline'><code class='language-cpp'>int</code></pre> cu valoarea 200 si doi pointeri <var>a</var> si <var>b</var> care arata spre el.\n</div>\n<div>\nSe apeleaza functia <pre class='inline'><code class='language-cpp'>f</code></pre> cu <var>a</var> si <var>b</var> care sunt de tip <pre class='inline'><code class='language-cpp'>int*</code></pre>. Nu se potriveste functia non-template <pre class='inline'><code class='language-cpp'>int* f(int* x, int y)</code></pre> pentru ca primeste un <pre class='inline'><code class='language-cpp'>int*</code></pre> si un <pre class='inline'><code class='language-cpp'>int</code></pre> ca parametrii asa ca ramanem cu functia template unde <pre class='inline'><code class='language-cpp'>X</code></pre> si <pre class='inline'><code class='language-cpp'>Y</code></pre> sunt ambele <pre class='inline'><code class='language-cpp'>int*</code></pre>. Deci avem functia:\n</div>\n<pre class='block'><code>int* f(int* x, int* y)\n{\n    return x + y;\n}</code></pre>\n<div>\nAici avem eroarea pentru ca nu se pot aduna 2 pointeri.\n</div>\n<div>\nCa programul sa fie corect as modifica linia 15 in <pre class='inline'><code class='language-cpp'>int* a = new int(200), b = 0;</code></pre>. Acum avem pointerul <var>a</var> si variabila (care nu e pointer) <var>b</var> cu valorea 0. Cand se apeleaza functia <pre class='inline'><code class='language-cpp'>f</code></pre> aici <pre class='inline'><code class='language-cpp'>cout &lt;&lt; *f(a, b);</code></pre>, <var>a</var> este de tip <pre class='inline'><code class='language-cpp'>int*</code></pre> si <var>b</var> e de tip <pre class='inline'><code class='language-cpp'>int</code></pre>. Se potriveste exact cu functia non-template deci ea e aleasa.\n</div>\n<pre class='block'><code>int* f(int* x, int y)\n{\n    return x - y;\n    // aici intervine aritmetica cu pointeri, x+y e un pointer\n    // care o sa arate cu y*4 bytes spre stanga (sau spre dreapta daca y &lt; 0)\n    // pentru ca 4 bytes e dimensiunea unui int si p este de tip int*\n    // deci x-y o sa arate spre o zona de memorie nefolosita (sau folosita, eroare la runtime)\n}</code></pre>\n<div>\nDe asta am ales <var>b</var> sa fie 0, pentru ca functia practic nu modifica la ce adresa arata pointerul <pre class='inline'><code class='language-cpp'>p</code></pre> (o sa returneze acelasi pointer). Deci <pre class='inline'><code class='language-cpp'>f(a,b)</code></pre> returneaza pointerul <var>a</var> si cu <pre class='inline'><code class='language-cpp'>*</code></pre> se dereferentiaza ca sa accesam obiectul/valorea care se afla in memorie la adresa la care arata pointerul (adica 200).\n</div>\n<div>\nDaca <var>b</var> nu ar fi 0, atunci functia <pre class='inline'><code class='language-cpp'>f</code></pre> ar returna un pointer care arata spre o zona de memorie care e posibil sa nu ne apartina si putem avea eroare la runtime (e undefined behaviour).\n</div></div>", "tags": ["medium", "incorrect", "pointers", "template", "function overloading"]}, {"id": 70, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;class X&gt;\nvoid test(X&amp; a, X&amp; b){\n    X temp;\n    temp = a;\n    a = b;\n    b = temp;\n    cout &lt;&lt; &quot;ttest\\n&quot;;\n}\nvoid test(int&amp; c, int&amp; d){\n    int temp;\n    temp = c;\n    c = d;\n    d = temp;\n    cout &lt;&lt; &quot;test 1\\n&quot;;\n}\nvoid test(int e, int f){\n    int temp;\n    temp = e;\n    e = f;\n    f = temp;\n    cout &lt;&lt; &quot;test 2\\n&quot;;\n}\nvoid test(int g, int* h){\n    int temp;\n    temp = g;\n    g = *h;\n    *h = temp;\n    cout &lt;&lt; &quot;test 3\\n&quot;;\n}\n\nint main()\n{\n    int a = 5, b = 15, c = 25, *d = &amp;a;\n    test(a, b);\n    test(c, d);\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 36: <pre class='inline'><code class='language-cpp'>test(a, b);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;test&quot; matches the argument list</samp>\n<div>\nCum spune si eroarea, se potrivesc mai multe functii si nu se stie care sa se aleaga.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>test(a, b);</code></pre> se potriveste si functia <pre class='inline'><code class='language-cpp'>void test(int e, int f)</code></pre> si functia <pre class='inline'><code class='language-cpp'>void test(int&amp; c, int&amp; d)</code></pre> (pentru ca poti transmite parametrii ori prin referinta ori prin valoare). Cealalta functia non-template are un parametru de tip pointer si iese din discutie. La fel si cea template pentru ca am gasit macar 1 functie non-template care se potriveste.\n</div>\n<div>\nCa programul sa fie corect am putea schimba linia 36 cu <pre class='inline'><code class='language-cpp'>f(a, 2);</code></pre> de exemplu sau <pre class='inline'><code class='language-cpp'>f(2, 3);</code></pre> (sa apara o valoare in loc de unul sau ambele argumente). Ca sa transmiti ceva prin referinta trebuie sa fie stocat in memorie, un numar ca <pre class='inline'><code class='language-cpp'>2</code></pre> sau <pre class='inline'><code class='language-cpp'>-10</code></pre> nu este stocat in memorie (spre deosebire de variabila <var>b</var> de exemplu). Deci la <pre class='inline'><code class='language-cpp'>f(a, 2);</code></pre> doar functia <pre class='inline'><code class='language-cpp'>void test(int e, int f)</code></pre> se potriveste.\n</div>\n<div>\nAlta varianta e sa schimbi ceva (tipurile parametriilor; ordinea parametriilor, cand ai parametrii de mai multe tipuri; numarul parametriilor) la una din functiile care se potrivesc (<pre class='inline'><code class='language-cpp'>void test(int e, int f)</code></pre> si <pre class='inline'><code class='language-cpp'>void test(int&amp; c, int&amp; d)</code></pre>) ca una din ele sa nu se mai potriveasca. <b>Tipul returnat nu conteaza.</b>. Am putea schimba functia <pre class='inline'><code class='language-cpp'>void test(int e, int f)</code></pre> in <pre class='inline'><code class='language-cpp'>void test(int e, int f, int g)</code></pre> si acum nu se mai potriveste.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>test(c, d);</code></pre>, <var>c</var> e de tip <pre class='inline'><code class='language-cpp'>int</code></pre> si <var>d</var> e de tip <pre class='inline'><code class='language-cpp'>int*</code></pre>. Se potriveste functia non-template <pre class='inline'><code class='language-cpp'>void test(int g, int* h)</code></pre> (ultima) deci functia template iese din discutie (se prefera mereu ceva non-template si oricum functia template nici nu s-ar potrivi pentru ca ambii parametrii trebuie sa fie de acelasi tip, aici avem <pre class='inline'><code class='language-cpp'>int</code></pre> si <pre class='inline'><code class='language-cpp'>int*</code></pre>).\n</div></div>", "tags": ["medium", "incorrect", "template", "function overloading", "pointers"]}, {"id": 71, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\n    int x;\npublic:\n    A(int _x) : x(_x) {}\n    int getX() const { return x; }\n};\n\nclass B {\n    A a;\n    int y;\npublic:\n    B(int _y, A _a) { y = _y, a = _a; }\n    int f() const { return y + a.getX(); }\n};\n \n\nint main()\n{\n    A ob1(10);\n    B ob2(20, ob1);\n    cout &lt;&lt; ob1.getX() &lt;&lt; endl;\n    cout &lt;&lt; ob2.f() &lt;&lt; endl;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 15: <pre class='inline'><code class='language-cpp'>B(int _y, A _a) { y = _y, a = _a; }</code></pre>\n</div>\n<samp class='error'>no default constructor exists for class &quot;A&quot;</samp>\n<div>\nClasa <pre class='inline'><code class='language-cpp'>A</code></pre> nu are constructor default. Cand initializezi variabile in corpul constructorului, ele sunt deja create. Adica constructorul din clasa <pre class='inline'><code class='language-cpp'>B</code></pre>: <pre class='inline'><code class='language-cpp'>B(int _y, A _a) { y = _y, a = _a; }</code></pre> este echivalent cu <pre class='inline'><code class='language-cpp'>B(int _y, A _a) : y(), a() { y = _y, a = _a; }</code></pre>. Deci mai intai, in lista de initializare, chiar daca nu scrii tu asta, se creeaza <var>y</var> care e <pre class='inline'><code class='language-cpp'>int</code></pre> si <var>a</var> care e de tip <pre class='inline'><code class='language-cpp'>A</code></pre>. Doar ca nu se poate creea <var>a</var> pentru ca in clasa <pre class='inline'><code class='language-cpp'>A</code></pre>, constructorul trebuie sa primeasca ceva ca parametru.\n</div>\n<div>\nCa programul sa fie corect sunt 2 variante:\n</div>\n<div>\n<b>1)</b> initializezi <var>a</var> in lista de initializare, nu in corpul constructorului (daca faci asta pune-l si pe <var>y</var> acolo, desi pentru un <pre class='inline'><code class='language-cpp'>int</code></pre> nu conteaza e mai bine sa te obisnuiesti asa). Constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> devine: <pre class='inline'><code class='language-cpp'>B(int _y, A _a) : y(_y), a(_a) {}</code></pre>\n</div>\n<div>\n<b>2)</b> dai o valoare default pentru parametrul constructorului din <pre class='inline'><code class='language-cpp'>A</code></pre>: <pre class='inline'><code class='language-cpp'>A(int _x = 0) : x(_x) {}</code></pre>. Acum cand se ajunge la constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre>: <pre class='inline'><code class='language-cpp'>B(int _y, A _a) { y = _y, a = _a; }</code></pre> se poate creea obiectul <var>a</var> si dupa, in corpul constructorului, se copiaza in el ce exista in parametrul <var>_a</var>.\n</div>\n<div>\nDupa modificari, la <pre class='inline'><code class='language-cpp'>A ob1(10);</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>A</code></pre>, se apeleaza constructorul si <var>x</var> ia valoarea <pre class='inline'><code class='language-cpp'>10</code></pre>. La <pre class='inline'><code class='language-cpp'>B ob2(20, ob1);</code></pre> se creeaza un obiect <var>ob2</var> de tip <pre class='inline'><code class='language-cpp'>B</code></pre>. Mai intai se vor executa constructorii pentru datele membre, adica <var>a</var> si <var>y</var> (in ordinea in care i-ai definit ca membri ai clasei). Acum in functie de modificarile de mai sus sunt 2 variante (care fac acelasi lucru practic). La <pre class='inline'><code class='language-cpp'>B(int _y, A _a) : y(_y), a(_a) {}</code></pre> se creeaza obiectul <var>a</var> cu ce este in <var>_a</var> (se foloseste constructorul de copiere). La <pre class='inline'><code class='language-cpp'>B(int _y, A _a) { y = _y, a = _a; }</code></pre> se creeaza mai intai obiect <var>a</var> apelandu-se constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> cu parametrul implicit si dupa in corpul constructorului, ce este in <var>_a</var> se copiaza in <var>a</var> (se foloseste operatorul de atribuire). Oricum la final <var>y</var> ia valoarea <pre class='inline'><code class='language-cpp'>20</code></pre> si <var>a</var> este un obiect care are <var>x</var>-ul egal cu <pre class='inline'><code class='language-cpp'>10</code></pre>.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>ob1.getX()</code></pre> returneaza valorea lui <var>x</var> din <var>ob1</var> adica <pre class='inline'><code class='language-cpp'>10</code></pre>. Metoda este <pre class='inline'><code class='language-cpp'>const</code></pre>, asta inseamna ca nu poate modifica obiectul (deci nu se pot apela in metoda asta alte metode care nu sunt <pre class='inline'><code class='language-cpp'>const</code></pre>). De obicei, un getter este <pre class='inline'><code class='language-cpp'>const</code></pre> pentru ca doar intoarce ceva.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>ob2.f()</code></pre> intoarce valoarea lui <var>y</var> din <var>ob2</var> (adica <pre class='inline'><code class='language-cpp'>20</code></pre>) + valorea lui <var>x</var> din obiectul <var>a</var> (care e in <var>ob2</var>). <var>x</var> este <pre class='inline'><code class='language-cpp'>10</code></pre> de mai sus. Deci la final se returneaza <pre class='inline'><code class='language-cpp'>30</code></pre>. Se afiseaza:\n</div>\n<samp class='output'>10\n30</samp>\n<div>\nEu recomand sa initializezi mereu in lista de initializare (cand poti) ca sa se creeze obiectele direct cu ce trebuie (sa nu se mai piarda timp sa se creeeze obiecte &quot;goale&quot; ca dupa sa se copieze in ele ceva).\n</div></div>", "tags": ["medium", "incorrect", "constructor", "initializer list"]}, {"id": 72, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\npublic:\n    A() { cout &lt;&lt; &quot;A&quot;; }\n    ~A() { cout &lt;&lt; &quot;~A&quot;; }\n};\n\nclass B {\npublic:\n    A a;\n    B() { cout &lt;&lt; &quot;B&quot;; }\n    ~B() { cout &lt;&lt; &quot;~B&quot;; }\n};\n\nclass C : public A, public B {\npublic:\n    B ob;\n    A a;\n    C() : ob(), B() { cout &lt;&lt; &quot;C&quot;; }\n    ~C() { cout &lt;&lt; &quot;~C&quot;; }\n};\n \n\nint main()\n{\n    C ob;\n    return 0;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza: \n</div>\n<samp class='output'>AABABAC~C~A~B~A~B~A~A</samp>\n<div>\nOrdinea de executie a constructorilor este urmatoarea:\n<ol>\n<li> Constructorii claselor de baza virtuale in ordinea in care apar (in cazul asta nu exista) </li>\n<li> Constructorii claselor de baza ne-virtuale in ordinea in care apar (pentru <pre class='inline'><code class='language-cpp'>C</code></pre> care mosteneste <pre class='inline'><code class='language-cpp'>A</code></pre> si <pre class='inline'><code class='language-cpp'>B</code></pre> se executa mai intai constructorii din <pre class='inline'><code class='language-cpp'>A</code></pre> si <pre class='inline'><code class='language-cpp'>B</code></pre>, in ordinea asta) </li>\n<li> Constructorii membrilor clasei (nestatici) in ordinea in care au fost declarati (pentru <pre class='inline'><code class='language-cpp'>C</code></pre> care are membrii <var>ob</var> si <var>a</var> se vor executa constructorii in ordinea asta: pentru <var>ob</var> si dupa pentru <var>a</var>) </li>\n<li> La final constructorul din clasa respectiva (adica corpul constructorului) </li>\n</ol>\nChiar daca in lista de initializare a constructorului ordinea este schimbata, se pastreaza ordinea de mai sus. <b>Constructorii claselor de baza virtuale (oriunde ar fi in ierarhie) sunt apelati de constructorul din clasa &quot;cea mai derivata&quot;.</b>\n</div>\n<div>\nDestructorii sunt executati in ordinea inversa.\n</div>\n<div>\nSe creeaza obiectul <var>ob</var> de tip <pre class='inline'><code class='language-cpp'>C</code></pre>. Clasa <pre class='inline'><code class='language-cpp'>C</code></pre> mosteneste clasele <pre class='inline'><code class='language-cpp'>A</code></pre> si <pre class='inline'><code class='language-cpp'>B</code></pre>. Mergem mai intai in clasa <pre class='inline'><code class='language-cpp'>A</code></pre> care nu mosteneste nimic. <pre class='inline'><code class='language-cpp'>A</code></pre> nu are nici obiecte ca date membre asa ca se executa corpul constructorului (se afiseaza <pre class='inline'><code class='language-cpp'>&quot;A&quot;</code></pre>). Continuam cu <pre class='inline'><code class='language-cpp'>B</code></pre> (pt ca <pre class='inline'><code class='language-cpp'>C</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>A</code></pre> si <pre class='inline'><code class='language-cpp'>B</code></pre>). <pre class='inline'><code class='language-cpp'>B</code></pre> nu mosteneste nimic, insa are o data membra de tip <pre class='inline'><code class='language-cpp'>A</code></pre>. O sa se execute constructorul pentru el mai intai (se afiseaza <pre class='inline'><code class='language-cpp'>&quot;A&quot;</code></pre>) dupa nu mai exista date membre si se executa corpul constructorului din <pre class='inline'><code class='language-cpp'>B</code></pre> (se afiseaza <pre class='inline'><code class='language-cpp'>&quot;B&quot;</code></pre>).\n</div>\n<div>\nAm terminat cu ce mostenenste <pre class='inline'><code class='language-cpp'>C</code></pre> si acum trecem la datele membre din clasa. In ordinea declararii, avem un obiect de tip <pre class='inline'><code class='language-cpp'>B</code></pre> mai intai. Mergem in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> iar, ea nu mosteneste pe nimeni dar are ceva de tip <pre class='inline'><code class='language-cpp'>A</code></pre> ca data membra. Mergem in clasa <pre class='inline'><code class='language-cpp'>A</code></pre>, nu mosteneste nimic, nu are date membre, se executa corpul constructorului (se afiseaza <pre class='inline'><code class='language-cpp'>&quot;A&quot;</code></pre>). Ne intoarcem in <pre class='inline'><code class='language-cpp'>B</code></pre>, nu mai avem date membre, se executa corpul constructorului se afiseaza <pre class='inline'><code class='language-cpp'>&quot;B&quot;</code></pre>.\n</div>\n<div>\nRevenim in clasa <pre class='inline'><code class='language-cpp'>C</code></pre>, am construit prima data membra continuam cu a doua care e de tip <pre class='inline'><code class='language-cpp'>A</code></pre>. La fel, clasa <pre class='inline'><code class='language-cpp'>A</code></pre> nu mosteneste, nu are date membre, se executa corpul constructorului (se afiseaza <pre class='inline'><code class='language-cpp'>&quot;A&quot;</code></pre>). Dupa ce am construit datele membre, se executa corpul constructorului din <pre class='inline'><code class='language-cpp'>C</code></pre> (se afiseaza <pre class='inline'><code class='language-cpp'>&quot;C&quot;</code></pre>).\n</div>\n<div>\nPractic in lista de initializare apar constructorii in ordinea asta, chiar daca nu-i scrii tu sunt adaugati automat:  \n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>C() : A(), B(), ob(), a() { cout &lt;&lt; &quot;C&quot;; }</code></pre>\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>B() : a() { cout &lt;&lt; &quot;B&quot;; }</code></pre>\n</div>\n<div>\nDestructorii se vor apela fix in ordinea inversa.\n</div></div>", "tags": ["correct", "hard", "constructor", "inheritance", "destructors"]}, {"id": 73, "problem": "<pre class=\"block\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\npublic:\n    A() { cout &lt;&lt; &quot;A&quot;; }\n    A(int) { cout &lt;&lt; &quot;A(int)&quot;; }\n};\n\nclass B : virtual public A {\npublic:\n    B() : A(2) { cout &lt;&lt; &quot;B&quot;; }\n};\n\nclass C : public B {\npublic:\n    C() { cout &lt;&lt; &quot;C&quot;; }\n};\n\nint main() {\n    C c;\n}</code></pre>", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>ABC</samp>\n<div>\nOrdinea de executie a constructorilor este urmatoarea:\n<ol>\n<li> Constructorii claselor de baza virtuale in ordinea in care apar </li>\n<li> Constructorii claselor de baza ne-virtuale in ordinea in care apar </li>\n<li> Constructorii membrilor clasei (nestatici) in ordinea in care au fost declarati </li>\n<li> La final constructorul din clasa respectiva (adica corpul constructorului) </li>\n</ol>\n<b>Constructorii claselor de baza virtuale (oriunde ar fi in ierarhie) sunt apelati de constructorul din clasa &quot;cea mai derivata&quot;.</b>\n</div>\n<div>\nDin faptul ca <pre class='inline'><code class='language-cpp'>B</code></pre> mosteneste virtual <pre class='inline'><code class='language-cpp'>A</code></pre> stim ca <pre class='inline'><code class='language-cpp'>A</code></pre> e o clasa de baza virtuala. <pre class='inline'><code class='language-cpp'>C</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>B</code></pre> deci <pre class='inline'><code class='language-cpp'>A</code></pre> este o clasa de baza virtuala pentru <pre class='inline'><code class='language-cpp'>C</code></pre> (nu prea are sens pentru ca n-avem mostenire multipla dar se intampla ceva interesant). Daca creezi un obiect de tip <pre class='inline'><code class='language-cpp'>C</code></pre>, constructorul din <pre class='inline'><code class='language-cpp'>C</code></pre> e responsabil sa-l apeleze pe cel din <pre class='inline'><code class='language-cpp'>A</code></pre> (pentru ca <pre class='inline'><code class='language-cpp'>C</code></pre> e cea mai derivata clasa). Constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> il va apela pe cel din <pre class='inline'><code class='language-cpp'>A</code></pre> doar daca creezi un obiect de tip <pre class='inline'><code class='language-cpp'>B</code></pre> (pentru ca acum <pre class='inline'><code class='language-cpp'>B</code></pre> e cea mai derivata clasa)\n</div>\n<div>\nIn cazul asta, pentru ca este creat un obiect de tip <pre class='inline'><code class='language-cpp'>C</code></pre>, constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> NU mai apeleaza constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> (o sa il apeleze cel din <pre class='inline'><code class='language-cpp'>C</code></pre>). Constructorul din <pre class='inline'><code class='language-cpp'>C</code></pre> e completat automat de compilator sa arate asa: <pre class='inline'><code class='language-cpp'>C() : A(), B() { cout &lt;&lt; &quot;C&quot;; }</code></pre> (se adauga constructori default daca nu adaugi tu altii)\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>C c;</code></pre> se vor executa constructorii in ordinea <pre class='inline'><code class='language-cpp'>A</code></pre>, <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>C</code></pre>. In lista de initializare a constructorului din <pre class='inline'><code class='language-cpp'>C</code></pre> nu este apelat explicit constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> deci se va apela automat constructorul <b>implicit</b> care afiseaza <pre class='inline'><code class='language-cpp'>&quot;A&quot;</code></pre> pe ecran. Continuam cu constructorul pentru <pre class='inline'><code class='language-cpp'>B</code></pre>, care la fel, nu apare in lista de initializare deci se apeleaza cel default. Acum in lista de initializare a constructorului din <pre class='inline'><code class='language-cpp'>B</code></pre> se apeleaza cel din <pre class='inline'><code class='language-cpp'>A</code></pre> dar acest fapt e ignorat pentru ca deja s-a apelat (l-a apelat constructorul din <pre class='inline'><code class='language-cpp'>C</code></pre>). Constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> afiseaza <pre class='inline'><code class='language-cpp'>&quot;B&quot;</code></pre>. Dupa se continua cu constructorul din <pre class='inline'><code class='language-cpp'>C</code></pre> care afiseaza <pre class='inline'><code class='language-cpp'>&quot;C&quot;</code></pre>.\n</div>\n<div>\nDaca nu mosteneam virtual? In cazul asta constructorul din <pre class='inline'><code class='language-cpp'>C</code></pre> nu mai are treaba cu cel din <pre class='inline'><code class='language-cpp'>A</code></pre>. Ar arata practic asa: <pre class='inline'><code class='language-cpp'>C() : B() { cout &lt;&lt; &quot;C&quot;; }</code></pre>. Acum constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> il apeleaza pe cel din <pre class='inline'><code class='language-cpp'>A</code></pre> cu un <pre class='inline'><code class='language-cpp'>int</code></pre> si la final s-ar afisa:\n</div>\n<samp class='output'>A(int)BC</samp></div>", "tags": ["medium", "correct", "inheritance", "virtual", "constructor", "virtual inheritance"]}]}