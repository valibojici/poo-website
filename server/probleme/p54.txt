#BEGIN_PROBLEM
#include <iostream>
using namespace std;

class B {
protected:
    static int x;

public:
    B(int y = 0) { x = y; }
    virtual B f() { return 1-x; }
};
class D : public B {
public:
    D(int y = 0) { x = y; }
    void print() { cout << x; }
};

int B::x = 5;

int main()
{
    B* p1 = new D(10);
    *p1 = p1->f();
    ((D*)p1)->print();
    return 0;
}
#END_PROBLEM


#BEGIN_SOLUTION
<div>
Eu nu consider ca programul asta este corect, da probabil daca il rulezi nu o sa ai probleme si se afiseaza <inline>-9</inline> dar ce se intampla aici este undefined behaviour.
</div>
<div>
Avem clasa <inline>D</inline> care este derivata din <inline>B</inline>. <inline>B* p1 = new B(10);</inline> se creeaza un obiect de tip <inline>D</inline> si un pointer <var>p1</var> de tip <inline>B</inline> care arata spre el (upcast). Se apeleaza mai intai constructorul din <inline>B</inline> care seteaza variabila statica <var>x</var> la 0, dupa se continua cu constructorul din <inline>D</inline> si variabila statica <var>x</var> devine 10.
</div>
<div>
Acum la <inline>*p1 = p1->f();</inline>, <inline>p1->f();</inline> intoarce un obiect de tip <inline>B</inline> (cu <var>x</var>-ul setat la 1-10 adica -9). Acum obiectul la care arata <var>p1</var> este de tip <inline>B</inline>. <var>x</var> este variabila statica, nu uita.
</div>
<div>
Acum la <inline>((D*)p1)->print();</inline> se face un downcast <inline>(D*)p1</inline> si se apeleaza metoda <inline>f</inline> care cauzeaza undefined behaviour, pentru ca <var>p1</var> NU arata spre un obiect de tip <inline>D</inline> si functia <inline>f</inline> este in <inline>D</inline>. Ok, este adevarat ca in metoda <inline>f</inline> nu apare pointerul <inline>this</inline> deci nu este accesat obiectul, doar variabila statica <var>x</var> dar totusi asa spune standard-ul c++.
</div>
<div>
Eu as sterge linia <inline>((D*)p1)->print();</inline>.
</div>
#END_SOLUTION


#BEGIN_TAGS
medium, incorrect, inheritance, cast, pointers
#END_TAGS