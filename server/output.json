{"content": [{"id": 1, "problem": "#include <iostream> \nusing namespace std;\n\nvoid f(int x, int y) {\n\tcout << \"x=\" << x << \" \" << \"y=\" << y << endl;\n}\n\nvoid f(int x, double y) {\n\tcout << \"x+y=\" << x + y << endl;\n}\n\nint main()\n{\n\tf(1.5, 2);\n\tf(4, 2.4);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul funtioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>x=1 y=2\nx+y=6.4</samp>\n<div>\nFunctia f este supraincarcata. La linia 14: <pre class='inline'><code class='language-cpp'>f(1.5, 2);</code></pre> se apeleaza prima functie iar la linia 16: <pre class='inline'><code class='language-cpp'>f(4, 2.4)</code></pre> se apeleaza a doua. De ce? \n</div>\n<div>\nSa ne uitam la <pre class='inline'><code class='language-cpp'>f(1.5, 2);</code></pre>. Ambele functii, <pre class='inline'><code class='language-cpp'>void f(int x, int y)</code></pre> si <pre class='inline'><code class='language-cpp'>void f(int x, double y)</code></pre> au ca prim parametru o variabila de tip <pre class='inline'><code class='language-cpp'>int</code></pre> deci ambele functii convertesc 1.5 la 1 (de la <pre class='inline'><code class='language-cpp'>double</code></pre> la <pre class='inline'><code class='language-cpp'>int</code></pre>).\n</div>\n<div>\nAl doilea parametru din prima functie este de tip <pre class='inline'><code class='language-cpp'>int</code></pre> care se potriveste perfect cu ce avem. Al doilea parametru din a doua functie este de tip <pre class='inline'><code class='language-cpp'>double</code></pre> deci trebuie o conversie de la <pre class='inline'><code class='language-cpp'>int</code></pre> la <pre class='inline'><code class='language-cpp'>double</code></pre>, adica munca in plus. Deci prima functie este aleasa.\n</div>\n<div>\nSimilar se comporta linia 15: <pre class='inline'><code class='language-cpp'>f(4, 2.4);</code></pre>. Pentru mai multe detalii legat de cum se alege o functie daca este supraincarcata si are mai multe variante vezi ce am scris <a href='./tips.html#function-overloading'>aici</a>.\n</div></div>", "tags": ["easy", "correct", "function overloading", "implicit cast"]}, {"id": 2, "problem": "#include <iostream> \nusing namespace std;\n\nvoid f(double x, int y) {\n\tcout << \"x * y =\" << x + y << endl;\n}\n\nvoid f(int x, double y) {\n\tcout << \"x + y =\" << x + y << endl;\n}\n\nint main()\n{\n\tf(1, 2);\n\tf(1.5, 2);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect. Avem eroare de compilare la linia 14: <pre class='inline'><code class='language-cpp'>f(1, 2);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nDe ce avem eroare? In primul rand functia f este supraincarcata. Daca ne uitam la linia 14: <pre class='inline'><code class='language-cpp'>f(1, 2);</code></pre> ambele argumente sunt de tip <pre class='inline'><code class='language-cpp'>int</code></pre>. Acum sa ne uitam la functii: <pre class='inline'><code class='language-cpp'>void f(double x, int y)</code></pre> si <pre class='inline'><code class='language-cpp'>void f(int x, double y)</code></pre>. Prima functie trebuie sa converteasca primul argument (adica 1) din <pre class='inline'><code class='language-cpp'>int</code></pre> in <pre class='inline'><code class='language-cpp'>double</code></pre>, a doua functie nu trebuie sa faca nimic.\n</div>\n<div>\nAcum, prima functie nu trebuie sa mai faca nimic pentru al doilea argument (adica 2) pentru ca e deja <pre class='inline'><code class='language-cpp'>int</code></pre> in schimb a doua funtie trebuie sa convertesca din <pre class='inline'><code class='language-cpp'>double</code></pre> in <pre class='inline'><code class='language-cpp'>int</code></pre>.\n</div>\n<div>\nIn concluzie ambele functii trebuie sa faca o conversie obligatoriu, deci apelul functiei f este ambiguu, nu se stie care functie sa se apeleze. Ca programul sa fie corect sunt mai multe variante:\n</div>\n<div>\n1) schimbi linia 15 din <pre class='inline'><code class='language-cpp'>f(1, 2);</code></pre> in <pre class='inline'><code class='language-cpp'>f(1.0, 2);</code></pre> de exemplu (sa fie un double ca prim argument) sau in <pre class='inline'><code class='language-cpp'>f(1, 2.0);</code></pre>. Ai grija ca ceva de genul <pre class='inline'><code class='language-cpp'>f(1.3, 2.1);</code></pre> da aceeasi eroare.\n</div>\n<div>\n2) schimbi linia 4: <pre class='inline'><code class='language-cpp'>void f(double x, int y) {</code></pre> in <pre class='inline'><code class='language-cpp'>void f(int x, int y){</code></pre>\n</div>\n<div>\n3) schimbi linia 8: <pre class='inline'><code class='language-cpp'>void f(int x, double y) {</code></pre> in <pre class='inline'><code class='language-cpp'>void f(double x, double y) {</code></pre> sau <pre class='inline'><code class='language-cpp'>void f(int x, int y) {</code></pre>\n</div></div>", "tags": ["incorrect", "function overloading", "implicit cast", "easy"]}, {"id": 3, "problem": "#include <iostream> \nusing namespace std;\n\nint f(int x, int y) {\n\tcout << \"Salut din prima functie\" << endl;\n\treturn x + y;\n}\n\ndouble f(int y, int x) {\n\tcout << \"Salut din a doua functie\" << endl;\n\treturn 10.0;\n}\n\nint main()\n{\n\tf(2, 2);\n\tf(2.5, 3);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul nu funtioneaza corect. Avem eroare de compilare la linia 9: <pre class='inline'><code class='language-cpp'>double f(int y, int x) {</code></pre>\n</div>\n<samp class='error'>cannot overload functions distinguished by return type alone</samp>\n<div>\nPare ca functia f este supraincarcata dar nu este asa. Ca sa supraincarci o functie trebuie sa schimbi ori numarul de parametrii ori tipul parametrilor ori ordinea parametrilor (daca ai parametrii cu tipuri diferite) si cateva alte lucruri pe care la discut <a href='./tips.html#function-overloading'> aici</a>.\n</div>\n<div>\nDeci functiile <pre class='inline'><code class='language-cpp'>int f(int x, int y)</code></pre> si <pre class='inline'><code class='language-cpp'>double f(int y, int x)</code></pre> se deosebesc doar prin tipul returnat, care nu este destul pentru a le diferentia (am schimbat si <var>x</var> cu <var>y</var> in a doua functie dar asta nu are nicio treaba, sunt doar niste nume, tot doi parametrii de tip <pre class='inline'><code class='language-cpp'>int</code></pre> avem). De ce nu se deosebesc prin tipul returnat? Pentru ca exista situatii de genul urmator:\n</div>\n<div>\n<pre class='block'><code>#include &lt;iostream&gt; \nusing namespace std;\n\nint calculeazaPret(int pret, float TVA){\n\treturn pret + TVA * pret / 100;\n}\n\nfloat calculeazaPret(int pret, float TVA){\n\treturn pret + TVA * pret / 100;\n}\n\nint main()\n{\n\tdouble x = calculeazaPret(100, 4);\n\tcout &lt;&lt; x &lt;&lt; endl;\n}</code></pre>\n</div>\n<div>\nAici si <pre class='inline'><code class='language-cpp'>int</code></pre> si <pre class='inline'><code class='language-cpp'>float</code></pre> se poate converti la <pre class='inline'><code class='language-cpp'>double</code></pre> deci la linia <pre class='inline'><code class='language-cpp'>double x = calculeazaPret(100, 4);</code></pre> care functie se apeleaza? Ca sa se evite situatii de genul asta fara sens, tipul returnat nu e destul pentru a face diferenta.\n</div>\n<div>\nCa programul sa fie corect trebuie schimbata linia 9: <pre class='inline'><code class='language-cpp'>double f(int y, int x) {</code></pre> in ceva de genul <pre class='inline'><code class='language-cpp'>double f(double y, int x) {</code></pre> de exemplu.\n</div></div>", "tags": ["easy", "incorrect", "function overloading", "function signature"]}, {"id": 4, "problem": "#include <iostream> \nusing namespace std;\n\nvoid g(int x, int y, double z) {\n\tcout << \"x + y + z = \" << x + y + z << endl;\n\tz = x + y;\n}\n\nvoid g(int x, double y, int z) {\n\tcout << \"x + y - z = \" << x + y - z << endl;\n\tz = 5;\n}\n\nvoid g(double x, double y, int z) {\n\tx = y = 1.0;\n\tcout << \"x * y + z =\" << x * y + z << endl;\n}\n\nint main() {\n\tg(5, 6.5, 10);\n\tg(1, 2, 3);\n\tg(4, 5, 2.0);\n}", "solution": "<div><div>\nProgramul nu este corect. Avem eroare de compilare la linia 21: <pre class='inline'><code class='language-cpp'>g(1, 2, 3);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nAvem functia g care este supraincarcata si avem 3 &quot;variante&quot;: <pre class='inline'><code class='language-cpp'>void g(int x, int y, double z)</code></pre>, <pre class='inline'><code class='language-cpp'>void g(int x, double y, int z)</code></pre>, <pre class='inline'><code class='language-cpp'>void g(double x, double y, int z)</code></pre>. In main mai intai apelam functia g aici <pre class='inline'><code class='language-cpp'>g(5, 6.5, 10);</code></pre>. Se potriveste perfect cu a doua functie (<pre class='inline'><code class='language-cpp'>void g(int x, double y, int z)</code></pre>, are 3 argumente in ordinea asta: <pre class='inline'><code class='language-cpp'>int</code></pre>, <pre class='inline'><code class='language-cpp'>double</code></pre>, <pre class='inline'><code class='language-cpp'>int</code></pre>). Cand apelam functia g la sfarsit <pre class='inline'><code class='language-cpp'>g(4, 5, 2.0);</code></pre> si acum se potriveste perfect cu prima functie <pre class='inline'><code class='language-cpp'>void g(int x, int y, double z)</code></pre>.\n</div>\n<div>\nProblemele apar la <pre class='inline'><code class='language-cpp'>g(1, 2, 3);</code></pre>. Toate argumentele sunt de tip <pre class='inline'><code class='language-cpp'>int</code></pre>. Acum sa ne uitam la functii: avem prima si a doua care trebuie sa faca 1 conversie (de la <pre class='inline'><code class='language-cpp'>int</code></pre> la <pre class='inline'><code class='language-cpp'>double</code></pre>) si a treia care trebuie sa faca 2 conversii. A treia iese din discutie fiindca trebuie sa faca mai multa treaba. Dintre prima si a doua functie pe care o alegem? Asta e problema, ca nu stim, se potrivesc amandoua. Deci apelul functiei g la linia 21: <pre class='inline'><code class='language-cpp'>g(1, 2, 3);</code></pre> este ambiguu.\n</div></div>", "tags": ["easy", "incorrect", "function overloading", "implicit cast"]}, {"id": 5, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int x, int y) {\n\tcout << \"x = \" << x << \" si y = \" << y << endl;\n\tcout << \"Prima functie!\" << endl;\n\tint z = x + y;\n}\n\nvoid f(double x, int y) {\n\tdouble z = x + x;\n\tcout << \"Dublul lui x = \" << z << endl;\n\tcout << \"A doua functie!\" << endl;\n\tz = x - 20.0;\n}\n\nint main() {\n\tfloat x = 5;\n\tint y = 2;\n\tf(x, y);\n}", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>Dublul lui x = 10\nA doua functie!</samp>\n<div>\nPoate te-a luat prin surprindere ca este corect. Avem functia f care este supraincarcata <pre class='inline'><code class='language-cpp'>void f(int x, int y)</code></pre> si <pre class='inline'><code class='language-cpp'>void f(double x, int y)</code></pre>. In main apelam functia f cu un <pre class='inline'><code class='language-cpp'>float</code></pre> si cu un <pre class='inline'><code class='language-cpp'>int</code></pre>.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>void f(int x, int y)</code></pre> trebuie sa converteasca <pre class='inline'><code class='language-cpp'>float</code></pre> la <pre class='inline'><code class='language-cpp'>int</code></pre> iar <pre class='inline'><code class='language-cpp'>void f(double x, int y)</code></pre> trebuie sa converteasca <pre class='inline'><code class='language-cpp'>float</code></pre> la <pre class='inline'><code class='language-cpp'>double</code></pre>. Ambele fac o singura conversie de ce nu este ambiguu apelul <pre class='inline'><code class='language-cpp'>f(x, y);</code></pre>?\n</div>\n<div>\nPentru ca aceste conversii si ele de mai multe feluri, unele mai importante decat celelalte si asta contribuie la ce functie se alege in cazul asta.\nConversia de la <pre class='inline'><code class='language-cpp'>float</code></pre> la <pre class='inline'><code class='language-cpp'>double</code></pre> are un nume special putin, se numeste &quot;<b>promotie</b>&quot; (floating-point promotion). Conversia de la <pre class='inline'><code class='language-cpp'>int</code></pre> la <pre class='inline'><code class='language-cpp'>double</code></pre> se numeste tot &quot;<b>conversie</b>&quot; (floating-point conversion). \n</div>\n<div>\nPromotia se refera ca poti reprezenta si pastra exact informatia din tipul care se converteste in tipul convertit fara sa pierzi informatia. (de ex din <pre class='inline'><code class='language-cpp'>float</code></pre> in <pre class='inline'><code class='language-cpp'>double</code></pre> sau din <pre class='inline'><code class='language-cpp'>short</code></pre> in <pre class='inline'><code class='language-cpp'>int</code></pre>). Cand faci o conversie s-ar putea sa pierzi infomatia sau sa se modifice(de ex din <pre class='inline'><code class='language-cpp'>int</code></pre> in <pre class='inline'><code class='language-cpp'>float</code></pre>, pentru ca exista numere intregi care nu se reprezinta exact cu un <pre class='inline'><code class='language-cpp'>float</code></pre> ). Ai grija ca conversia din <pre class='inline'><code class='language-cpp'>int</code></pre> in <pre class='inline'><code class='language-cpp'>long</code></pre> sau <pre class='inline'><code class='language-cpp'>long long</code></pre> (dar si altele) <b>NU</b> sunt promotii, sunt conversii. Pentru mai multe detalii citeste <a href='./tips.html#function-overloading'>aici</a>.\n</div>\n<div>\nIn cazul asta se face o conversie in cazul primei functii si o promotie in cazul celei de a doua functii, si cum promotia este mai puternica nu mai exista ambiguitate si prin <pre class='inline'><code class='language-cpp'>f(x,y);</code></pre> apelezi a doua functie. \n</div></div>", "tags": ["correct", "easy", "function overloading", "implicit cast"]}, {"id": 6, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint *n, *nr, *s;\n\n\tcout << \"Cate numere sunt?\" << endl;\n\tn = new int;\n\tcin >> *n;\t// 5\n\n\tnr = new int[*n];\n\n\tcout << \"Introdu numerele\" << endl;\n\tfor (int i = 0; i < *n; ++i) {\n\t\tcin >> nr[i]; // 1 2 3 4 5\n\t}\n\n\ts = new int(0);\n\tfor (int i = 0; i < *n; ++i) {\n\t\t*s += nr[i];\n\t}\n\n\tcout << \"Suma este: \" << *s << endl;\n\n\tdelete n;\n\tdelete s;\n\tdelete nr;\n}", "solution": "<div><div>\nDaca se citeste de la tastatura <pre class='inline'><code class='language-cpp'>1</code></pre> si dupa <pre class='inline'><code class='language-cpp'>1 2 3 4 5</code></pre> se afiseaza:\n</div>\n<samp class='output'>Cate numere sunt?\n5\nIntrodu numerele\n1 2 3 4 5\nSuma este: 15</samp>\n<div>\nProbabil va functiona corect daca incerci, dar la linia 27: <pre class='inline'><code class='language-cpp'>delete nr;</code></pre> nu e corect. Cand aloci dinamic memorie cu <pre class='inline'><code class='language-cpp'>new</code></pre>, eliberezi memoria cu <pre class='inline'><code class='language-cpp'>delete</code></pre> iar cand aloci memorie cu <pre class='inline'><code class='language-cpp'>new[]</code></pre> eliberezi cu <pre class='inline'><code class='language-cpp'>delete[]</code></pre>. In cazul asta <pre class='inline'><code class='language-cpp'>nr</code></pre> e un array alocat dinamic si trebuie eliberata memoria cu <pre class='inline'><code class='language-cpp'>delete[]</code></pre> nu cu <pre class='inline'><code class='language-cpp'>delete</code></pre>. Daca folosesti <pre class='inline'><code class='language-cpp'>delete</code></pre> pentru un array ce se intampla e <i>undefined behaviour</i>, adica depinde de compilator ce se intampla, poate nimic, poate ceva grav care nu va genera eroare dar va face programul sa nu functioneze corect mai tarziu. Deci corect ar fi sa inlocuiesti <pre class='inline'><code class='language-cpp'>delete nr;</code></pre> cu <pre class='inline'><code class='language-cpp'>delete[] nr;</code></pre>\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>s = new int(0);</code></pre> inseamna ca aloci dinamic un <pre class='inline'><code class='language-cpp'>int</code></pre> si ii dai valoarea 0. Poti pune si alte numere. \n</div>\n<div>\nCand aloci dinamic un array de ex. <pre class='inline'><code class='language-cpp'>int *s = new int[10];</code></pre> si vrei ca elementele sa fie 0 poti scrie direct <pre class='inline'><code class='language-cpp'>int *s = new int[10]()</code></pre>, nu pune nimic intre paranteze.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "dynamic memory allocation"]}, {"id": 7, "problem": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tchar* s = new char[20];\n\tstrcpy(s, \"Hello world!\");\n\n\tcout << s << endl;\n\n\tdelete[] s;\n\n\ts = new char[4];\n\ts[0] = 'a';\n\ts[1] = 'b';\n\ts[2] = 'c';\n\ts[3] = 0;\n\n\tcout << s << endl;\n\n\tdelete[] s;\n}", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>Hello world!\nabc</samp>\n<div>\nSe aloca dinamic spatiu in memorie pentru un sir de caractere de lungime 20 (practic 19 pentru ca ultimul trebuie sa fie caracterul special <pre class='inline'><code class='language-cpp'>&#39;\\0&#39;</code></pre> ca sa marcheze sfarsitul). Se copiaza <pre class='inline'><code class='language-cpp'>&quot;Hello world!&quot;</code></pre> in <var>s</var> si se afiseaza dupa care se sterge si se aloca iar spatiu pentru 4 caractere de data asta. Se pun <pre class='inline'><code class='language-cpp'>&#39;a&#39;</code></pre>, <pre class='inline'><code class='language-cpp'>&#39;b&#39;</code></pre>, <pre class='inline'><code class='language-cpp'>&#39;c&#39;</code></pre> pe primele 3 pozitii iar pe ultima se pune caracterul special <pre class='inline'><code class='language-cpp'>&#39;\\0&#39;</code></pre> sau <pre class='inline'><code class='language-cpp'>0</code></pre> (sau <pre class='inline'><code class='language-cpp'>NULL</code></pre>). La final se elibereaza memoria cu <pre class='inline'><code class='language-cpp'>delete[]</code></pre>.\n</div>\n<div>\nDaca nu pui <pre class='inline'><code class='language-cpp'>&#39;\\0&#39;</code></pre> sau <pre class='inline'><code class='language-cpp'>0</code></pre> la sfarsit se pot afisa caractere in plus la finalul cuvantului pentru ca se afiseaza caracter cu caracter pana la <pre class='inline'><code class='language-cpp'>0</code></pre> pus de tine sau gasit undeva in memorie random.\n</div>\n<pre class='block'><code>s = new char[3];\ns[0] = &#39;a&#39;;\ns[1] = &#39;b&#39;;\ns[2] = &#39;c&#39;;\n\ncout &lt;&lt; s &lt;&lt; endl;</code></pre>\n<div>\nSe afiseaza (pe calculatorul meu):\n</div>\n<samp class='output'>Hello world!\nabc$|PPP</samp></div>", "tags": ["easy", "correct", "pointers", "dynamic memory allocation"]}, {"id": 8, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint a = 5;\n\tint b = 2;\n\tint& x = a;\n\n\tx += b;\n\ta = b;\n\tb += x;\n\n\tcout << a << ' ' << b << ' ' << x << endl;\n}", "solution": "<div><div>\nProgramul este corect, se afiseaza:\n</div>\n<samp class='output'>2 4 2</samp>\n<div>\nSe creeaza variabila <var>a</var> avand valoarea 5 si variabila <var>b</var> avand valoarea 2 si o referinta la variabila <var>a</var>. In cazul asta referinta este un alias pentru variabila <var>a</var> deci <pre class='inline'><code class='language-cpp'>x += b;</code></pre> este practic <pre class='inline'><code class='language-cpp'>a += b;</code></pre>. Deci acum <var>a</var> = 7. Dupa <var>a</var> ia valorea lui <var>b</var> adica 2 si dupa <pre class='inline'><code class='language-cpp'>b += x;</code></pre> inseamna <pre class='inline'><code class='language-cpp'>b += a;</code></pre>. Deci in final <var>a</var> = 2, <var>b</var> = 4.\n</div>\n<div>\nTrebuie sa initializezi o referinta cand o creezi si nu poti schimba la cine se refera referinta dupa ce faci asta.\n</div>\n<pre class='block'><code>int a = 5;\nint&amp; b;\t\t// eroare\nb = a;\n\nint c = 10;\nint &amp;t = c;\nt = a;\t\t// inseamna &#39;c = a;&#39;</code></pre></div>", "tags": ["correct", "references", "easy"]}, {"id": 9, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint x = 1, y = 2, z = 3;\n\tint &a = x, &b = y, &c = z;\n\n\tint& arr[] = { a, b ,c };\n\n\tarr[0] = 100;\n\n\tcout << arr[0] << endl;\n\tcout << x << \" \" << y << \" \" << z << endl;\n}", "solution": "<div><div>\nProgramul nu e corect, avem eroare la linia 8:<pre class='inline'><code class='language-cpp'>int&amp; arr[] = { a, b ,c };</code></pre>\n</div>\n<samp class='error'>array of reference is not allowed</samp>\n<div>\nCum spune si eroarea nu putem creea array-uri (de fapt orice container) de referinte. Trebuie schimbata linia 8:<pre class='inline'><code class='language-cpp'>int&amp; arr[] = { a, b ,c };</code></pre> in <pre class='inline'><code class='language-cpp'>int arr[] = { a, b ,c };</code></pre>.\n</div>\n<div>\nMai intai se creeaza 3 variabile si dupa 3 referinte pentru cele 3 variabile. Dupa se creeaza un array de <pre class='inline'><code class='language-cpp'>int</code></pre> iar valorile din el sunt de fapt valorile variabilelor <var>x</var>, <var>y</var>, <var>z</var> pentru ca referintele sunt ca un alias pentru variabilele <var>x</var>, <var>y</var>, <var>z</var> deci <pre class='inline'><code class='language-cpp'>arr[0] = 100;</code></pre> nu modifica valoarea lui <var>x</var>.\n</div>\n<div>\nDe ce nu putem avea array de referinte? Cand creezi un array, de ex <pre class='inline'><code class='language-cpp'>int v[3] = {1, 2, 3};</code></pre>, <pre class='inline'><code class='language-cpp'>v</code></pre> este un pointer la primul element, iar elementele sunt unele langa altele in memorie. Cand accesezi elementul <pre class='inline'><code class='language-cpp'>v[2]</code></pre> de fapt este <pre class='inline'><code class='language-cpp'>*(v + 2)</code></pre>(de la primul element te duci 2 pozitii in fata). Acum daca ai avea <pre class='inline'><code class='language-cpp'>int&amp; v[3] = {a, b, c};</code></pre> v este un pointer la primul element, adica <var>a</var>, dar <var>a</var> e referinta si adresa lui <var>a</var> este adresa varibilei la care se refera (pentru care e un alias) care este altundeva in memorie deci nu ai cum sa te referi la restul elementelor.\n</div>\n<div>\nDe asemenea nu poti avea pointeri la referinte si referinte la referinte.\n</div></div>", "tags": ["incorrect", "easy", "references"]}, {"id": 10, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint x = 123, y = 456;\n\tint& rx = x;\n\trx = 50;\n\t\n\tint* p = &rx;\n\tint*& rp = p;\n\n\t*rp = 100;\n\tp = &y;\n\t*rp = 200;\n\n\tcout << x << ' ' << y << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>100 200</samp>\n<div>\nAvem doua variabile <var>x</var> si <var>y</var> si o referinta la <var>x</var>. <pre class='inline'><code class='language-cpp'>rx = 50;</code></pre> este de fapt <pre class='inline'><code class='language-cpp'>x = 50;</code></pre> pentru ca referinta este ca un alias pentru variabila <var>x</var>. Dupa avem un pointer care arata spre adresa de memorie lui <var>rx</var> care este de fapt adresa de memorie lui <var>x</var> pentru ca referintele nu ocupa memorie. Dupa la linia 10: <pre class='inline'><code class='language-cpp'>int*&amp; rp = p;</code></pre> se creeaza o referinta la pointerul <var>p</var>. Deci acum <var>rp</var> este practic <var>p</var>. <pre class='inline'><code class='language-cpp'>*rp = 100;</code></pre> este ca si cum ai scrie <pre class='inline'><code class='language-cpp'>*p = 100;</code></pre>. Adica dereferentiezi pointerul <var>p</var> ca sa ai acces la zona din memorie la care arata, adica la variabila <var>x</var> a carui valorea este modificata in 100.\n</div>\n<div>\nApoi <var>p</var> arata acum spre zona din memorie unde este <var>y</var>. <var>rp</var> continua sa fie o referinta la <var>p</var> deci <pre class='inline'><code class='language-cpp'>*rp = 200;</code></pre> este practic <pre class='inline'><code class='language-cpp'>*p = 200;</code></pre> adica prin <var>p</var> accesezi variabila <var>y</var> a carui valoare o schimbi in 200.\n</div></div>", "tags": ["easy", "pointers", "references", "correct"]}, {"id": 11, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int*& x, int& y) {\n\ty = *x;\n\tx = &y;\n}\n\nint main()\n{\n\tint a = 10;\n\tint b = 20;\n\tint* p = &a;\n\tf(p, b);\n\n\t*p = 0;\n\n\tcout << a << \" \" << b << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>10 0</samp>\n<div>\nSe creeaza 2 variabile <var>a</var> si <var>b</var> si un pointer care arata spre zona de memorie unde este <var>a</var>. Se apeleaza functia f unde parametrii sunt de tip referinta (referinta la un pointer de tip <pre class='inline'><code class='language-cpp'>int</code></pre> si referinta la un <pre class='inline'><code class='language-cpp'>int</code></pre>). Deci in interiorul functiei <var>x</var> este <var>p</var> iar <var>y</var> este <var>b</var>. <var>y</var> ia valoarea variabilei de la adresa la care arata pointerul <var>x</var> adica <var>b</var> ia valorea lui <var>a</var> si dupa <var>x</var> arata spre adresa lui <var>y</var>, deci <var>p</var> arata spre adresa lui <var>b</var>. Prin <pre class='inline'><code class='language-cpp'>*p</code></pre> accesezi zona din memorie la care arata pointerul si in cazul asta setezi valorea lui <var>b</var> la 0.\n</div></div>", "tags": ["correct", "easy", "pointers", "references"]}, {"id": 12, "problem": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N = 99, M = 2;\n\tint v[] = { 10, 20, N, M };\n\n\tint(*p1)[4] = &v;\n\tint* p2 = v;\n\n\tp1++;\n\tp2++;\n\tcout << (*p1)[1] << \" \" << p2[1];\n}", "solution": "<div><div>\nProgramul nu functioneaza corect. Nu avem eroare de compilare dar posibil eroare la runtime pentru ca accesam memorie unde nu trebuie.\n</div>\n<div>\nDeci avem un array <pre class='inline'><code class='language-cpp'>v[] = {10, 20, 99, 2};</code></pre> (am pus direct valorile lui <var>N</var> si <var>M</var>). La linia 9: <pre class='inline'><code class='language-cpp'>int(*p1)[4] = &amp;v;</code></pre> se creeaza un pointer cu numele <var>p1</var> de tip <pre class='inline'><code class='language-cpp'>int(*)[4]</code></pre> care arata spre un array cu 4 elemente, in cazul asta <var>v</var>. Deci <var>p1</var> arata spre intreg array-ul <var>v</var>. \n</div>\n<div>\nCand scrii <pre class='inline'><code class='language-cpp'>int* p2 = v;</code></pre> este ca si cum ai scrie <pre class='inline'><code class='language-cpp'>int* p2 = &amp;v[0];</code></pre>. (se produce un &quot;decay&quot;, array-ul se transforma intr-un pointer la primul element, <var>v</var> nu este de tip <pre class='inline'><code class='language-cpp'>int*</code></pre> ci <pre class='inline'><code class='language-cpp'>int[4]</code></pre> dar totusi poti scrie <pre class='inline'><code class='language-cpp'>int* p2 = v;</code></pre>). Deci <var>p2</var> este un pointer la primul element.\n</div>\n<div>\nDeci <var>p2</var> este un pointer de tip <pre class='inline'><code class='language-cpp'>int*</code></pre> la primul element din array-ul <var>v</var>, iar <var>p1</var> este un pointer de tip <pre class='inline'><code class='language-cpp'>int(*)[4]</code></pre> la intreg array-ul v. Deocamdata ambii pointeri arata spre aceeasi zona de memorie (inceputul array-ului) dar sunt de tipuri <b>diferite</b>.\n</div>\n<div>\nAcum urmeaza partea care nu e corecta. Operatiile aritmetice cu pointeri se folosesc de tipul lor. Un <pre class='inline'><code class='language-cpp'>int</code></pre> are 4 bytes si <var>p2</var> arata spre un <pre class='inline'><code class='language-cpp'>int</code></pre> deci <pre class='inline'><code class='language-cpp'>p2++;</code></pre> inseamna ca adresa la care arata p2 se mareste cu 4 bytes adica trece la urmatorul numar din array-ul <var>v</var> adica <pre class='inline'><code class='language-cpp'>20</code></pre>. Insa <var>p1</var> arata spre un <pre class='inline'><code class='language-cpp'>int[4]</code></pre> si <pre class='inline'><code class='language-cpp'>p1++;</code></pre> mareste adresa lui p1 cu 4*4=16 bytes (dimensiunea lui <pre class='inline'><code class='language-cpp'>int[4]</code></pre>) deci ajunge <b>dupa</b> zona de memorie rezervata pentru array-ul <var>v</var>. Cand scrii <pre class='inline'><code class='language-cpp'>(*p1)[1]</code></pre> si dereferentiezi <var>p1</var> obtii ceva de tip <pre class='inline'><code class='language-cpp'>int[4]</code></pre> adica un array, dar array-ul asta e dupa zona de memorie a lui <var>v</var> daca incerci sa accesezi primul element obtii o valoare random din memorie sau intri peste memorie deja alocata si ai eroare. Este corect sa scrii <pre class='inline'><code class='language-cpp'>p2[1]</code></pre> pentru ca inseamna de fapt <pre class='inline'><code class='language-cpp'>*(p2 + 1)</code></pre> adica urmatorul nr din array-ul <var>v</var> dupa <pre class='inline'><code class='language-cpp'>20</code></pre> adica 99.\n</div>\n<img class='img-fluid' src='./imgs/p12.png' alt='...'>\n<div>\nDeci ca sa fie corect stergi linia 12: <pre class='inline'><code class='language-cpp'>p1++;</code></pre>. Sau ai putea inlocui linia 15: cu <pre class='inline'><code class='language-cpp'>cout &lt;&lt; (*(p1-1))[1] &lt;&lt; &quot; &quot; &lt;&lt; p2[1];</code></pre>. <pre class='inline'><code class='language-cpp'>p1-1</code></pre> inseamna practic ca te intorci la adresa la care se afla <var>v</var>. Ca sa ai acces la array trebuie sa deferentiezi pointerul adica <pre class='inline'><code class='language-cpp'>*(p1-1)</code></pre> si pentru ca <pre class='inline'><code class='language-cpp'>[]</code></pre> are precedenta mai mare mai trebuie niste paranteze <pre class='inline'><code class='language-cpp'>(*(p1-1))[1]</code></pre> si asta inseamana practic <pre class='inline'><code class='language-cpp'>v[1]</code></pre>.\n</div></div>", "tags": ["incorrect", "easy", "pointers", "array"]}, {"id": 13, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint x = 5;\n\tconst int y = 10;\n\n\tconst int* p = &y;\n\tint const* p2 = &x;\n\n\t*p2 = *p;\n\n\tcout << x << \" \" << y << endl;\n}", "solution": "<div><div>\nProgramul nu este corect, avem eroare la linia 11: <pre class='inline'><code class='language-cpp'>*p2 = *p;</code></pre>\n</div>\n<samp class='error'>expression must be a modifiable lvalue</samp>\n<div>\nAvem <var>x</var> care are valoarea 5 si <var>y</var> care are valoarea 10 (<var>y</var> este <pre class='inline'><code class='language-cpp'>const int</code></pre> si deci nu mai poti schimba valoarea lui <var>y</var>, poti elimina partea de const cu un cast dar ce rost mai are). <pre class='inline'><code class='language-cpp'>const int*</code></pre> este identic cu <pre class='inline'><code class='language-cpp'>int const*</code></pre> deci\n</div>\n<pre class='block'><code>const int* p = &amp;y;\nint const* p2 = &amp;x;</code></pre>\n<div>\ne identic cu\n</div>\n<pre class='block'><code>const int* p = &amp;y;\nconst int* p2 = &amp;x;</code></pre>\n<div>\n<pre class='inline'><code class='language-cpp'>const int* p = &amp;y;</code></pre> inseamna un pointer la un <pre class='inline'><code class='language-cpp'>const int</code></pre> adica NU ai voie sa modifici valorea de la adresa la care arata pointerul dar in schimb poti modifica la ce adresa arata pointerul (gen <pre class='inline'><code class='language-cpp'>p = &amp;x;</code></pre> e corect dar <pre class='inline'><code class='language-cpp'>*p = 5;</code></pre> nu e corect pentru ca modific valoarea de la adresa la care arata pointerul).\n</div>\n<div>\nProblema e la <pre class='inline'><code class='language-cpp'>*p2 = *p;</code></pre> ca <var>p2</var> e pointer la <pre class='inline'><code class='language-cpp'>const int</code></pre> si incerci sa modifici valoarea de la adresa la care arata pointerul. Ca sa mearga programul trebuie schimbata linia 9: <pre class='inline'><code class='language-cpp'>int const* p2 = &amp;x;</code></pre> in <pre class='inline'><code class='language-cpp'>int* p2 = &amp;x;</code></pre> si acum <var>p2</var> e pointer la <pre class='inline'><code class='language-cpp'>int</code></pre> si poti sa modifici valoarea de la adresa la care arata pointerul, deci <var>x</var> ia valoarea lui <var>y</var> adica 10.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "const"]}, {"id": 14, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint a = 100;\n\tint b = 200;\n\tint c = 300;\n\n\tint* const p1 = &a;\n\t*p1 = 999;\n\tp1 = &b;\n\t*p1 = 9999;\n\n\tconst int* p2 = &c;\n\tp2 = p1;\n\tp2 = &a;\n\n\tcout << *p1 << ' ' << *p2;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare la linia 11: <pre class='inline'><code class='language-cpp'>p1 = &amp;b;</code></pre>\n</div>\n<samp class='error'>expression must be a modifiable lvalue</samp>\n<div>\n<var>p1</var> este un pointer constant la un <pre class='inline'><code class='language-cpp'>int</code></pre>, deci il poti dereferentia cu <pre class='inline'><code class='language-cpp'>*</code></pre> si sa schimbi valorea de la adresa la care arata, dar nu poti schimba la ce adresa arata (adica arata spre <var>a</var>, nu poti schimba sa arate spre <var>b</var>). Ca sa fie corect poti schimba linia 10: <pre class='inline'><code class='language-cpp'>int* const p1 = &amp;a;</code></pre> in <pre class='inline'><code class='language-cpp'>int* p1 = &amp;a;</code></pre> si acum <var>p1</var> este un simplu pointer la un <pre class='inline'><code class='language-cpp'>int</code></pre> si poti schimba si adresa la care arata.\n</div>\n<pre class='block'><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint a = 100;\n\tint b = 200;\n\tint c = 300;\n\n\tint* p1 = &amp;a;\t// p1 arata spre a\n\t*p1 = 999;\t\t// a ia valorea 999\n\tp1 = &amp;b;\t\t// acum p1 arata spre b\n\t*p1 = 9999;\t\t// b ia valoarea 9999\n\n\tconst int* p2 = &amp;c;\t\t// p2 arata spre c\n\t\n\t// p2 e un pointer la un int constant, poti schimba la ce\n\t// adresa arata dar nu poti schimba valoarea de la adresa \n\t// la care arata: *p2 = 5; eroare si p2 = &amp;a; ok\n\t\n\tp2 = p1;\t// p2 arata spre ce arata p1 adica b\n\tp2 = &amp;a;\t// acum p2 arata spre a (p1 nu se modifica)\n\n\tcout &lt;&lt; *p1 &lt;&lt; &#39; &#39; &lt;&lt; *p2; // 9999 999\n}</code></pre></div>", "tags": ["easy", "incorrect", "pointers", "const"]}, {"id": 15, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int x = 5;\n\tint* const p = &x;\n\n\tint y = 100;\n\tconst int* const p2 = &y;\n\ty = 200;\n\n\tcout << *p + *p2;\n}", "solution": "<div><div>\nProgramul nu este corect, avem eroare la linia 6: <pre class='inline'><code class='language-cpp'>int* const p = &amp;x;</code></pre>\n</div>\n<samp class='error'>a value of type &quot;const int *&quot; cannot be used to initialize an entity of type &quot;int *const&quot;</samp>\n<div>\n<var>p</var> este un pointer const la un <pre class='inline'><code class='language-cpp'>int</code></pre> (poti modifica valoarea de la adresa la care arata, dar nu poti modifica la ce adresa arata pointerul) dar <var>x</var> este <pre class='inline'><code class='language-cpp'>const int</code></pre> si practic ai putea modifica valorea lui prin pointerul <var>p</var> deci nu e corect sa initializezi pointerul <var>p</var> cu adresa lui <var>x</var>. Ca sa fie corect <var>p</var> trebuie sa fie un pointer la <pre class='inline'><code class='language-cpp'>const int</code></pre> sau <var>x</var> sa fie doar <pre class='inline'><code class='language-cpp'>int</code></pre>. Deci ori schimbi linia 5: <pre class='inline'><code class='language-cpp'>const int x = 5;</code></pre> in <pre class='inline'><code class='language-cpp'>int x = 5;</code></pre> ori schimbi linia 6: <pre class='inline'><code class='language-cpp'>int* const p = &amp;x;</code></pre> in <pre class='inline'><code class='language-cpp'>const int* const p = &amp;x</code></pre>.\n</div>\n<div>\n<var>p2</var> este un pointer constant la un <pre class='inline'><code class='language-cpp'>const int</code></pre> deci nu poti modifica valoarea de la adresa la care arata <var>p2</var> si nici adresa la care arata. Poti modifica <var>y</var>, nu are legatura cu <var>p2</var>. La final se afiseaza: <pre class='inline'><code class='language-cpp'>205</code></pre> (daca faci modificarile de mai sus).\n</div>\n<div>\nCa sa nu te incurci cand citesti ceva de genul <pre class='inline'><code class='language-cpp'>const int* const p2 = &amp;y;</code></pre>, citeste de la dreapta la stanga: <var>p2</var> este un const  pointer la un <pre class='inline'><code class='language-cpp'>int</code></pre> const, <pre class='inline'><code class='language-cpp'>const int* const * const p3 = &amp;p2;</code></pre> este un const pointer la un const pointer la un <pre class='inline'><code class='language-cpp'>const int</code></pre>. Poti folosi si site-ul <a href='https://cdecl.org/?q=int*const+*const+p3'>asta</a>.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "const"]}, {"id": 16, "problem": "#include <iostream>\nusing namespace std;\n\nconst int f(int x, int y) {\n\tint* p = &x;\n\tint& ry = y;\n\n\t*p = 100;\n\try = x;\n\try = 5;\n\n\treturn x + y;\n}\n\nint main() {\n\tconst int a = 500;\n\tint b = 300;\n\n\tint c = f(a, b);\n\n\tcout << a << \" \" << b << \" \" << c << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>500 300 105</samp>\n<div>\nAvem <var>a</var> care este un <pre class='inline'><code class='language-cpp'>const int</code></pre> cu valorea 500 si <var>b</var> care are valorea 300. <var>c</var> se initializeaza cu valorea returnata de functia <var>f</var> (nu conteaza ca <var>f</var> intoarce un <pre class='inline'><code class='language-cpp'>const int</code></pre>, se poate initializa un <pre class='inline'><code class='language-cpp'>int</code></pre> cu un <pre class='inline'><code class='language-cpp'>const int</code></pre>).\n</div>\n<div>\nIn functia <var>f</var> parametrii sunt transmisi prin valoare deci <var>x</var> si <var>y</var> sunt copii ale variabilelor <var>a</var> si <var>b</var>. <pre class='inline'><code class='language-cpp'>int* p = &amp;x;</code></pre> inseamna ca pointerul <var>p</var> arata spre zona de memorie unde este <var>x</var>, iar <var>ry</var> este o referinta la y (un alt nume practic). Prin <pre class='inline'><code class='language-cpp'>*p = 100;</code></pre> dereferentiezi pointerul <var>p</var> ca sa ai acces la zona de memorie la care arata si modifici valoarea de acolo in 100, adica <var>x</var> devine 100. <pre class='inline'><code class='language-cpp'>ry = x;</code></pre> inseamna practic <pre class='inline'><code class='language-cpp'>y = x;</code></pre>, pentru ca <var>ry</var> este o referinta la <var>y</var> (NU inseamna ca schimbi la ce se refera <var>ry</var>, nu poti face asta), deci <var>y</var> ia valorea lui <var>x</var> adica 100. <pre class='inline'><code class='language-cpp'>ry = 5;</code></pre> inseamna ca <var>y</var> ia valorea 5. La final se returneaza 100 + 5 adica 105. (nu uita ca <var>x</var> si <var>y</var> sunt copii ale lui <var>a</var> si <var>b</var> deci nu le modifica). Deci <var>a</var> ramane 500, <var>b</var> ramane 300 si <var>c</var> ia valorea 105.\n</div></div>", "tags": ["easy", "pointers", "references", "correct"]}, {"id": 17, "problem": "#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid f(int x, const double& y) {\n\tif (x == 0) {\n\t\tcout << \"x = 0!\";\n\t}\n\telse {\n\t\tcout << y / x << endl;\n\t}\n}\n\nvoid f(int x, double& y) {\n\tcout << x << \" si \" << y << endl;\n}\n\nint main() {\n\tf(2, 3.0);\n\n\tint x = 4;\n\tdouble y = 10.0;\n\n\tf(x, y);\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>1.5\n4 si 10</samp>\n<div>\nPrima functie <pre class='inline'><code class='language-cpp'>void f(int x, const double&amp; y)</code></pre> are ca parametru o referinta la un <pre class='inline'><code class='language-cpp'>const double</code></pre>, asta inseamana ca poti apela functia asta si cu ceva temporar care nu exista in memorie adica <pre class='inline'><code class='language-cpp'>f(1, 2.0)</code></pre> si cu o variabila <pre class='inline'><code class='language-cpp'>f(1, a);</code></pre>.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>void f(int x, double&amp; y)</code></pre> aici referinta e la un <pre class='inline'><code class='language-cpp'>double</code></pre> deci functia se asteapta ca parametrul <var>y</var> sa fie o referinta la ceva care chiar exista in memorie, nu ar merge <pre class='inline'><code class='language-cpp'>f(1, 2.0)</code></pre>.\n</div>\n<div>\nDeci la <pre class='inline'><code class='language-cpp'>f(2, 3.0);</code></pre> se apeleaza prima functie, <var>x</var> e diferit de 0 si se afiseaza 3.0 / 2 adica <pre class='inline'><code class='language-cpp'>1.5</code></pre>.\nLa linia 24: <pre class='inline'><code class='language-cpp'>f(x, y);</code></pre> desi se potrivesc ambele functii a doua este preferata, e mai specifica, si se apeleaza <pre class='inline'><code class='language-cpp'>void f(int x, double&amp; y)</code></pre> si se afiseaza <pre class='inline'><code class='language-cpp'>4 si 10</code></pre>.\n</div>\n<div>\nDaca vrei ca functia sa accepte numai ceva temporar poti scrie <pre class='inline'><code class='language-cpp'>void f(int x, double&amp;&amp; y)</code></pre> (asta de la C++11 incoace), acum <pre class='inline'><code class='language-cpp'>f(1, 2.0);</code></pre> merge dar <pre class='inline'><code class='language-cpp'>f(1, x);</code></pre> nu merge.\n</div></div>", "tags": ["easy", "references", "function overloading", "correct"]}, {"id": 18, "problem": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nvoid afis(char v[][20], int rows) {\n\t\n\tfor (int i = 0; i < rows; ++i) {\n\t\tfor (int j = 0; j < strlen(v[i]); ++j) {\n\t\t\tcout << v[i][j] << \" \";\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\n\nint main() {\n\tchar v[3][20] = {\n\t\t\"Creion\",\n\t\t\"Hartie\",\n\t\t\"Pix\"\n\t};\n\n\tafis(v, 3);\n}", "solution": "<div><div>\nProgramul e corect, se afiseaza:\n</div>\n<samp class='output'>C r e i o n\nH a r t i e\nP i x</samp>\n<div>\nSe creeaza o &quot;matrice&quot; de <pre class='inline'><code class='language-cpp'>char</code></pre> sau mai bine zis, un array de cuvinte, unde lungimea maxima a cuvintelor este 20 si exista 3 cuvinte. Daca ai in parametrii functiei array-uri care au mai multe dimensiuni (in cazul asta 2) trebuie sa specifici marimea pentru fiecare dimensiune in afara de prima (poti si la prima dar daca nu faci asta dimensiunea e variabila). \n</div>\n<pre class='block'><code>void f(int v[][][100])  { /* ... */ } \t// gresit\nvoid f(int v[25][][30]) { /* ... */ } \t// gresit\nvoid f(int v[][20][10]) { /* ... */ } \t// corect\nvoid f(int v[10][20][10]) { /* ... */ } // corect</code></pre>\n<div><pre class='inline'><code class='language-cpp'>void afis(char v[][20], int rows)</code></pre> are ca prim parametru o matrice de <pre class='inline'><code class='language-cpp'>char</code></pre> cu 20 coloane si numar variabil de linii, parametrul <var>rows</var> inseamna numarul de linii.\n</div>\n<div>\nLuam fiecare linie pe rand (pe fiecare linie e un cuvant), acum parcurgem pe rand literele cuvantului respectiv, care poate avea mai putin de 20 de caractere de aceea folosim <pre class='inline'><code class='language-cpp'>strlen</code></pre> care e o functie care ne da numarul de caractere din cuvant. Se afiseaza literele cuvintelor separate prin spatiu, iar cand se termina cuvantul se trece la o linie noua si la urmatorul cuvant.\n</div></div>", "tags": ["correct", "easy", "2d array"]}, {"id": 19, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int x, double y, const int z) \n{\n\tcout << \"x = \" << x << endl;\n\tcout << y / 2 << endl;\n\tint temp = z + x;\n\n\tfor (int i = 0; i < temp; ++i)\n\t{\n\t\tcout << 'a' << ' ' << endl;\n\t}\n}\n\nvoid f(int x,const double y, int z)\n{\n\twhile (x > 1) \n\t{\n\t\tcout << y << \", \";\n\t\tx--;\n\t}\n\tcout << endl;\n\n\tif (z < 0) z = -z;\n\t\n\tcout << x + z << endl;\n}\n \n\nint main() {\n\tconst int x = 4;\n\tconst double y = 3.14;\n\tf(2, 2.0, x);\n\tf(3, y, 3);\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 16\n</div>\n<samp class='error'>function &#39;void f(int,double,const int)&#39; already has a body</samp>\n<div>\nNu te poti baza pe faptul ca un parametru este sau nu <pre class='inline'><code class='language-cpp'>const</code></pre> atunci cand vrei sa supraincarci o functie, decat daca acel parametru este <b>pointer sau referinta</b> pentru ca daca nu este pointer sau referinta se transmite argumentul prin valoare, adica se copiaza si nu conteaza ca parametrul e <pre class='inline'><code class='language-cpp'>const</code></pre> pentru ca oricum este o copie.\n</div>\n<div>\nEroarea spune ca practic definesti aceeasi functie de 2 ori, nu conteaza ca unii paramterii sunt <pre class='inline'><code class='language-cpp'>const</code></pre> pentru ca nu sunt referinte sau pointeri. Ca programul sa functioneze corect poti schimba prima functie (linia 4) in <pre class='inline'><code class='language-cpp'>void f(int x, double&amp; y, const int z)</code></pre>, acum primeste o referinta la <pre class='inline'><code class='language-cpp'>double</code></pre>, ceea ce ii permite sa modifice valoarea argumentului cand se apeleaza functia, deci nu mai face acelasi lucru cu a doua functie care nu putea face asta pentru ca argumentul se transmite prin copiere.\n</div>\n<div>\nCu modificarea de mai sus, <pre class='inline'><code class='language-cpp'>f(2, 2.0, x);</code></pre> se apeleaza a doua functie pentru ca <pre class='inline'><code class='language-cpp'>2.0</code></pre> este o valoare temporara care nu exista in memorie si nu putem avea referinta la ea. La urmatoarea linie <pre class='inline'><code class='language-cpp'>f(3, y, 3);</code></pre> se apeleaza a doua functie pentru ca la prima ai referinta la un <pre class='inline'><code class='language-cpp'>double</code></pre> care NU e const, deci ai putea modifica valorea lui in functie si se va reflecta si in afara functiei, dar in <pre class='inline'><code class='language-cpp'>main</code></pre>, <var>y</var> este <pre class='inline'><code class='language-cpp'>const double</code></pre> si nu-i poti modifica valorea. La final se afiseaza:\n</div>\n<samp class='output'>2,\n5\n3.14, 3.14,\n4</samp></div>", "tags": ["easy", "incorrect", "const", "function overloading"]}, {"id": 20, "problem": "#include <iostream>\nusing namespace std;\n\nint myFunction(int A = 1, int B = 2, int C) {\n\tint temp = A;\n\tfor (int i = 0; i < B; ++i)\n\t{\n\t\ttemp += C;\n\t\tC--;\n\t}\n\treturn temp;\n}\n\nint main() {\n\tint num = myFunction(1, 2, 3);\n\tcout << num << endl;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 4: <pre class='inline'><code class='language-cpp'>int myFunction(int A = 1, int B = 2, int C) {</code></pre>.\n</div>\n<samp class='error'>default argument not at end of parameter list</samp>\n<div>\nDaca ai o functie cu parametrii care au valori implicite, ei trebuie sa se afle la sfarsit, nu pot urma parametrii fara valori implicite dupa cei cu valori implicite.\nCa sa fie corect modifica linia 4 in <pre class='inline'><code class='language-cpp'>int myFunction(int A = 1, int B = 2, int C = 0) {</code></pre> sau in <pre class='inline'><code class='language-cpp'>int myFunction(int A, int B, int C) {</code></pre>. La final se afiseaza:\n</div>\n<samp class='output'>6</samp></div>", "tags": ["easy", "incorrect"]}, {"id": 21, "problem": "#include <iostream>\nusing namespace std;\n\nint f(double x)\n{\n\tint i = 1;\n\twhile (i * i < x)\n\t{\n\t\ti++;\n\t\tcout << '*';\n\t}\n\tcout << '!' << endl;\n\treturn i;\n}\n\nint f(int x)\n{\n\tif (x % 2 == 0)\n\t\treturn x * 2;\n\telse\n\t\treturn x * 3 - 10;\n}\n\nint main()\n{\n\tshort a = 3;\n\tfloat b = 5.0f;\n\n\tint x = f(a);\n\tint y = f(b);\n\n\tcout << x << ' ' << y << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>**!\n-1 3</samp>\n<div>\nFunctia <var>f</var> este supraincarcata. La linia 29: <pre class='inline'><code class='language-cpp'>int x = f(a);</code></pre> se apeleaza functia <var>f</var> cu un <pre class='inline'><code class='language-cpp'>short int</code></pre>. Ambele variante ale functiei <var>f</var> fac o conversie deci nu ar trebui sa fie ambiguu apelul, adica sa nu se stie care functie se apeleaza? In cazul asta nu pentru ca, desi ambele functii fac o conversie, cea de la <pre class='inline'><code class='language-cpp'>short int</code></pre> la <pre class='inline'><code class='language-cpp'>int</code></pre> este mai speciala, se numeste &quot;promotie&quot; (adica valorile care se reprezinta cu un <pre class='inline'><code class='language-cpp'>short int</code></pre> se pot reprezenta la fel de exact si cu un <pre class='inline'><code class='language-cpp'>int</code></pre>). Cand se alege ce functie se apeleaza, promotiile sunt mai importante decat conversile obisnuite si de aceea se apeleaza a doua functie. \n</div>\n<div>\nLa linia 30: <pre class='inline'><code class='language-cpp'>int y = f(b);</code></pre> se apeleaza functia <var>f</var> cu un <pre class='inline'><code class='language-cpp'>float</code></pre>. Este aceeasi situatie de mai sus, din nou conversia din <pre class='inline'><code class='language-cpp'>float</code></pre> in <pre class='inline'><code class='language-cpp'>double</code></pre> este &quot;promotie&quot; deci se alege prima functie. Mai multe detalii <a href='./tips.html#function-overloading'>aici</a>.\n</div></div>", "tags": ["correct", "easy", "function overloading"]}, {"id": 22, "problem": "#include <iostream>\nusing namespace std;\n\nvoid multiply(int* v, int n, int x)\n{\n\tfor (int i = 0; i < n; ++i)\n\t\tv[i] *= x;\n}\n\nvoid print(int* v, int n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << v[i] << ' ';\n\t\n\tcout << endl;\n}\n\nint main()\n{\n\tint* i = new int[5]{ 1, 2, 3, 4, 5 }; \n\t// din C++11 https://www.geeksforgeeks.org/uniform-initialization-in-c/\n\n\tint* j = i;\n\n\tmultiply(i, 5, 2);\n\tprint(i, 5);\n\tprint(j, 5);\n\n\tdelete[] i;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>2 4 6 8 10\n2 4 6 8 10</samp>\n<div>\nSe creeaza un array alocat dinamic cu 5 elemente (1, 2, 3, 4 si 5). Se creeaza un pointer <var>j</var> care arata spre aceeasi zona de memorie ca <var>i</var> (primul element din array). Functia <pre class='inline'><code class='language-cpp'>void multiply(int* v, int n, int x)</code></pre> primeste ca argumente pointerul <var>i</var>, lungimea array-ului si un numar cu care inmulteste toate elementele. La linia 26: <pre class='inline'><code class='language-cpp'>print(i, 5);</code></pre> si linia 27: <pre class='inline'><code class='language-cpp'>print(j, 5);</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>void print(int* v, int n)</code></pre> care printeaza elementele array-ului. Se printeaza aceleasi valori de 2 ori pentru ca <var>i</var> si <var>j</var> arata spre aceeasi zona de memorie.\n</div>\n<div>\nCand scrii o functie <pre class='inline'><code class='language-cpp'>void f(int v[]) { /* ... */ }</code></pre> este acelasi lucru cu <pre class='inline'><code class='language-cpp'>void f(int *v) { /* ... */ }</code></pre> (nu conteaza ca returneaza <pre class='inline'><code class='language-cpp'>void</code></pre> sau array-ul/pointerul este <pre class='inline'><code class='language-cpp'>int</code></pre>). <pre class='inline'><code class='language-cpp'>v[i]</code></pre> este de fapt <pre class='inline'><code class='language-cpp'>*(v + i)</code></pre>.\n</div>\n<div>\nMereu array-urile sunt transmise prin &quot;referinta&quot; la o functie (de fapt cum este mai sus, se transmite pointerul la primul element prin valoare dar asta nu conteaza pentru ca arata spre aceeasi zona de memorie, adica array-ul initial).\n</div></div>", "tags": ["correct", "easy", "dynamic memory allocation", "pointers"]}, {"id": 23, "problem": "#include <iostream>\nusing namespace std;\n\nconst int x;\n\nconst int f(int x, int y)\n{\n\tint temp = x + y;\n\treturn temp;\n}\n\nint main()\n{\n\tint a = f(2, 3);\n\tcout << a << endl;\n}", "solution": "<div><div>\nProgramul nu e corect, avem eroare la linia 4: <pre class='inline'><code class='language-cpp'>const int x;</code></pre>\n</div>\n<samp class='error'>&#39;x&#39;: &#39;const&#39; object must be initialized if not &#39;extern&#39;</samp>\n<div>\nCand creezi o variabila <pre class='inline'><code class='language-cpp'>const</code></pre> trebuie sa-i dai si o valore neaparat, (daca nu e si <pre class='inline'><code class='language-cpp'>extern</code></pre>, <a href='https://stackoverflow.com/a/10422050'>vezi aici</a>) pentru ca nu este stocata in memorie. In cod, unde apare o variabila <pre class='inline'><code class='language-cpp'>const</code></pre> este inlocuita cu valorea ei. Ca sa fie corect modifica linia 4 in: <pre class='inline'><code class='language-cpp'>const int x = 0;</code></pre> de exemplu.\n</div>\n<pre class='block'><code>const int x; \n// gresit\n\nconst int x;\nx = 20;\n// gresit\n\nconst int x = 1;\n// corect</code></pre>\n<div>\nLa final se afiseaza 5 (poti initializa un <pre class='inline'><code class='language-cpp'>int</code></pre> cu valoarea unui <pre class='inline'><code class='language-cpp'>const int</code></pre>).\n</div></div>", "tags": ["incorrect", "const", "easy"]}, {"id": 24, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int*& t, int& x)\n{\n\tcout << \"in functia f\" << endl;\n\tt = &x;\n}\n\nint main()\n{\n\tint x = 20;\n\tint y = 30;\n\tint* p = &x;\n\n\t(*p)++;\n\tf(p, y);\n\t(*p)--;\n\n\tcout << *p << ' ' << x << ' ' << y << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>in functia f\n29 21 29</samp>\n<div>\nAvem doua variabile <var>x</var> si <var>y</var> cu valorile 20 si 30, si un pointer <var>p</var> la <var>x</var>, <var>p</var> arata spre zona de memorie unde se afla <var>x</var>. La linia 16: <pre class='inline'><code class='language-cpp'>(*p)++;</code></pre>, mai intai dereferentiezi pointerul ca sa ai acces la zona de memorie unde arata, adica la <var>x</var> si dupa incrementezi valoarea cu 1, deci practic inseamna <pre class='inline'><code class='language-cpp'>x++;</code></pre>(acum x e 21).\n</div>\n<div>\nCand transmiti parametrii prin referinta (la o functie) modificarile parametrilor se vor reflecta si in afara functiei. In cazul asta functia <var>f</var> primeste un pointer transmis prin referinta, deci il putem modifica in interiorul functiei si se va modifica si in locul unde este apelata functia (in cazul asta in <var>main</var>). La linia 17: <pre class='inline'><code class='language-cpp'>f(p, y)</code></pre> se apeleaza <var>f</var>, se afiseaza <pre class='inline'><code class='language-cpp'>&quot;in functia f&quot;</code></pre> si dupa, pointerul <var>t</var> din functie arata spre parametrul <var>x</var>. Dar pointerul <var>t</var> este practic pointerul <var>p</var> din <var>main</var>, deci acum <var>p</var> nu mai arata spre zona de memorie unde este <var>x</var>, ci unde este <var>y</var>. <pre class='inline'><code class='language-cpp'>(*p)--</code></pre> inseamna de fapt <pre class='inline'><code class='language-cpp'>y--;</code></pre> (y e 29 acum). La final <var>x</var> este 21, <var>y</var> este 29, iar <var>p</var> arata spre zona de memorie unde e <var>y</var>.\n</div></div>", "tags": ["easy", "correct", "pointers"]}, {"id": 25, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int v[])\n{\n\tcout << \"Prima functie\" << endl;\n}\n\nvoid f(int* p)\n{\n\tcout << \"A doua functie\" << endl;\n}\n\nint main()\n{\n\tint v[] = { 1, 2, 3, 4, 5 };\n\tf(v);\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 9: <pre class='inline'><code class='language-cpp'>void f(int *p)</code></pre>\n</div>\n<samp class='error'>function &#39;void f(int [])&#39; already has a body</samp>\n<div>\nCand transmiti un array ca parametru isi pierde &quot;forma&quot; de array, devine un pointer la primul element. Acum, <pre class='inline'><code class='language-cpp'>void f(int v[])</code></pre> si <pre class='inline'><code class='language-cpp'>void f(int* v)</code></pre> par lucruri diferite dar <pre class='inline'><code class='language-cpp'>void f(int v[])</code></pre> este transformat de compilator in <pre class='inline'><code class='language-cpp'>void f(int* v)</code></pre> deci cele 2 functii au aceeasi signatura (nume, numar parametrii, ordine parametrii, tip paramterii).  Practic incerci sa definesti functia <var>f</var> din nou fara sa schimbi ceva la ea (in afara de corp). Ca sa functioneze corect ai variantele:\n</div>\n<div>\n1) schimbi linia 4 in <pre class='inline'><code class='language-cpp'>void(const int v[])</code></pre>, acum prima functie primeste ca parametru un array de <pre class='inline'><code class='language-cpp'>const int</code></pre>. Array-ul din main este de tip <pre class='inline'><code class='language-cpp'>int</code></pre> deci se apeleaza a doua functie.\n</div>\n<div>\n2) schimbi linia 9 in <pre class='inline'><code class='language-cpp'>void(const int* p)</code></pre>, acum a doua functie primeste ca parametru un pointer la un <pre class='inline'><code class='language-cpp'>const int</code></pre> (gandeste ca e identic cu <pre class='inline'><code class='language-cpp'>void(const int p[])</code></pre>). Array-ul din main este de tip <pre class='inline'><code class='language-cpp'>int</code></pre> deci se apeleaza prima functie.\n</div></div>", "tags": ["easy", "incorrect", "pointers"]}, {"id": 26, "problem": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint v[] = { 1, 2, 3, 4, 5 };\n\t\n\tint* p = v;\n\tp++;\n\n\tp[-1] = 10;\n\n\tfor (int i = 0; i < 5; ++i)\n\t\tcout << v[i] << ' ';\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>10 2 3 4 5</samp>\n<div>\nDeci avem un vector <var>v</var> cu 5 elemente (nu mai trebuie sa pui intre <pre class='inline'><code class='language-cpp'>[]</code></pre> numarul de elemente daca spui care sunt, se deduce automat ca sunt 5). <pre class='inline'><code class='language-cpp'>int* p = v;</code></pre> pare ca initializeaza <var>p</var> cu array-ul <var>v</var> dar de fapt inseamna <pre class='inline'><code class='language-cpp'>int* p = &amp;v[0];</code></pre>. Acum <var>p</var> arata spre zona din memorie unde e primul element din array. <pre class='inline'><code class='language-cpp'>p++;</code></pre> inseamna ca <var>p</var> arata acum spre al doilea element. (intr-un array elementele sunt unele langa altele, in ordine, in memorie).\n</div>\n<div>\nPentru un array sau un pointer <var>v</var> si un indice <var>i</var>, expresia <pre class='inline'><code class='language-cpp'>v[i]</code></pre> inseamna <pre class='inline'><code class='language-cpp'>*(v + i)</code></pre>. Te gandesti ca <var>v</var> este un pointer, te duci in dreapta cu <var>i</var> pozitii si dupa dereferentiezi pointerul ca sa ai acces la elementul la care arata. (din cauza asta <pre class='inline'><code class='language-cpp'>v[i]</code></pre> este la fel ca <pre class='inline'><code class='language-cpp'>i[v]</code></pre> pentru ca <pre class='inline'><code class='language-cpp'>*(v + i)</code></pre> e la fel ca <pre class='inline'><code class='language-cpp'>*(i + v)</code></pre> ). Vezi <a href='https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c'>aici</a> despre array-uri pe SO.\n</div>\n<div>\nDeci <var>p</var> arata spre al doilea element si <pre class='inline'><code class='language-cpp'>p[-1] = 10;</code></pre> inseamna <pre class='inline'><code class='language-cpp'>*(p - 1) = 10;</code></pre> adica te duci in stanga cu o pozitie (la primul element) si modifici valoarea in 10. Deci primul element este 10 acum. La final elementele sunt <pre class='inline'><code class='language-cpp'>10, 2, 3, 4, 5</code></pre>\n</div></div>", "tags": ["correct", "easy", "pointers"]}, {"id": 27, "problem": "#include <iostream>\nusing namespace std;\n\nvoid afis(int v[], int n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << v[i] << ' ';\n\tcout << endl;\n}\n\nint main()\n{\n\tint v[] = { 1, 2, 3, 4, 5 };\n\tint w[] = { 10, 20, 30, 40, 50 };\n\n\tv = w;\n\tafis(v, 5);\n\tafis(w, 5);\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 16: <pre class='inline'><code class='language-cpp'>v = w;</code></pre>\n</div>\n<samp class='error'>expression must be a modifiable lvalue</samp>\n<div>\nNu poti modifica un intreg array dupa ce l-ai creat, poti sa modifici elementele pe rand dar nu ceva de genul <pre class='inline'><code class='language-cpp'>v = w;</code></pre>. Ca sa functioneze corect programul trebuie stearsa linia 16: <pre class='inline'><code class='language-cpp'>v = w;</code></pre>. Daca vrei sa copiezi tot vectorul deodata poti folosi functia <pre class='inline'><code class='language-cpp'>memcpy</code></pre> care primeste ca parametrii: un pointer ca destinatie, un pointer ca sursa si dimensiunea in bytes. Poti inlocui linia 16 cu <pre class='inline'><code class='language-cpp'>memcpy(v, w, 5 * sizeof(int));</code></pre>. <pre class='inline'><code class='language-cpp'>sizeof</code></pre> e un operator care iti da dimensiunea in bytes, avem 5 numere deci in total 5 * dimensiunea unui <pre class='inline'><code class='language-cpp'>int</code></pre> bytes. Dar mai bine folosesti un <pre class='inline'><code class='language-cpp'>vector</code></pre> din STL si nu te mai complici cu <pre class='inline'><code class='language-cpp'>memcpy</code></pre>.\n</div></div>", "tags": ["easy", "incorrect"]}, {"id": 28, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(short x, double y)\n{\n\tfor (short i = 0; i < x; ++i)\n\t\tcout << y << \", \";\n\tcout << \"Gata!\" << endl;\n}\n\nvoid f(int x, long double y)\n{\n\tint temp = y;\n\tcout << x + temp << endl;\n}\n\nint main()\n{\n\tshort x = 5;\n\tlong double y = 3.14;\n\tf(x, y);\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare la linia 21: <pre class='inline'><code class='language-cpp'>f(x, y);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nFunctia <var>f</var> este supraincarcata. In <var>main</var> se apeleaza <var>f</var> cu un <pre class='inline'><code class='language-cpp'>short int</code></pre> si un <pre class='inline'><code class='language-cpp'>long double</code></pre>. Luam argumentele pe rand si vedem care varianta a lui <var>f</var> se potriveste cel mai bine pentru fiecare (pot fi mai multe). Primul argument este <pre class='inline'><code class='language-cpp'>short int</code></pre> care se potriveste exact cu prima functie (merge si a doua functie dar acolo trebuie o conversie la <pre class='inline'><code class='language-cpp'>int</code></pre> iar aici nu trebuie). Al doilea argument este <pre class='inline'><code class='language-cpp'>long double</code></pre> care se potriveste exact cu a doua functie (la fel ar merge si o conversie la <pre class='inline'><code class='language-cpp'>double</code></pre> pentru prima functie dar la a doua nu trebuie).\n</div>\n<div>\nDaca ne gandim ca si cum am avea niste multimi, multimea de functii care se potrivesc cel mai bine pentru primul argument este { functia_1 }, iar pentru al doilea argument { functia_2 }. Intersectia dintre multimile astea este &empty;, deci nu se stie ce functie sa se apeleze. (mai multe detalii <a href=\"tips.html#function-overloading\">aici</a>).\n</div>\n<div>\nCa programul sa functioneze corect poti schimba linia 4: <pre class='inline'><code class='language-cpp'>void f(short x, double y)</code></pre> in <pre class='inline'><code class='language-cpp'>void f(short x,long double y)</code></pre> de exemplu. Acum la linia 22: <pre class='inline'><code class='language-cpp'>f(x, y);</code></pre> al doilea argument se potriveste si la prima functie. Deci multimea de functii care se potrivesc cel mai bine pentru argumentul <var>y</var> (care este de tip <pre class='inline'><code class='language-cpp'>long double</code></pre>) este { functia_1, functia_2 }, iar pentru argumentul <var>x</var> ramane { functia_1 }. Intersectia dintre multimile astea este prima functie (<pre class='inline'><code class='language-cpp'>void f(short x,long double y)</code></pre>), deci ea se apeleaza.\nLa final se afiseaza:\n</div>\n<samp class='output'>3.14, 3.14, 3.14, 3.14, 3.14, Gata!</samp></div>", "tags": ["easy", "incorrect", "function overloading"]}, {"id": 29, "problem": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint a = 500;\n\tint b = 250;\n\tint* const p1 = &a;\n\tconst int* p2 = &b;\n\tp2 = p1;\n\tcout << *p1 << ' ' << *p2;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>500 500</samp>\n<div>\n<pre class='inline'><code class='language-cpp'>int* const p1 = &amp;a;</code></pre> inseamna ca se creeaza un pointer <pre class='inline'><code class='language-cpp'>const</code></pre> cu numele <var>p1</var> la un <pre class='inline'><code class='language-cpp'>int</code></pre>. Deci pointerul este <pre class='inline'><code class='language-cpp'>const</code></pre>, nu valoarea la care arata (adica <pre class='inline'><code class='language-cpp'>*p1 = 100;</code></pre> e corect pentru ca modifici valorea de la zona de memorie la care arata, dar <pre class='inline'><code class='language-cpp'>p1 = &amp;b;</code></pre> nu e corect pentru ca nu ai voie sa modifici spre ce zona de memorie arata <var>p1</var>).\n</div>\n<div>\n In schimb <var>p2</var> este un pointer simplu la un <pre class='inline'><code class='language-cpp'>const int</code></pre>. Deci acum pointerul NU mai este <pre class='inline'><code class='language-cpp'>const</code></pre> dar arata spre un <pre class='inline'><code class='language-cpp'>const int</code></pre> ( <pre class='inline'><code class='language-cpp'>p2 = &amp;a;</code></pre> e corect pentru ca poti schimba zona de memorie la care arata, dar <pre class='inline'><code class='language-cpp'>*p2 = 100;</code></pre> nu e corect pentru ca modifici ceva ce este <pre class='inline'><code class='language-cpp'>const int</code></pre>). Deci este corect <pre class='inline'><code class='language-cpp'>p2 = p1;</code></pre>, acum <var>p2</var> arata spre aceeasi zona de memorie ca <var>p1</var>, adica acolo unde este variabila <var>a</var>.\n</div>\n<div>\nLa final se dereferentiaza pointerii (cu <pre class='inline'><code class='language-cpp'>*</code></pre>) ca sa ai acces la variabila de la zona de memorie la care arata (adica la <var>a</var>).\n</div></div>", "tags": ["easy", "correct", "pointers"]}, {"id": 30, "problem": "#include <iostream>\nusing namespace std;\n\nvoid swap(int* const x, int* const y)\n{\n\tint temp = *x;\n\t*x = *y;\n\t*y = temp;\n}\n\nint main()\n{\n\tint a = 500;\n\tint b = 45;\n\tint c = 1000;\n\tswap(&a, &b);\n\tswap(&b, &c);\n\n\tcout << a << \" \" << b << \" \" << c << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>45 1000 500</samp>\n<div>\nFunctia <var>swap</var> are ca parametrii 2 pointeri <pre class='inline'><code class='language-cpp'>const</code></pre> la <pre class='inline'><code class='language-cpp'>int</code></pre>. (adica pointerii sunt constanti nu valorile de la zona de memorie la care arata). Poti modifica ce se afla la adresa la care arata pointerii dar nu poti schimba la ce adresa arata pointerii. Functia <var>swap</var> practic interschimba valorile a 2 variabile, folosindu-se de adresa lor din memorie (adica prin pointerii <var>x</var> si <var>y</var>). Variabila <var>temp</var> tine minte ce valoare este la adresa la care arata pointerul <var>x</var> (cu <pre class='inline'><code class='language-cpp'>*</code></pre> dereferentiezi pointerul ca sa ai acces la ce se afla la adresa de memorie la care arata). Apoi variabila de la adresa unde arata <var>x</var> ia valoarea variabilei de la adresa unde arata <var>y</var>. La final variabila de la adresa unde arata <var>y</var> ia valorea lui <var>temp</var>.\n</div>\n<div>\nIn <var>main</var> se apeleaza <var>swap</var> cu adresele variabilelor, nu cu ele direct, pentru ca functia <var>swap</var> se asteapta sa primeasca niste adrese (ca sa aiba la ce sa arate pointerii). Mai intai se interschimba <var>a</var> cu <var>b</var> si dupa <var>b</var> cu <var>c</var>. La final <var>a</var> e 45, <var>b</var> e 1000 si <var>c</var> e 500.\n</div></div>", "tags": ["correct", "easy", "pointers"]}, {"id": 31, "problem": "#include <iostream>\nusing namespace std;\n\n\nint main() {\n\tint v[] = { 1, 2, 3, 4, 5 };\n\tint s = 0;\n\tfor (int n : v)\t\t// din C++11\n\t{\n\t\ts += n;\n\t\tn *= 2;\n\t}\n\n\tcout << s << endl;\n\n\tfor (int i = 0; i < 5; ++i)\n\t\tcout << v[i] << ' ';\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>15\n1 2 3 4 5</samp>\n<div>\n<pre class='inline'><code class='language-cpp'>for(int n : v) { /* ... */ }</code></pre> se numeste <a href=\"https://www.geeksforgeeks.org/range-based-loop-c/\">range-based for loop</a>. De obicei se foloseste cu containerele din STL dar merge si cu array-uri simple (dar nu merge cu pointeri).\n</div>\n<pre class='block'><code>void f(int v[])\n{\n\tfor (int i : v)\n\t\tcout &lt;&lt; i &lt;&lt; &#39; &#39;;\n\n\t// eroare, v nu este array, este de fapt un pointer.\n\t// Cand transmiti un array ca parametru, se transforma in pointer\n\t// la primul element, se pierde informatia despre dimensiunea si tipul\n\t// array-ului (acum v e doar int* in loc de int[100] de exemplu)\n\t// asta se numeste &#39;array to pointer decay&#39; \n\t// Functia este identica cu:\n\t//\n\t// void f(int *v) { ... }\n}\n\nvoid g( int(&amp;v)[5] )\n{\n\tfor (int i : v)\n\t\tcout &lt;&lt; i &lt;&lt; &#39; &#39;;\n\n\t// aici merge, se transmite array-ul prin &#39;referinta&#39;\n\t// adica se pastreaza &#39;forma&#39; (dimensiunea adica) nu se\n\t// mai transforma in pointer. Range based for loop are nevoie\n\t// de dimensiunea intreg array-ului, !! deci trebuie sa specifici, aici e 5 !!\n\t// (de asta nu merge cu pointeri, se pierde informatia despre dimensiune)\n}</code></pre>\n\n<pre class='block'><code>for(int n : v)\n{\n\ts += n;\n\tn *= 2;\n}\n\n// este ca si cum ai scrie:\n\nfor(int i = 0; i &lt; 5; ++i)\n{\n\tint n = v[i]; // n este o copie !! \n\n\ts += n;\n\tn *= 2;\t\t  // NU se modifica si elementul din array\n}</code></pre>\n\n<div>\nDaca vrei sa si modifici elementele:\n</div>\n<pre class='block'><code>for(int&amp; n : v)\n{\n\ts += n;\n\tn *= 2; \n}\n\n// este ca si cum ai scrie:\n\nfor(int i = 0; i &lt; 5; ++i)\n{\n\tint&amp; n = v[i]; // n este o referinta !! \n\n\ts += n;\n\tn *= 2;        // se modifica si elementul din array\n}</code></pre>\n<div>\nRevenind la problema, parcurgi toate elementele din <var>v</var> cu un range for loop, aduni in <var>s</var> fiecare element si modifici o copie a elementului din array (deci array-ul nu se modifica). Dupa se afiseaza suma, si pe alta linie elementele din array-ul <var>v</var>, care nu s-au schimbat.\n</div></div>", "tags": ["easy", "correct"]}, {"id": 32, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int x, int y, double z, char w)\n{\n\tcout << \"Prima functie.\";\n}\n\nvoid f(int x, long y, double z, int w)\n{\n\tcout << \"A doua functie.\";\n}\n\nvoid f(short x, int y, float z, char w)\n{\n\tcout << \"A treia functie.\";\n}\n\nint main() {\n\tf(3, 4, 5.0, 'a');\n\t\n\tshort int x = 10;\n\tf(x, 50, 1.0f, 2);\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare la linia 23: <pre class='inline'><code class='language-cpp'>f(x, 50, 1.0f, 2);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nCum spune si eroarea, mai multe functii se potrivesc pentru <pre class='inline'><code class='language-cpp'>f(x, 50, 1.0f, 2);</code></pre> si niciuna nu e mai buna ca celelalte deci nu se stie care sa se apeleze.\n</div>\n<div>\nSa incepem mai intai cu <pre class='inline'><code class='language-cpp'>f(3, 4, 5.0, &#39;a&#39;);</code></pre> care e ok. Ne uitam la fiecare argument pe rand si vedem care varianta a functiei <var>f</var> (care e supraincarcata) se potriveste cel mai bine. Mai intai <pre class='inline'><code class='language-cpp'>3</code></pre>, se potrivesc primele 2 functii pentru ca avem un <pre class='inline'><code class='language-cpp'>int</code></pre> si nu trebuie nicio conversie (trebuie la ultima functie). Sa zicem ca punem functiile astea in o multime: { functia_1, functia_2 }. Acum pentru urmatorul argument: <pre class='inline'><code class='language-cpp'>4</code></pre>, este un <pre class='inline'><code class='language-cpp'>int</code></pre> si functiile care se potrivesc sunt prima si ultima, pentru ca nu fac vreo conversie, deci multimea asta este { functia_1, functia_3 }. Pentru al treilea argument, <pre class='inline'><code class='language-cpp'>5.0</code></pre>, care este un <pre class='inline'><code class='language-cpp'>double</code></pre> se potrivesc primele doua functii, la fel pentru ca nu trebuie conversii, deci multimea asta este { functia_1, functia_2 }. Aceeasi logica si pentru ultimul argument, <pre class='inline'><code class='language-cpp'>&#39;a&#39;</code></pre>, care este <pre class='inline'><code class='language-cpp'>char</code></pre>, multimea asta este { functia_1, functia_3 }. Ca sa vedem ce functie se apeleaza luam multimile astea si le intersectam. { functia_1, functia_2 } &cap; { functia_1, functia_3 } &cap; { functia_1, functia_2 } &cap; { functia_1, functia_3 } = { functia_1 }, deci se apeleaza prima functie.\n</div>\n<div>\nAcum, sa ne uitam la <pre class='inline'><code class='language-cpp'>f(x, 50, 1.0f, 2);</code></pre>, unde <var>x</var> este un <pre class='inline'><code class='language-cpp'>short int</code></pre>:\n</div>\n<div class='table-responsive'>\n<table class=\"table table-sm align-middle table-bordered border-altdark\">\n\t<thead class='align-middle'>\n\t\t<tr>\n\t\t\t<th scope=\"col\" class='text-center'>Arg.</th>\n\t\t\t<th scope=\"col\" class='text-center'>Functii care se potrivesc</th>\n\t\t\t<th scope=\"col\" class='text-center'>Functii care nu se potrivesc</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<th class='text-center' scope=\"row\"><pre class='inline'><code class='language-cpp'>x (short)</code></pre></th>\n\t\t\t<td>\n\t\t\t\t<b>Functia 3:</b> <i class='text-nowrap'>void f(<pre class='inline'><code class='language-cpp'>short x</code></pre>, int y, float z, char w)</i> (pentru ca se potriveste exact, e deja <pre class='inline'><code class='language-cpp'>short int</code></pre>)\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<b>Functia 1:</b> <i class='text-nowrap'>void f(<pre class='inline'><code class='language-cpp'>int x</code></pre>, int y, double z, char w)</i> (pentru ca face conversie la <pre class='inline'><code class='language-cpp'>int</code></pre>)\n\t\t\t\t<br>\n\t\t\t\t<b>Functia 2:</b> <i class='text-nowrap'>void f(<pre class='inline'><code class='language-cpp'>int x</code></pre>, long y, double z, int w)</i> (pentru ca face conversie la <pre class='inline'><code class='language-cpp'>int</code></pre>)\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th class='text-center' scope=\"row\"><pre class='inline'><code class='language-cpp'>50 (int)</code></pre></th>\n\t\t\t<td>\n\t\t\t\t<b>Functia 1:</b> <i class='text-nowrap'>void f(int x, <pre class='inline'><code class='language-cpp'>int y</code></pre>, double z, char w)</i> (pentru ca nu trebuie sa se faca conversie)\n\t\t\t\t<br>\n\t\t\t\t<b>Functia 3:</b> <i class='text-nowrap'>void f(short x, <pre class='inline'><code class='language-cpp'>int y</code></pre>, float z, char w)</i> (pentru ca nu trebuie sa se faca conversie)\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<b>Functia 2:</b> <i class='text-nowrap'>void f(int x, <pre class='inline'><code class='language-cpp'>long y</code></pre>, double z, int w)</i> (pentru ca face conversie la <pre class='inline'><code class='language-cpp'>long</code></pre>)\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th class='text-center' scope=\"row\"><pre class='inline'><code class='language-cpp'>1.0f (float)</code></pre></th>\n\t\t\t<td>\n\t\t\t\t<b>Functia 3:</b> <i class='text-nowrap'>void f(short x, int y, <pre class='inline'><code class='language-cpp'>float z</code></pre>, char w)</i> (pentru ca nu trebuie sa se faca conversie)\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<b>Functia 1:</b> <i class='text-nowrap'>void f(int x, int y, <pre class='inline'><code class='language-cpp'>double z</code></pre>, char w)</i> (pentru ca face conversie (promotie) la <pre class='inline'><code class='language-cpp'>double</code></pre>)\n\t\t\t\t<br>\n\t\t\t\t<b>Functia 2:</b> <i class='text-nowrap'>void f(int x, long y, <pre class='inline'><code class='language-cpp'>double z</code></pre>, int w)</i> (pentru ca face conversie (promotie) la <pre class='inline'><code class='language-cpp'>double</code></pre>)\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th class='text-center' scope=\"row\"><pre class='inline'><code class='language-cpp'>2 (int)</code></pre></th>\n\t\t\t<td>\n\t\t\t\t<b>Functia 2:</b> <i class='text-nowrap'>void f(int x, long y, double z, <pre class='inline'><code class='language-cpp'>int w</code></pre>)</i> (pentru ca nu trebuie sa se faca conversie)\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\t<b>Functia 1:</b> <i class='text-nowrap'>void f(int x, int y, double z, <pre class='inline'><code class='language-cpp'>char w</code></pre>)</i> (pentru ca face conversie la <pre class='inline'><code class='language-cpp'>char</code></pre>)\n\t\t\t\t<br>\n\t\t\t\t<b>Functia 3:</b> <i class='text-nowrap'>void f(short x, int y, float z, <pre class='inline'><code class='language-cpp'>char w</code></pre>)</i> (pentru ca face conversie la <pre class='inline'><code class='language-cpp'>char</code></pre>)\n\t\t\t</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n<div>\nDeci avem:\n<br>\n<pre class='inline'><code class='language-cpp'>x</code></pre> -> { functia_3 }\n<br>\n<pre class='inline'><code class='language-cpp'>50</code></pre> -> { functia_1, functia_3 }\n<br>\n<pre class='inline'><code class='language-cpp'>1.0f</code></pre> -> { functia_3 }\n<br>\n<pre class='inline'><code class='language-cpp'>2</code></pre> -> { functia_2 }\n<br>\nIntersectia dintre multimile astea este: &#xD8;. Rezulta ca nu se stie care functie sa se apeleaze (trebuie ca intersectia sa contina exact 1 functie ca sa nu fie ambiguu apelul de functie).\n</div>\n<div>\nCa programul sa fie corect trebuie modificata a treia functie (linia 14: <pre class='inline'><code class='language-cpp'>void f(short x, int y, float z, char w)</code></pre>) in <pre class='inline'><code class='language-cpp'>void f(short x, int y, float z, int w)</code></pre> si acum la linia 23: <pre class='inline'><code class='language-cpp'>f(x, 50, 1.0f, 2);</code></pre> se apeleaza a treia functie.\n</div></div>", "tags": ["easy", "incorrect", "function overloading"]}, {"id": 33, "problem": "#include <iostream>\nusing namespace std;\n \nint main() {\n\tint* const p = new int(2);\n\tint& x = *p;\n\n\tint y = *p;\n\n\tx = 20;\n\t*p = x;\n\tcout << *p << ' ' << y << endl;\n\tdelete p;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>20 2</samp>\n<div>\n<pre class='inline'><code class='language-cpp'>int* const p = new int(2);</code></pre> se creeaza un pointer constant <var>p</var> catre un <pre class='inline'><code class='language-cpp'>int</code></pre> alocat dinamic cu valoarea <pre class='inline'><code class='language-cpp'>2</code></pre>. Pointerul este constant asta inseamna ca nu poti schimba spre ce zona de memorie arata dar poti modifica ce se afla la zona aceea de memorie la care arata. <pre class='inline'><code class='language-cpp'>int&amp; x = *p;</code></pre> se creeaza o referinta (un alias) la ce se afla in zona de memorie la care arata <var>p</var> (cu <pre class='inline'><code class='language-cpp'>*p</code></pre> accesezi ce se afla la zona de memorie la care arata <var>p</var>). Dupa se creeaza o variabila <var>y</var> de tip <pre class='inline'><code class='language-cpp'>int</code></pre> cu valorea <pre class='inline'><code class='language-cpp'>2</code></pre>, adica ce se afla la zona de memorie la care arata <var>p</var>. <pre class='inline'><code class='language-cpp'>x = 20;</code></pre> inseamna practic <pre class='inline'><code class='language-cpp'>*p = 20;</code></pre> pentru ca <var>x</var> este o referinta. <pre class='inline'><code class='language-cpp'>*p = x;</code></pre> inseamna practic <pre class='inline'><code class='language-cpp'>*p = p;</code></pre> deci nu face nimic. La final <pre class='inline'><code class='language-cpp'>*p</code></pre> este <pre class='inline'><code class='language-cpp'>20</code></pre> si <var>y</var> ramane neschimbat, adica 2. De asemenea se elibereaza zona de memorie alocata mai sus. (ce se aloca cu <pre class='inline'><code class='language-cpp'>new</code></pre> se sterge cu <pre class='inline'><code class='language-cpp'>delete</code></pre>, ce se aloca cu <pre class='inline'><code class='language-cpp'>new[]</code></pre> se sterge cu <pre class='inline'><code class='language-cpp'>delete[]</code></pre>).\n</div></div>", "tags": ["easy", "correct", "pointers", "references"]}, {"id": 34, "problem": "#include <iostream>\nusing namespace std;\n\nint f(int x)\n{\n    int y = x * x;\n    return y++;\n}\n\n\nint main()\n{\n    int a = f(2);\n    cout << a << endl;\n    cout << f(++a) << endl;\n    return 0;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>4\n25</samp>\n<div>\nLa linia 13: <pre class='inline'><code class='language-cpp'>int a = f(2);</code></pre>, se apeleaza functia <var>f</var> cu valorea <pre class='inline'><code class='language-cpp'>2</code></pre>: <var>y</var> ia valorea 2*2 adica 4 si acum la <pre class='inline'><code class='language-cpp'>return y++;</code></pre>, pentru ca <pre class='inline'><code class='language-cpp'>++</code></pre> este <b>dupa</b> <var>y</var>, inseamna ca mai intai se returneaza valorea lui <var>y</var> (adica <pre class='inline'><code class='language-cpp'>4</code></pre>) si dupa se adauga <pre class='inline'><code class='language-cpp'>1</code></pre> la <var>y</var>, dar pentru ca functia s-a terminat si <var>y</var> e o simpla variabila locala, nu mai are nici un efect.(ar fi avut daca <var>y</var> era o variabila statica)\n</div>\n<div>\nDeci in <var>main</var> <var>a</var> ia valorea <pre class='inline'><code class='language-cpp'>4</code></pre>. La linia urmatoare <pre class='inline'><code class='language-cpp'>cout &lt;&lt; f(++a) &lt;&lt; endl;</code></pre>, <pre class='inline'><code class='language-cpp'>++</code></pre> este <b>inainte</b> de <var>a</var>, deci mai intai se mareste valoarea lui <var>a</var> si dupa se evalueaza expresia, in cazul asta se apeleaza functia <var>f</var> si dupa <pre class='inline'><code class='language-cpp'>cout</code></pre>.\n</div></div>", "tags": ["easy", "correct"]}, {"id": 35, "problem": "#include <iostream>\nusing namespace std;\n\nint f(int x)\n{\n    int y = x++;\n    return ++y + x;\n}\n\n\nint main()\n{\n    int a = f(2);\n    int x = a++ + 1;\n    cout << x << \" \" << a << endl;\n    return 0;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>7 7</samp>\n<div>\nLa linia 13: <pre class='inline'><code class='language-cpp'>int a = f(2);</code></pre> se apeleaza functia <var>f</var> cu valorea <pre class='inline'><code class='language-cpp'>2</code></pre>. In functie, <pre class='inline'><code class='language-cpp'>int y = x++;</code></pre> inseamna ca mai intai <var>y</var> ia valorea lui <var>x</var> si <b>dupa</b> <var>x</var> se mareste cu 1 (pentru ca <pre class='inline'><code class='language-cpp'>++</code></pre> este dupa <var>x</var>). La <pre class='inline'><code class='language-cpp'>return ++y + x;</code></pre>, <var>x</var> este <pre class='inline'><code class='language-cpp'>3</code></pre> (s-a marit mai sus), iar pentru ca <pre class='inline'><code class='language-cpp'>++</code></pre> este <b>inainte</b> de <var>y</var> mai intai se mareste <var>y</var> cu 1 (acum e 3), abia apoi se face suma si se returneaza (3 + 3 adica 6).\n</div>\n<div>\nDeci in <var>main</var>, <var>a</var> ia valorea 6. La linia 14: <pre class='inline'><code class='language-cpp'>int x = a++ + 1;</code></pre>, <pre class='inline'><code class='language-cpp'>a++</code></pre> mareste valorea lui <var>a</var> cu 1 dupa ce se evalueaza expresia (adica dupa ce <var>x</var> ia valorea nu stiu cat). Deocamdata <var>a</var> ramane 6, iar <var>x</var> este 6 + 1 adica 7. La final nu uita ca se mareste si <var>a</var> cu 1.\n</div>\n<div>\n<b>Totusi nu scrie niciodata ceva de genul </b> <pre class='inline'><code class='language-cpp'>int x = a++ + a;</code></pre> <b>, este <a href=\"https://stackoverflow.com/a/7812241\">unspecified behaviour</a>.</b>\n</div></div>", "tags": ["easy", "correct"]}, {"id": 36, "problem": "#include <iostream>\nusing namespace std;\n\nint x = 0;\n\nint a() {\n    x = 100;\n    return 1;\n}\n\nint b(){\n    x = 200;\n    return 2;\n}\n\nint c(){\n    x = 300;\n    return 3;\n}\n\nvoid print(int x, int y, int z){\n    cout << x << ' ' << y << ' ' << z << endl;\n}\n\nint main()\n{\n    print(a(), b(), c());\n    cout << x << endl;\n    return 0;\n}", "solution": "<div><div>\nProgramul compileaza dar output-ul nu este sigur. Daca rulezi programul asta probabil o sa se afiseze :\n</div>\n<samp class='output'>1 2 3\n100</samp>\n<div>\nDar ideea este ca la linia 15: <pre class='inline'><code class='language-cpp'>print(a(), b(), c());</code></pre> nu se garanteaza o ordine in care sa se evalueze functiile <var>a</var>, <var>b</var> si <var>c</var>. (de obicei e de la dreapta la stanga dar nu e o regula). Deci cum <var>x</var> este o variabila globala si este modificata in fiecare functie la final poate fi ori 100 ori 200 ori 300. (in cazul asta pentru ca functiile sunt prea simple probabil ca compilatorul face ceva optimizari fara sa stim si e posibil ca <var>x</var> sa fie mereu <pre class='inline'><code class='language-cpp'>100</code></pre>). Oricum nu te baza pe ordinea in care se evalueaza o partiile unei expresii pentru ca <a href=\"https://stackoverflow.com/questions/38501587/what-are-the-evaluation-order-guarantees-introduced-by-c17\">nu e specificat</a>.\n</div></div>", "tags": ["easy", "incorrect", "runtime"]}, {"id": 37, "problem": "#include <iostream>\nusing namespace std;\n\nclass A {\n    static int x;\n\npublic:\n    A (int i = 0) { x = i; }\n    \n    int getX() { return x; }\n    int& setX(int i) { x = i; }\n    \n    A operator=(A other){\n        setX(other.getX());\n        return other;\n    }\n};\n\nint main()\n{\n    A a(100), b;\n    cout << (b = a).getX();\n    return 0;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare la compilare (mai exact linking error)\n</div>\n<samp class='error'>unresolved external symbol &quot;private: static int A::x&quot; (?x@A@@0HA)</samp>\n<div>\nVariabilele statice dintr-o clasa trebuie definite <b>in afara</b> ei. <var>x</var> este declarata in clasa dar nu este definita. De obicei cand declari ceva tot atunci si definesti in acelasi timp, dar variabilele statice intr-o clasa sunt o <a href=\"https://stackoverflow.com/a/1411005\">exceptie</a>. Daca nu declari o variabila ai probleme la compilare, daca nu definesti o variabila ai probleme la linkare.\n</div>\n<pre class='block'><code>class A{\n\tint x;\t\t   // declari si definesti x\n\tstatic int y;  // declari y\n};\n\nint A::y = 0;\t   // definesti y</code></pre>\n<div>\nCa sa fie corect, poti schimba linia 5: <pre class='inline'><code class='language-cpp'>static int x;</code></pre> in <pre class='inline'><code class='language-cpp'>int x;</code></pre> si acum <var>x</var> nu mai e <pre class='inline'><code class='language-cpp'>static</code></pre>.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>A a(100), b;</code></pre> se apeleaza constructorul pentru <var>a</var> cu valorea <pre class='inline'><code class='language-cpp'>100</code></pre>, si <var>x</var> ia valorea 100. Pentru <var>b</var> se apeleaza constructorul cu parametrul implicit si <var>x</var> ia valorea 0. La linia <pre class='inline'><code class='language-cpp'>cout &lt;&lt; (b = a).getX();</code></pre> se apeleaza mai intai operatorul <pre class='inline'><code class='language-cpp'>=</code></pre> (<var>b</var> apeleaza si <var>a</var> este argumentul).\n</div>\n<div>\n<var>a</var> se transmite prin valoare in functie (<pre class='inline'><code class='language-cpp'>A operator=(A other)</code></pre>) deci <var>other</var> e o copie al lui <var>a</var>. <pre class='inline'><code class='language-cpp'>setX(other.getX());</code></pre> seteaza <var>x</var>-ul din obiectul in care suntem (<var>b</var> din main) la valorea returnata de <pre class='inline'><code class='language-cpp'>other.getX()</code></pre> (<var>other</var> este o copie a lui <var>a</var> din main deci se returneaza 100). Acum <var>x</var>-ul din <var>b</var> este 100. Functia <pre class='inline'><code class='language-cpp'>operator=</code></pre> returneaza o copie (nu referinta la obiectul curent, cum se face de obicei) a lui <var>other</var> care e neschimbat (care e o copie al lui <var>a</var> din main). Revenind in main, <pre class='inline'><code class='language-cpp'>(b = a)</code></pre> este un obiect temporar (adica ce returneaza <pre class='inline'><code class='language-cpp'>operator=</code></pre>) cu <var>x</var>-ul egal cu 100. Deci <pre class='inline'><code class='language-cpp'>getX()</code></pre> intoarce <pre class='inline'><code class='language-cpp'>100</code></pre> si asta se afiseaza.\n</div>\n<div>\nLa linia 11: <pre class='inline'><code class='language-cpp'>int&amp; setX(int i) { x = i; }</code></pre> nu e tocmai gresit dar n-are sens sa ai o functie care intoarce ceva si sa nu intorci nimic (poate pe visual studio da eroare la linia asta)\n</div></div>", "tags": ["medium", "incorrect", "static"]}, {"id": 38, "problem": "#include <iostream>\nusing namespace std;\n\nclass A\n{\n    int i;\npublic:\n    A(int x = 2) : i(x + 1) {}\n    virtual int get_i() { return i; }\n};\nclass B : public A\n{\n    int j;\npublic:\n    B(int x = 20) : j(x - 2) {}\n    virtual int get_j() { return A::get_i() + j; }\n};\nint main()\n{\n    A o1(5);\n    B o2;\n    cout << o1.get_i() << \" \";\n    cout << o2.get_j() << \" \";\n    cout << o2.get_i();\n    return 0;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>6 21 3</samp>\n<div>\n<pre class='inline'><code class='language-cpp'>A o1(5);</code></pre> se creeaza un obiect <var>o1</var> de tip <pre class='inline'><code class='language-cpp'>A</code></pre>, se apeleaza constructorul din clasa <var>A</var> cu valorea <pre class='inline'><code class='language-cpp'>5</code></pre>, deci <var>i</var>-ul din obiectul <var>o1</var> ia valoarea 5+1 adica <pre class='inline'><code class='language-cpp'>6</code></pre>.\n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>B o2;</code></pre> se creeaza un obiect <var>o2</var> de tip <pre class='inline'><code class='language-cpp'>B</code></pre>. clasa <pre class='inline'><code class='language-cpp'>B</code></pre> este derivata din <pre class='inline'><code class='language-cpp'>A</code></pre> deci mai intai se executa constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> pentru <var>o2</var>. In lista de initializarea a constructorului din <pre class='inline'><code class='language-cpp'>B</code></pre> nu este apelat explicit constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> deci se apeleaza cu parametrul implicit 2. <var>i</var>-ul (din clasa <pre class='inline'><code class='language-cpp'>A</code></pre>) pentru obiectul <var>o2</var> este 2+1 adica <pre class='inline'><code class='language-cpp'>3</code></pre>. Se continua cu constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre>, care seteaza <var>j</var> la 20-2 adica <pre class='inline'><code class='language-cpp'>18</code></pre> (pentru ca in main nu este specificata o valoarea pentru constructor (<pre class='inline'><code class='language-cpp'>B o2;</code></pre>), parametrul <var>x</var> ramane 20).\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; o1.get_i() &lt;&lt; &quot; &quot;;</code></pre>, <pre class='inline'><code class='language-cpp'>o1.get_i()</code></pre> returneaza valorea lui <var>i</var> pentru obiectul <var>o1</var> adica 6 deci se afiseaza <pre class='inline'><code class='language-cpp'>6</code></pre>\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; o2.get_j() &lt;&lt; &quot; &quot;;</code></pre>, <pre class='inline'><code class='language-cpp'>o2.get_j()</code></pre> returneaza <pre class='inline'><code class='language-cpp'>A::get_i() + j</code></pre> (<var>j</var> este 18 de mai sus). Prin <pre class='inline'><code class='language-cpp'>A::get_i()</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> din clasa <pre class='inline'><code class='language-cpp'>A</code></pre> (nu conteaza ca functiile astea sunt <pre class='inline'><code class='language-cpp'>virtual</code></pre>, nici macar nu au acelasi nume si nici nu lucram cu pointeri). Pentru ca nu exista confuzii de nume, <pre class='inline'><code class='language-cpp'>A::get_i()</code></pre> este la fel cu <pre class='inline'><code class='language-cpp'>get_i()</code></pre>(daca in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> era o functie <pre class='inline'><code class='language-cpp'>get_i()</code></pre> atunci cu <pre class='inline'><code class='language-cpp'>A::</code></pre> te referi la cea din clasa <pre class='inline'><code class='language-cpp'>A</code></pre>). <pre class='inline'><code class='language-cpp'>get_i()</code></pre> returneaza valorea lui <var>i</var>, care pentru obiectul <var>o2</var> este 3 (de mai sus). Deci <pre class='inline'><code class='language-cpp'>o2.get_j()</code></pre> returneza 3 + 18 adica <pre class='inline'><code class='language-cpp'>21</code></pre> si se afiseaza <pre class='inline'><code class='language-cpp'>21</code></pre>.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; o2.get_i();</code></pre>, <pre class='inline'><code class='language-cpp'>o2.get_i()</code></pre> returneza valoarea lui <var>i</var> pentru obiectul <var>o2</var> adica <pre class='inline'><code class='language-cpp'>3</code></pre> si asta se si afiseaza.\n</div></div>", "tags": ["medium", "correct", "inheritance", "virtual", "public inheritance", "constructors"]}, {"id": 39, "problem": "#include <iostream>\nusing namespace std;\n\nclass Cerc {\n    double raza;\npublic:\n    Cerc(double r = 5.0) { raza = r; }\n    void afis() { cout << \"Raza este \" << raza << endl; }\n    void schimba(double r) { raza = r; }\n};\n\nCerc construieste(double x) { return Cerc(x); }\n\nvoid verifica(Cerc& c)\n{\n    c.afis();\n    c.schimba(2.0);\n    c.afis();\n}\n \nint main()\n{\n    verifica(construieste(1.5));\n    return 0;\n}", "solution": "<div><div>\nProgramul are eroare de compilare la linia 23: <pre class='inline'><code class='language-cpp'>verifica(construieste(1.5));</code></pre>.\n</div>\n<samp class='error'>initial value of reference to non-const must be an lvalue</samp>\n<div>\nFunctia <pre class='inline'><code class='language-cpp'>Cerc construieste(double x)</code></pre> returneaza un obiect de tip <pre class='inline'><code class='language-cpp'>Cerc</code></pre> temporar, nu este stocat in memorie deci nu ii poti lua adresa. La linia 23: <pre class='inline'><code class='language-cpp'>verifica(construieste(1.5));</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>void verifica(Cerc&amp; c)</code></pre> care primeste o referinta la un obiect de tip <pre class='inline'><code class='language-cpp'>Cerc</code></pre>, dar functia se apeleaza cu obiectul temporar intors de functia <var>construieste</var>. De aici si eroarea, nu poti avea o referinta la ceva temporar.\n</div>\n<div>\nCa programul sa fie corect, trebuie eliminata referinta, linia 15 devine: <pre class='inline'><code class='language-cpp'>void verifica(Cerc c)</code></pre>. Acum cand se apeleaza functia <var>verifica</var>, obiectul temporar este transmis prin valoare (se copiaza) deci nu mai sunt probleme, dar acum modificarile din functia <var>verifica</var> nu se vor mai reflecta in afara functiei pentru ca parametrul nu mai e referinta (aici nu e cazul).\n</div>\n<div>\nPoate esti tentat sa schimbi linia 15 in: <pre class='inline'><code class='language-cpp'>void verifica(const Cerc&amp; c)</code></pre> pentru ca asa functia poate primi ca parametrii si valori temporare (totusi nu poti avea referinte la obiecte temporare, poti avea din C++11 dar se noteaza cu && in loc de &). Nu este corect pentru ca in functia <var>verifica</var> se apeleaza niste metode care nu sunt <pre class='inline'><code class='language-cpp'>const</code></pre>, dar parametrul e de tip <pre class='inline'><code class='language-cpp'>const</code></pre> si ai eroare. \n</div>\n<div class=\"text-center\">\n<button class=\"btn btn-altdark mt-4\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#collapseCode\">Arata programul corect.</button>\n\t<div class=\"collapse\" id=\"collapseCode\">\n<pre class='block'><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Cerc {\n    double raza;\npublic:\n    Cerc(double r = 5.0) { raza = r; }\n    void afis() { cout &lt;&lt; &quot;Raza este &quot; &lt;&lt; raza &lt;&lt; endl; }\n    void schimba(double r) { raza = r; }\n};\n\nCerc construieste(double x) { return Cerc(x); }\n\nvoid verifica(Cerc c) // linia schimbata\n{\n    c.afis();\n    c.schimba(2.0);\n    c.afis();\n}\n \nint main()\n{\n    verifica(construieste(1.5));\n    return 0;\n}</code></pre>\n\t</div>\n</div></div>", "tags": ["medium", "incorrect", "references", "rvalue"]}, {"id": 40, "problem": "#include <iostream>\nusing namespace std;\n\nclass B {\n    int i;\npublic:\n    B() { i = 1; }\n    virtual int get_i() { return i; }\n};\n\nclass D : virtual public B {\n    int j;\npublic:\n    D() { j = 2; }\n    int get_i() { return B::get_i() + j; }\n};\n\nclass D2 : virtual public B {\n    int j2;\npublic:\n    D2() { j2 = 3; }\n    int get_i() { return B::get_i() + j2; }\n};\n\nclass MM : public D, public D2 {\n    int x;\npublic:\n    MM() { x = D::get_i() + D2::get_i(); }\n    int get_i() { return x; }\n};\n\nint main()\n{\n    B* o = new MM();\n    cout << o->get_i() << \" \";\n    \n    MM* p = dynamic_cast<MM*>(o);\n    if (p)\n        cout << p->get_i() << \" \";\n    \n    D* p2 = dynamic_cast<D*>(o);\n    if (p2)\n        cout << p2->get_i();\n    \n    return 0;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>7 7 7</samp>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>B* o = new MM();</code></pre> se aloca dinamic spatiu pentru un obiect de tip <pre class='inline'><code class='language-cpp'>MM</code></pre> iar pointerul de tip <pre class='inline'><code class='language-cpp'>B</code></pre> arata spre el. (upcasting pentru ca MM mosteneste B). Se executa constructorii in ordinea: B, D, D2, MM. Constructorii din B, D, D2 seteaza variabila membra la o anumita valoare iar in MM, <var>x</var> ia valoarea 3 + 4 adica <pre class='inline'><code class='language-cpp'>7</code></pre>.\n</div>\n<div>\nLa linia urmatoare: <pre class='inline'><code class='language-cpp'>cout &lt;&lt; o-&gt;get_i() &lt;&lt; &quot; &quot;</code></pre>, pentru ca <var>o</var> este un pointer de tip <pre class='inline'><code class='language-cpp'>B*</code></pre>, nu uitam in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> la functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> care este <pre class='inline'><code class='language-cpp'>virtual</code></pre>. Cum <var>o</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>MM</code></pre> si in clasa <pre class='inline'><code class='language-cpp'>MM</code></pre> functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> este supradefinita, ea se va apela si va returna valorea lui <var>x</var> adica 7 de mai sus. Deci se afiseaza <pre class='inline'><code class='language-cpp'>7</code></pre>.\n</div>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>MM* p = dynamic_cast&lt;MM*&gt;(o);</code></pre>, se face un dynamic cast la un pointer de tip <pre class='inline'><code class='language-cpp'>MM*</code></pre> si cum <var>o</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>MM</code></pre> va fi ok cast-ul. <var>p</var> este diferit de <pre class='inline'><code class='language-cpp'>nullptr</code></pre> deci se executa ce este in <pre class='inline'><code class='language-cpp'>if</code></pre> adica <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p-&gt;get_i() &lt;&lt; &quot; &quot;;</code></pre>. <var>p</var> este de tip <pre class='inline'><code class='language-cpp'>MM*</code></pre>, se apeleaza functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> din clasa <pre class='inline'><code class='language-cpp'>MM</code></pre> care intoarce 7, deci se afiseaza tot <pre class='inline'><code class='language-cpp'>7</code></pre>.\n</div>\n<div>\nLa linia <pre class='inline'><code class='language-cpp'>D* p2 = dynamic_cast&lt;D*&gt;(o);</code></pre>, se face un dynamic cast la un pointer de tip <pre class='inline'><code class='language-cpp'>D*</code></pre>. Clasa <pre class='inline'><code class='language-cpp'>MM</code></pre> mosteneste clasa <pre class='inline'><code class='language-cpp'>D</code></pre> deci merge cast-ul. La fel se executa ce este in <pre class='inline'><code class='language-cpp'>if</code></pre> adica <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p2-&gt;get_i();</code></pre>. <var>p2</var> este pointer de tip <pre class='inline'><code class='language-cpp'>D*</code></pre> si functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> din clasa <pre class='inline'><code class='language-cpp'>D</code></pre>, desi nu are cuvantul <pre class='inline'><code class='language-cpp'>virtual</code></pre> in fata, <b>este virtuala</b>. De ce? <a href=\"https://stackoverflow.com/a/58042469\">Pentru ca proprietatea unei functii din clasa de baza de a fi virtuala e valabila si pentru functia supradefinita din clasa derivata.</a> Pentru ca <var>p2</var> arata spre un obiect de tip <pre class='inline'><code class='language-cpp'>MM</code></pre> si functia <pre class='inline'><code class='language-cpp'>get_i()</code></pre> din <pre class='inline'><code class='language-cpp'>D</code></pre> este virtuala se apeleaza <pre class='inline'><code class='language-cpp'>get_i()</code></pre> din <pre class='inline'><code class='language-cpp'>MM</code></pre>, care intoarce 7 si se afiseaza <pre class='inline'><code class='language-cpp'>7</code></pre>.\n</div></div>", "tags": ["hard", "correct", "virtual", "inheritance", "polymorphism", "multiple inheritance", "pointers", "dynamic cast"]}, {"id": 41, "problem": "#include <iostream>\nusing namespace std;\n\nclass B {\n    int x;\n\npublic:\n    B(int i = 7) { x = i; }\n    int get_x() { return x; }\n    operator int() { return x; }\n};\nclass D : public B {\npublic:\n    D(int i = -12)\n        : B(i) {}\n\n    D operator+(D a) { return get_x() + a.get_x() + 1; }\n};\nint main()\n{\n    D a;\n    int b = 18;\n    b += a;\n    cout << b;\n    return 0;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>6</samp>\n<div>\nLa linia 21: <pre class='inline'><code class='language-cpp'>D a;</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>D</code></pre>, se executa constructorii in ordinea <pre class='inline'><code class='language-cpp'>B</code></pre>, <pre class='inline'><code class='language-cpp'>D</code></pre>. Cand se apeleaza in main, constructorul <pre class='inline'><code class='language-cpp'>D(int i = -12) : B(i) {}</code></pre> nu primeste niciun argument deci <var>i</var> ramane -12. In lista de initializare se apeleaza constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre> cu valorea <pre class='inline'><code class='language-cpp'>-12</code></pre>, el se executa primul si seteaza <var>x</var>-ul din <pre class='inline'><code class='language-cpp'>B</code></pre> la -12. Apoi se continua cu constructorul din <pre class='inline'><code class='language-cpp'>D</code></pre> care nu mai face nimic.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>b += a;</code></pre>, <var>b</var> este de tip <pre class='inline'><code class='language-cpp'>int</code></pre> deci trebuie o conversie de la <pre class='inline'><code class='language-cpp'>D</code></pre> la <pre class='inline'><code class='language-cpp'>int</code></pre>. Clasa <pre class='inline'><code class='language-cpp'>D</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>operator int()</code></pre> din clasa <pre class='inline'><code class='language-cpp'>B</code></pre> deci o sa fie folosit acum. In clasa <pre class='inline'><code class='language-cpp'>B</code></pre> <pre class='inline'><code class='language-cpp'>operator int()</code></pre> returneaza valorea lui <var>x</var> adica <pre class='inline'><code class='language-cpp'>-12</code></pre>. Deci <pre class='inline'><code class='language-cpp'>b += a;</code></pre> este <pre class='inline'><code class='language-cpp'>b += -12;</code></pre>, adica <var>b</var> devine 18 - 12 = <pre class='inline'><code class='language-cpp'>6</code></pre>.\n</div></div>", "tags": ["medium", "correct", "cast", "inheritance"]}, {"id": 42, "problem": "#include <iostream>\n#include <typeinfo>\nusing namespace std;\n\nclass A {\n    const int x;\npublic:\n\n    A(int y = 10) : x(y) {}\n    int getX() const { return x; }\n};\n\nclass B : A {\n    int y;\npublic:\n    B() { y = 20; }\n    int getY() const { return y; }\n};\n\nint main()\n{\n    A* p = new B;\n    cout << p->getX();\n    if (typeid((A*)p).name() == \"B*\")\n        cout << ((B*)p)->getY();\n    return 0;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, eroare de compilare la linia 22: <pre class='inline'><code class='language-cpp'>A* p = new B;</code></pre>\n</div>\n<samp class='error'>conversion to inaccessible base class &quot;A&quot; is not allowed</samp>\n<div>\nClasa <pre class='inline'><code class='language-cpp'>B</code></pre> mosteneste <b>privat</b> clasa <pre class='inline'><code class='language-cpp'>A</code></pre>, pentru ca modificatorul de access default la mostenire e <pre class='inline'><code class='language-cpp'>private</code></pre>. Cand mostenesti privat, din exterior nu stie nimeni ca ai derivat. La linia <pre class='inline'><code class='language-cpp'>A* p = new B;</code></pre> vrei sa faci upcasting, deci presupui ca <pre class='inline'><code class='language-cpp'>B</code></pre> mosteneste <pre class='inline'><code class='language-cpp'>A</code></pre> dar nu stie nimeni asta aici in <var>main</var> (doar cand esti in clasa <pre class='inline'><code class='language-cpp'>B</code></pre> stii asta) deci nu e valabil. E ca si cum ai vrea sa faci upcasting dar fara mostenire, nu merge.\n</div>\n<div>\nCa sa fie corect, trebuie sa mostenesti public, deci linia 13 sa devina <pre class='inline'><code class='language-cpp'>class B : public A {</code></pre>.\n</div>\n<div>\nDupa modificari, la <pre class='inline'><code class='language-cpp'>A* p = new B;</code></pre> se apeleaza constructorii in ordinea <pre class='inline'><code class='language-cpp'>A</code></pre>, <pre class='inline'><code class='language-cpp'>B</code></pre>. In lista de initializare a constructorului din <pre class='inline'><code class='language-cpp'>B</code></pre> nu este apelat constructorul din <pre class='inline'><code class='language-cpp'>A</code></pre> cu o valoare, deci se apeleaza ca parametrul implicit 10. Se seteaza <var>x</var> la 10 (<var>x</var> e <pre class='inline'><code class='language-cpp'>const int</code></pre> deci trebuie initializat in lista de initializare a constructorului, nu merge facut asta in corpul constructorului), dupa se continua cu constructorul din <pre class='inline'><code class='language-cpp'>B</code></pre>, care seteaza <var>y</var> la 20.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>cout &lt;&lt; p-&gt;getX();</code></pre> se apeleaza functia <pre class='inline'><code class='language-cpp'>getX()</code></pre> din <pre class='inline'><code class='language-cpp'>A</code></pre> (care e <pre class='inline'><code class='language-cpp'>const</code></pre> deci nu poate modifica starea obiectului, gen variabile sau sa apeleze functii neconst, dar oricum nu face asta) si se afiseaza <pre class='inline'><code class='language-cpp'>10</code></pre>.\n</div>\n<div>\n<var>p</var> este de tip <pre class='inline'><code class='language-cpp'>A*</code></pre> deja deci nu are sens vreun cast la <pre class='inline'><code class='language-cpp'>A*</code></pre>, deci <pre class='inline'><code class='language-cpp'>typeid((A*)p).name()</code></pre> e la fel ca <pre class='inline'><code class='language-cpp'>typeid(p).name();</code></pre>. <pre class='inline'><code class='language-cpp'>typeid</code></pre> returneaza un obiect de tip <pre class='inline'><code class='language-cpp'>type_info</code></pre> ce reprezinta informatii despre tipul de date, are si o metoda <pre class='inline'><code class='language-cpp'>name()</code></pre> care returneaza numele tipului de date dar depinde de compilator numele exact. Tipul lui <var>p</var> este <pre class='inline'><code class='language-cpp'>A*</code></pre> (ne intereseaza pointerul, nu obiectul la care arata) deci in numele returnat de <pre class='inline'><code class='language-cpp'>typeid(p).name()</code></pre> nu are de ce sa apara <pre class='inline'><code class='language-cpp'>&quot;B*&quot;</code></pre> deci nu se executa if-ul. (pe visual studio, typeid(p).name() intoarce <pre class='inline'><code class='language-cpp'>&quot;class A * __ptr64&quot;</code></pre>)\n</div></div>", "tags": ["medium", "incorrect", "typeinfo", "RTTI", "inheritance", "access modifiers"]}, {"id": 43, "problem": "#include <iostream>\nusing namespace std;\n\nclass Locuinta {\nprotected:\n    int camere;\npublic:\n    Locuinta(int c = 10) { camere = c; }\n    virtual Locuinta upgrade(Locuinta other) { \n  \t\treturn other.camere + 2; \n    }\n    void print() const { \n    \tcout << \"Locuinta are \" << camere << \" camere\"; \n    }\n};\n\nclass Casa : public Locuinta {\nprivate:\n    int etaje;\npublic:\n    Casa(int e = 0) : Locuinta(4) { etaje = e; }\n\n    Locuinta upgrade(Locuinta other) { \n    \treturn camere + other.camere * 2; \n\t}\n};\n\nint main()\n{\n    Locuinta* p1 = new Casa(5);\n    Locuinta* p2 = new Locuinta();\n    Locuinta* p3 = new Locuinta(p1->upgrade(*p2));\n    p3->print();\n    return 0;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, eroare de compilare la linia 24 <pre class='inline'><code class='language-cpp'>return camere + other.camere * 2;</code></pre>\n</div>\n<samp class='error'>protected member &quot;Locuinta::camere&quot; (declared at line 6) is not accessible through a &quot;Locuinta&quot; pointer or object</samp>\n<div>\nMembrii <pre class='inline'><code class='language-cpp'>protected</code></pre> dintr-o clasa de baza poti fi accesati intr-o clasa derivata doar de obiecte (sau pointeri) de tipul clasei derivate. \n</div>\n<pre class='block'><code>class Base {\nprotected:\n    int x;\n};\n\nclass Derived : public Base {\n    void f(Base ob) { cout &lt;&lt; ob.x; }         // eroare, accesezi x-ul prin ceva de tip Base\n    void f(Base* ob) { cout &lt;&lt; ob-&gt;x; }       // eroare\n    void f(const Base&amp; ob) { cout &lt;&lt; ob.x; }  // eroare\n\n    void f(Derived ob) { cout &lt;&lt; ob.x; }          // ok, ob e Derived si ai acces la x\n    void f(Derived* ob) { cout &lt;&lt; ob-&gt;x; }        // ok\n    void f(const Derived&amp; ob) { cout &lt;&lt; ob.x; }   // ok\n\n    void g() { x = 100; }  // ok, ai acces la x-ul pentru obiectul curent\n};</code></pre>\n<div>\nProblema e la <pre class='inline'><code class='language-cpp'>other.camere</code></pre>, <var>other</var> e de tip <pre class='inline'><code class='language-cpp'>Locuinta</code></pre> nu <pre class='inline'><code class='language-cpp'>Casa</code></pre>. Cum tu este in clasa <pre class='inline'><code class='language-cpp'>Casa</code></pre> si <var>other</var> nu e de tip <pre class='inline'><code class='language-cpp'>Casa</code></pre>, nu ai acces la <var>other.camere</var> (care e <pre class='inline'><code class='language-cpp'>protected</code></pre> in clasa <pre class='inline'><code class='language-cpp'>Locuinta</code></pre>).\nCa programul sa fie corect, poti modifica functia <pre class='inline'><code class='language-cpp'>Locuinta upgrade(Locuinta other)</code></pre> din clasa <pre class='inline'><code class='language-cpp'>Casa</code></pre> in <pre class='inline'><code class='language-cpp'>Locuinta upgrade(Casa other)</code></pre>, acum primeste un obiect de tip <pre class='inline'><code class='language-cpp'>Casa</code></pre> si poti accesa variabila <var>camere</var>.\n</div>\n<div>\nDupa modificari, <pre class='inline'><code class='language-cpp'>Locuinta* p1 = new Casa(5);</code></pre> se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>Casa</code></pre>, se apeleaza constructorii in ordinea <pre class='inline'><code class='language-cpp'>Locuinta</code></pre>, <pre class='inline'><code class='language-cpp'>Casa</code></pre>. In lista de initializare din constructorul din <pre class='inline'><code class='language-cpp'>Casa</code></pre> este apelat constructorul din <pre class='inline'><code class='language-cpp'>Locuinta</code></pre> cu valoarea 4, si dupa se continua cu constructorul din <pre class='inline'><code class='language-cpp'>Casa</code></pre> (etaje = 5). Dupa ce se creeaza se face upcast (pointerul <var>p1</var> de tip <pre class='inline'><code class='language-cpp'>Locuinta</code></pre> arata spre ceva de tip <pre class='inline'><code class='language-cpp'>Casa</code></pre>). \n</div>\n<div>\n<pre class='inline'><code class='language-cpp'>Locuinta* p2 = new Locuinta();</code></pre>, se creeaza un obiect de tip <pre class='inline'><code class='language-cpp'>Locuinta</code></pre>, nu este transmis vreun argument pentru constructor deci ramane cel default adica in obiectul la care arata <var>p2</var>, <var>camere</var> este 10.\n</div>\n<div>\nLa <pre class='inline'><code class='language-cpp'>p1-&gt;upgrade(*p2)</code></pre> se apeleaza metoda <pre class='inline'><code class='language-cpp'>upgrade</code></pre> din clasa <pre class='inline'><code class='language-cpp'>Locuinta</code></pre>, pentru ca <var>p1</var> este de tip <pre class='inline'><code class='language-cpp'>Locuinta</code></pre> si functia <pre class='inline'><code class='language-cpp'>upgrade</code></pre> din <pre class='inline'><code class='language-cpp'>Casa</code></pre> difera prin tipul parametrului, se ignora faptul ca metoda e <pre class='inline'><code class='language-cpp'>virtual</code></pre>. Obiectul la care arata <var>p2</var> (are <var>camere</var> egal cu 10 de mai sus) este transmis ca parametru in functia <pre class='inline'><code class='language-cpp'>upgrade</code></pre>. Se returneaza 10 + 2 adica <pre class='inline'><code class='language-cpp'>12</code></pre>. Deci <pre class='inline'><code class='language-cpp'>p3 = new Locuinta(12);</code></pre>.\n</div></div>", "tags": ["incorrect", "medium", "virtual", "pointers", "inheritance", "protected"]}]}