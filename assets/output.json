{"content": [{"id": 1, "problem": "#include <iostream>\n\nusing namespace std;\n\nclass Vector2D{\nprivate:\n    int x,y;\npublic:\n    Vector2D(int x, int y) : x(x), y(y) {}\n    void afis(){\n        cout << '(' << x << ',' << y << ')';\n    }\n};\n\nint main(){\n    Vector2D a(1,2), b(2,3), c;\n    a.afis();\n}", "solution": "<div><div>\nProgramul nu compileaza, avem eroare la linia 16: <pre class='inline'><code>Vector2D a(1,2), b(2,3), c;</code></pre>\n</div>\n<samp class='error'>error: no matching function for call to &#39;Vector2D::Vector2D()&#39;</samp>\n<div>\nPentru ca nu avem contructor cu parametri impliciti nu se poate crea o variabila de tip Vector2D fara sa specifici valorile parametrilor din constructor (e vorba despre variabila <var>c</var>)\n</div>\n<div>\nPentru ca programul sa mearga sunt mai multe variante: \n</div>\n<div>\n1) stergi variabila <var>c</var> de la linia 16 care devine <pre class='inline'><code>Vector2D a(1,2), b(2,3);</code></pre>\n</div>\n<div>\n2) adaugi valori implicite pentru contructor, adica linia 9 sa devina <pre class='inline'><code>Vector2D(int x = 0, int y = 0) : x(x), y(y) {}</code></pre>. Poti pune si alte valori in afara de 0, nu conteaza\n</div>\n<div>\n3) adaugi constructor fara parametri:\n<pre class='block'><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Vector2D{\nprivate:\n    int x,y;\npublic:\n\n    Vector2D() {} // constructor fara parametrii\n\n    Vector2D(int x, int y) : x(x), y(y) {}\n    void afis(){\n        cout &lt;&lt; &#39;(&#39; &lt;&lt; x &lt;&lt; &#39;,&#39; &lt;&lt; y &lt;&lt; &#39;)&#39;;\n    }\n};\n\nint main(){\n    Vector2D a(1,2), b(2,3), c;\n    a.afis();\n}</code></pre>\n</div></div>", "tags": ["easy", "incorrect", "constructor"]}, {"id": 2, "problem": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nclass Persoana{\n    \n    char nume[20];\n    int varsta;\n    float inaltime;\n\n    Persoana(){\n        strcpy(nume, \"Gigel\");\n        varsta = 20;\n        inaltime = 1.8;\n    }\n\n    Persoana(const char* n, int v, float i){\n        strcpy(nume, n);\n        varsta = v;\n        inaltime = i;\n    }\n\n    void afis(){\n        cout << nume << \" are \" << varsta << \" ani si are \" << inaltime << \"m.\";\n    }\n};\n\nint main(){\n    Persoana p1,p2(\"Maria\", 21, 1.76);\n    p2.afis();\n}", "solution": "<div><div>\nProgramul nu compileaza, avem eroare la linia 30: <pre class='inline'><code>Persoana p1,p2(&quot;Maria&quot;, 21, 1.76);</code></pre>\n</div>\n<samp class='error'>error: &#39;Persoana::Persoana()&#39; is private within this context</samp>\n<div>\nCare sunt modificatorii de acces in C++? Si care este modificatorul de acces implicit?\n</div>\n<div>\nPentru ca nu am specificat niciun modificator de acces, se aplica cel implicit adica private deci tot ce este in clasa este private. Deci si constructorii sunt private deci nu pot fi apelati din main.\n</div>\n<div>\nModificarea care face programul corect este sa adaugi modificatorul de acces public. Unde mai exact? Niciodata sa nu ai datele membre (in cazul asta <var>nume</var>, <var>varsta</var>, <var>inaltime</var>) publice. Deci pui <pre class='inline'><code>public:</code></pre> fix inainte de constructori.\n\n<pre class='block'><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nclass Persoana{\n    \n    char nume[20];\n    int varsta;\n    float inaltime;\n\npublic:\n\n    Persoana(){\n        strcpy(nume, &quot;Gigel&quot;);\n        varsta = 20;\n        inaltime = 1.8;\n    }\n\n    Persoana(const char* n, int v, float i){\n        strcpy(nume, n);\n        varsta = v;\n        inaltime = i;\n    }\n\n    void afis(){\n        cout &lt;&lt; nume &lt;&lt; &quot; are &quot; &lt;&lt; varsta &lt;&lt; &quot; ani si are &quot; &lt;&lt; inaltime &lt;&lt; &quot;m.&quot;;\n    }\n};\n\nint main(){\n    Persoana p1,p2(&quot;Maria&quot;, 21, 1.76);\n    p2.afis();\n}</code></pre>\n</div></div>", "tags": ["easy", "incorrect", "modificatori acces"]}, {"id": 3, "problem": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nclass Fruct{\nprotected:\n    char denumire[10];\n    int kg;\npublic:\n    Fruct(const char* nume=\"fara\", int kg=0){\n        strcpy(denumire, nume);\n        this->kg = kg;\n    }\n};\n\nclass Mar : public Fruct{\nprivate:\n    char culoare[10];\npublic:\n    Mar(const char* nume=\"\", int kg=0, const char* culoare=\"fara\") : Fruct::Fruct(nume, kg) {\n        strcpy(this->culoare, culoare);\n    }\n\n    void afis(){\n        cout << denumire << \" \" << kg << \" \" << culoare << '\\n';\n    }\n};\n\nint main(){\n    Mar m1(\"Red Delicious\", 23, \"Rosu\"), m2(\"Honeycrisp\", 2);\n    m1.afis();\n    m2.afis();\n}", "solution": "<div><div>\nProgramul compileaza. Se afiseaza\n</div>\n<samp class='output'>Red Delicious 23 Rosu\nHoneycrisp 2 fara</samp>\n<div>\nSe creaza 2 variabile de tip Mar, <var>m1</var> si <var>m2</var>. Pentru amandoua se apeleaza pe rand constructorul de la linia 21, care apeleaza la randul lui constructorul din clasa de baza Fruct. Asta trebuie sa se faca in initializer list, nu se poate in corpul constructorului!!!\n</div>\n<pre class='block'><code>Mar(const char* nume=&quot;&quot;, int kg=0, const char* culoare=&quot;fara&quot;){\n        Fruct::Fruct(nume, kg); // nu e corect, eroare\n        strcpy(this-&gt;culoare, culoare);\n    }</code></pre>\n<div>\nDe ce? C++ garanteaza ca clasa de baza se construieste inainte de clasa derivata. Cand esti in corpul constructorului din clasa Mar, s-a apelat deja constructorul din clasa Fruct (daca nu l-ai apelat tu se apeleaza automat) deci nu poti sa il mai apelezi iar.\n</div>\n<pre class='block'><code>Mar(const char* nume=&quot;&quot;, int kg=0, const char* culoare=&quot;fara&quot;){\n    strcpy(this-&gt;culoare, culoare);  \n}\n\n// este echivalent cu:\n\nMar(const char* nume=&quot;&quot;, int kg=0, const char* culoare=&quot;fara&quot;)\n    : Fruct::Fruct() // daca nu apelezi tu constructorul, se apeleaza automat constructorul implicit\n{\n    strcpy(this-&gt;culoare, culoare);  \n}</code></pre>\n<div>\nIn constructorul din clasa Fruct de exemplu, avem parametrul <var>kg</var> dar si data membra <var>kg</var>. Deci cum deosebim care e care? Punand <pre class='inline'><code>this-&gt;kg</code></pre> te referi la data membra, cand scrii doar <var>kg</var> te referi la parametrul constructorului. Daca parametrul din consrtuctor avea alt nume, de ex. <var>kilograme</var> atunci puteai scrie doar <var>kg</var> in loc de <pre class='inline'><code>this-&gt;kg</code></pre> pentru ca nu mai exista confuzii.\n</div>\n<div>\nIn constructori avem parametrii impliciti, care trebuie pusi dupa cei care nu sunt impliciti dar in exemplul asta nu avem. De exemplu cand se apeleaza constructorul pentru <var>m2</var> nu se specifica <var>culoare</var> deci va avea valoarea implicita <var>fara</var>.\n</div></div>", "tags": ["easy", "correct", "mostenire", "constructor", "initializer list"]}]}