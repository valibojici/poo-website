{"content": [{"id": 1, "problem": "#include <iostream> \nusing namespace std;\n\nvoid f(int x, int y) {\n\tcout << \"x=\" << x << \" \" << \"y=\" << y << endl;\n}\n\nvoid f(int x, double y) {\n\tcout << \"x+y=\" << x + y << endl;\n}\n\nint main()\n{\n\tf(1.5, 2);\n\tf(4, 2.4);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul funtioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>x=1 y=2\nx+y=6.4</samp>\n<div>\nFunctia f este supraincarcata. La linia 14: <pre class='inline'><code>f(1.5, 2);</code></pre> se apeleaza prima functie iar la linia 16: <pre class='inline'><code>f(4, 2.4)</code></pre> se apeleaza a doua. De ce? \n</div>\n<div>\nSa ne uitam la <pre class='inline'><code>f(1.5, 2);</code></pre>. Ambele functii, <pre class='inline'><code>void f(int x, int y)</code></pre> si <pre class='inline'><code>void f(int x, double y)</code></pre> au ca prim parametru o variabila de tip <pre class='inline'><code>int</code></pre> deci ambele functii convertesc 1.5 la 1 (de la <pre class='inline'><code>double</code></pre> la <pre class='inline'><code>int</code></pre>).\n</div>\n<div>\nAl doilea parametru din prima functie este de tip <pre class='inline'><code>int</code></pre> care se potriveste perfect cu ce avem. Al doilea parametru din a doua functie este de tip <pre class='inline'><code>double</code></pre> deci trebuie o conversie de la <pre class='inline'><code>int</code></pre> la <pre class='inline'><code>double</code></pre>, adica munca in plus. Deci prima functie este aleasa.\n</div>\n<div>\nSimilar se comporta linia 15: <pre class='inline'><code>f(4, 2.4);</code></pre>. Pentru mai multe detalii legat de cum se alege o functie daca este supraincarcata si are mai multe variante vezi ce am scris <a href='./tips.html#function-overloading'>aici</a>.\n</div></div>", "tags": ["easy", "correct", "function overloading", "implicit cast"]}, {"id": 2, "problem": "#include <iostream> \nusing namespace std;\n\nvoid f(double x, int y) {\n\tcout << \"x * y =\" << x + y << endl;\n}\n\nvoid f(int x, double y) {\n\tcout << \"x + y=\" << x + y << endl;\n}\n\nint main()\n{\n\tf(1, 2);\n\tf(1.5, 2);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect. Avem eroare de compilare la linia 14: <pre class='inline'><code>f(1, 2);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nDe ce avem eroare? In primul rand functia f este supraincarcata. Daca ne uitam la linia 14: <pre class='inline'><code>f(1, 2);</code></pre> ambele argumente sunt de tip <pre class='inline'><code>int</code></pre>. Acum sa ne uitam la functii: <pre class='inline'><code>void f(double x, int y)</code></pre> si <pre class='inline'><code>void f(int x, double y)</code></pre>. Prima functie trebuie sa converteasca primul argument (adica 1) din <pre class='inline'><code>int</code></pre> in <pre class='inline'><code>double</code></pre>, a doua functie nu trebuie sa faca nimic.\n</div>\n<div>\nAcum, prima functie nu trebuie sa mai faca nimic pentru al doilea argument (adica 2) pentru ca e deja <pre class='inline'><code>int</code></pre> in schimb a doua funtie trebuie sa convertesca din <pre class='inline'><code>double</code></pre> in <pre class='inline'><code>int</code></pre>.\n</div>\n<div>\nIn concluzie ambele functii trebuie sa faca o conversie obligatoriu, deci apelul functiei f este ambiguu, nu se stie care functie sa se apeleze. Ca programul sa fie corect sunt mai multe variante:\n</div>\n<div>\n1) schimbi linia 15 din <pre class='inline'><code>f(1, 2);</code></pre> in <pre class='inline'><code>f(1.0, 2);</code></pre> de exemplu (sa fie un double ca prim argument) sau in <pre class='inline'><code>f(1, 2.0);</code></pre>. Ai grija ca ceva de genul <pre class='inline'><code>f(1.3, 2.1);</code></pre> da aceeasi eroare.\n</div>\n<div>\n2) schimbi linia 4: <pre class='inline'><code>void f(double x, int y) {</code></pre> in <pre class='inline'><code>void f(int x, int y){</code></pre>\n</div>\n<div>\n3) schimbi linia 8: <pre class='inline'><code>void f(int x, double y) {</code></pre> in <pre class='inline'><code>void f(double x, double y) {</code></pre> sau <pre class='inline'><code>void f(int x, int y) {</code></pre>\n</div></div>", "tags": ["incorrect", "function overloading", "implicit cast", "easy"]}, {"id": 3, "problem": "#include <iostream> \nusing namespace std;\n\nint f(int x, int y) {\n\tcout << \"Salut din prima functie\" << endl;\n\treturn x + y;\n}\n\ndouble f(int y, int x) {\n\tcout << \"Salut din a doua functie\" << endl;\n\treturn 10.0;\n}\n\nint main()\n{\n\tf(2, 2);\n\tf(2.5, 3);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul nu funtioneaza corect. Avem eroare de compilare la linia 9: <pre class='inline'><code>double f(int y, int x) {</code></pre>\n</div>\n<samp class='error'>cannot overload functions distinguished by return type alone</samp>\n<div>\nPare ca functia f este supraincarcata dar nu este asa. Ca sa supraincarci o functie trebuie sa schimbi ori numarul de parametrii ori tipul parametrilor ori ordinea parametrilor (daca ai parametrii cu tipuri diferite) si cateva alte lucruri pe care la discut <a href='./tips.html#function-overloading'> aici</a>.\n</div>\n<div>\nDeci functiile <pre class='inline'><code>int f(int x, int y)</code></pre> si <pre class='inline'><code>double f(int y, int x)</code></pre> se deosebesc doar prin tipul returnat, care nu este destul pentru a le diferentia (am schimbat si <var>x</var> cu <var>y</var> in a doua functie dar asta nu are nicio treaba, sunt doar niste nume, tot doi parametrii de tip <pre class='inline'><code>int</code></pre> avem). De ce nu se deosebesc prin tipul returnat? Pentru ca exista situatii de genul urmator:\n</div>\n<div>\n<pre class='block'><code>#include &lt;iostream&gt; \nusing namespace std;\n\nint calculeazaPret(int pret, float TVA){\n\treturn pret + TVA * pret / 100;\n}\n\nfloat calculeazaPret(int pret, float TVA){\n\treturn pret + TVA * pret / 100;\n}\n\nint main()\n{\n\tdouble x = calculeazaPret(100, 4);\n\tcout &lt;&lt; x &lt;&lt; endl;\n}</code></pre>\n</div>\n<div>\nAici si <pre class='inline'><code>int</code></pre> si <pre class='inline'><code>float</code></pre> se poate converti la <pre class='inline'><code>double</code></pre> deci la linia <pre class='inline'><code>double x = calculeazaPret(100, 4);</code></pre> care functie se apeleaza? Ca sa se evite situatii de genul asta fara sens, tipul returnat nu e destul pentru a face diferenta.\n</div>\n<div>\nCa programul sa fie corect trebuie schimbata linia 9: <pre class='inline'><code>double f(int y, int x) {</code></pre> in ceva de genul <pre class='inline'><code>double f(double y, int x) {</code></pre> de exemplu.\n</div></div>", "tags": ["easy", "incorrect", "function overloading", "function signature"]}, {"id": 4, "problem": "#include <iostream> \nusing namespace std;\n\nvoid g(int x, int y, double z) {\n\tcout << \"x + y + z = \" << x + y + z << endl;\n\tz = x + y;\n}\n\nvoid g(int x, double y, int z) {\n\tcout << \"x + y - z = \" << x + y - z << endl;\n\tz = 5;\n}\n\nvoid g(double x, double y, int z) {\n\tx = y = 1.0;\n\tcout << \"x * y + z =\" << x * y + z << endl;\n}\n\nint main() {\n\tg(5, 6.5, 10);\n\tg(1, 2, 3);\n\tg(4, 5, 2.0);\n}", "solution": "<div><div>\nProgramul nu este corect. Avem eroare de compilare la linia 21: <pre class='inline'><code>g(1, 2, 3);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nAvem functia g care este supraincarcata si avem 3 &quot;variante&quot;: <pre class='inline'><code>void g(int x, int y, double z)</code></pre>, <pre class='inline'><code>void g(int x, double y, int z)</code></pre>, <pre class='inline'><code>void g(double x, double y, int z)</code></pre>. In main mai intai apelam functia g aici <pre class='inline'><code>g(5, 6.5, 10);</code></pre>. Se potriveste perfect cu a doua functie (<pre class='inline'><code>void g(int x, double y, int z)</code></pre>, are 3 argumente in ordinea asta: <pre class='inline'><code>int</code></pre>, <pre class='inline'><code>double</code></pre>, <pre class='inline'><code>int</code></pre>). Cand apelam functia g la sfarsit <pre class='inline'><code>g(4, 5, 2.0);</code></pre> si acum se potriveste perfect cu prima functie <pre class='inline'><code>void g(int x, int y, double z)</code></pre>.\n</div>\n<div>\nProblemele apar la <pre class='inline'><code>g(1, 2, 3);</code></pre>. Toate argumentele sunt de tip <pre class='inline'><code>int</code></pre>. Acum sa ne uitam la functii: avem prima si a doua care trebuie sa faca 1 conversie (de la <pre class='inline'><code>int</code></pre> la <pre class='inline'><code>double</code></pre>) si a treia care trebuie sa faca 2 conversii. A treia iese din discutie fiindca trebuie sa faca mai multa treaba. Dintre prima si a doua functie pe care o alegem? Asta e problema, ca nu stim, se potrivesc amandoua. Deci apelul functiei g la linia 21: <pre class='inline'><code>g(1, 2, 3);</code></pre> este ambiguu.\n</div></div>", "tags": ["easy", "incorrect", "function overloading", "implicit cast"]}, {"id": 5, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int x, int y) {\n\tcout << \"x = \" << x << \" si y = \" << y << endl;\n\tcout << \"Prima functie!\" << endl;\n\tint z = x + y;\n}\n\nvoid f(double x, int y) {\n\tdouble z = x + x;\n\tcout << \"Dublul lui x = \" << z << endl;\n\tcout << \"A doua functie!\" << endl;\n\tz = x - 20.0;\n}\n\nint main() {\n\tfloat x = 5;\n\tint y = 2;\n\tf(x, y);\n}", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>Dublul lui x = 10\nA doua functie!</samp>\n<div>\nPoate te-a luat prin surprindere ca este corect. Avem functia f care este supraincarcata <pre class='inline'><code>void f(int x, int y)</code></pre> si <pre class='inline'><code>void f(double x, int y)</code></pre>. In main apelam functia f cu un <pre class='inline'><code>float</code></pre> si cu un <pre class='inline'><code>int</code></pre>.\n</div>\n<div>\n<pre class='inline'><code>void f(int x, int y)</code></pre> trebuie sa converteasca <pre class='inline'><code>float</code></pre> la <pre class='inline'><code>int</code></pre> iar <pre class='inline'><code>void f(double x, int y)</code></pre> trebuie sa converteasca <pre class='inline'><code>float</code></pre> la <pre class='inline'><code>double</code></pre>. Ambele fac o singura conversie de ce nu este ambiguu apelul <pre class='inline'><code>f(x, y);</code></pre>?\n</div>\n<div>\nPentru ca aceste conversii si ele de mai multe feluri, unele mai importante decat celelalte si asta contribuie la ce functie se alege in cazul asta.\nConversia de la <pre class='inline'><code>float</code></pre> la <pre class='inline'><code>double</code></pre> are un nume special putin, se numeste &quot;<b>promotie</b>&quot; (floating-point promotion). Conversia de la <pre class='inline'><code>int</code></pre> la <pre class='inline'><code>double</code></pre> se numeste tot &quot;<b>conversie</b>&quot; (floating-point conversion). \n</div>\n<div>\nPromotia se refera ca poti reprezenta si pastra exact informatia din tipul care se converteste in tipul convertit fara sa pierzi informatia. (de ex din <pre class='inline'><code>float</code></pre> in <pre class='inline'><code>double</code></pre> sau din <pre class='inline'><code>short</code></pre> in <pre class='inline'><code>int</code></pre>). Cand faci o conversie s-ar putea sa pierzi infomatia sau sa se modifice(de ex din <pre class='inline'><code>int</code></pre> in <pre class='inline'><code>float</code></pre>, pentru ca exista numere intregi care nu se reprezinta exact cu un <pre class='inline'><code>float</code></pre> ). Ai grija ca conversia din <pre class='inline'><code>int</code></pre> in <pre class='inline'><code>long</code></pre> sau <pre class='inline'><code>long long</code></pre> (dar si altele) <b>NU</b> sunt promotii, sunt conversii. Pentru mai multe detalii citeste <a href='./tips.html#function-overloading'>aici</a>.\n</div>\n<div>\nIn cazul asta se face o conversie in cazul primei functii si o promotie in cazul celei de a doua functii, si cum promotia este mai puternica nu mai exista ambiguitate si prin <pre class='inline'><code>f(x,y);</code></pre> apelezi a doua functie. \n</div></div>", "tags": ["correct", "easy", "function overloading", "implicit cast"]}, {"id": 6, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint *n, *nr, *s;\n\n\tcout << \"Cate numere sunt?\" << endl;\n\tn = new int;\n\tcin >> *n;\t// 5\n\n\tnr = new int[*n];\n\n\tcout << \"Introdu numerele\" << endl;\n\tfor (int i = 0; i < *n; ++i) {\n\t\tcin >> nr[i]; // 1 2 3 4 5\n\t}\n\n\ts = new int(0);\n\tfor (int i = 0; i < *n; ++i) {\n\t\t*s += nr[i];\n\t}\n\n\tcout << \"Suma este: \" << *s << endl;\n\n\tdelete n;\n\tdelete s;\n\tdelete nr;\n}", "solution": "<div><div>\nDaca se citeste de la tastatura <pre class='inline'><code>1</code></pre> si dupa <pre class='inline'><code>1 2 3 4 5</code></pre> se afiseaza:\n</div>\n<samp class='output'>Cate numere sunt?\n5\nIntrodu numerele\n1 2 3 4 5\nSuma este: 15</samp>\n<div>\nProbabil va functiona corect daca incerci, dar la linia 27: <pre class='inline'><code>delete nr;</code></pre> nu e corect. Cand aloci dinamic memorie cu <pre class='inline'><code>new</code></pre>, eliberezi memoria cu <pre class='inline'><code>delete</code></pre> iar cand aloci memorie cu <pre class='inline'><code>new[]</code></pre> eliberezi cu <pre class='inline'><code>delete[]</code></pre>. In cazul asta <pre class='inline'><code>nr</code></pre> e un array alocat dinamic si trebuie eliberata memoria cu <pre class='inline'><code>delete[]</code></pre> nu cu <pre class='inline'><code>delete</code></pre>. Daca folosesti <pre class='inline'><code>delete</code></pre> pentru un array ce se intampla e <i>undefined behaviour</i>, adica depinde de compilator ce se intampla, poate nimic, poate ceva grav care nu va genera eroare dar va face programul sa nu functioneze corect mai tarziu. Deci corect ar fi sa inlocuiesti <pre class='inline'><code>delete nr;</code></pre> cu <pre class='inline'><code>delete[] nr;</code></pre>\n</div>\n<div>\n<pre class='inline'><code>s = new int(0);</code></pre> inseamna ca aloci dinamic un <pre class='inline'><code>int</code></pre> si ii dai valoarea 0. Poti pune si alte numere. \n</div>\n<div>\nCand aloci dinamic un array de ex. <pre class='inline'><code>int *s = new int[10];</code></pre> si vrei ca elementele sa fie 0 poti scrie direct <pre class='inline'><code>int *s = new int[10]()</code></pre>, nu pune nimic intre paranteze.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "dynamic memory allocation"]}]}