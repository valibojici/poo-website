{"content": [{"id": 1, "problem": "#include <iostream> \nusing namespace std;\n\nvoid f(int x, int y) {\n\tcout << \"x=\" << x << \" \" << \"y=\" << y << endl;\n}\n\nvoid f(int x, double y) {\n\tcout << \"x+y=\" << x + y << endl;\n}\n\nint main()\n{\n\tf(1.5, 2);\n\tf(4, 2.4);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul funtioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>x=1 y=2\nx+y=6.4</samp>\n<div>\nFunctia f este supraincarcata. La linia 14: <pre class='inline'><code>f(1.5, 2);</code></pre> se apeleaza prima functie iar la linia 16: <pre class='inline'><code>f(4, 2.4)</code></pre> se apeleaza a doua. De ce? \n</div>\n<div>\nSa ne uitam la <pre class='inline'><code>f(1.5, 2);</code></pre>. Ambele functii, <pre class='inline'><code>void f(int x, int y)</code></pre> si <pre class='inline'><code>void f(int x, double y)</code></pre> au ca prim parametru o variabila de tip <pre class='inline'><code>int</code></pre> deci ambele functii convertesc 1.5 la 1 (de la <pre class='inline'><code>double</code></pre> la <pre class='inline'><code>int</code></pre>).\n</div>\n<div>\nAl doilea parametru din prima functie este de tip <pre class='inline'><code>int</code></pre> care se potriveste perfect cu ce avem. Al doilea parametru din a doua functie este de tip <pre class='inline'><code>double</code></pre> deci trebuie o conversie de la <pre class='inline'><code>int</code></pre> la <pre class='inline'><code>double</code></pre>, adica munca in plus. Deci prima functie este aleasa.\n</div>\n<div>\nSimilar se comporta linia 15: <pre class='inline'><code>f(4, 2.4);</code></pre>. Pentru mai multe detalii legat de cum se alege o functie daca este supraincarcata si are mai multe variante vezi ce am scris <a href='./tips.html#function-overloading'>aici</a>.\n</div></div>", "tags": ["easy", "correct", "function overloading", "implicit cast"]}, {"id": 2, "problem": "#include <iostream> \nusing namespace std;\n\nvoid f(double x, int y) {\n\tcout << \"x * y =\" << x + y << endl;\n}\n\nvoid f(int x, double y) {\n\tcout << \"x + y =\" << x + y << endl;\n}\n\nint main()\n{\n\tf(1, 2);\n\tf(1.5, 2);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect. Avem eroare de compilare la linia 14: <pre class='inline'><code>f(1, 2);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nDe ce avem eroare? In primul rand functia f este supraincarcata. Daca ne uitam la linia 14: <pre class='inline'><code>f(1, 2);</code></pre> ambele argumente sunt de tip <pre class='inline'><code>int</code></pre>. Acum sa ne uitam la functii: <pre class='inline'><code>void f(double x, int y)</code></pre> si <pre class='inline'><code>void f(int x, double y)</code></pre>. Prima functie trebuie sa converteasca primul argument (adica 1) din <pre class='inline'><code>int</code></pre> in <pre class='inline'><code>double</code></pre>, a doua functie nu trebuie sa faca nimic.\n</div>\n<div>\nAcum, prima functie nu trebuie sa mai faca nimic pentru al doilea argument (adica 2) pentru ca e deja <pre class='inline'><code>int</code></pre> in schimb a doua funtie trebuie sa convertesca din <pre class='inline'><code>double</code></pre> in <pre class='inline'><code>int</code></pre>.\n</div>\n<div>\nIn concluzie ambele functii trebuie sa faca o conversie obligatoriu, deci apelul functiei f este ambiguu, nu se stie care functie sa se apeleze. Ca programul sa fie corect sunt mai multe variante:\n</div>\n<div>\n1) schimbi linia 15 din <pre class='inline'><code>f(1, 2);</code></pre> in <pre class='inline'><code>f(1.0, 2);</code></pre> de exemplu (sa fie un double ca prim argument) sau in <pre class='inline'><code>f(1, 2.0);</code></pre>. Ai grija ca ceva de genul <pre class='inline'><code>f(1.3, 2.1);</code></pre> da aceeasi eroare.\n</div>\n<div>\n2) schimbi linia 4: <pre class='inline'><code>void f(double x, int y) {</code></pre> in <pre class='inline'><code>void f(int x, int y){</code></pre>\n</div>\n<div>\n3) schimbi linia 8: <pre class='inline'><code>void f(int x, double y) {</code></pre> in <pre class='inline'><code>void f(double x, double y) {</code></pre> sau <pre class='inline'><code>void f(int x, int y) {</code></pre>\n</div></div>", "tags": ["incorrect", "function overloading", "implicit cast", "easy"]}, {"id": 3, "problem": "#include <iostream> \nusing namespace std;\n\nint f(int x, int y) {\n\tcout << \"Salut din prima functie\" << endl;\n\treturn x + y;\n}\n\ndouble f(int y, int x) {\n\tcout << \"Salut din a doua functie\" << endl;\n\treturn 10.0;\n}\n\nint main()\n{\n\tf(2, 2);\n\tf(2.5, 3);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul nu funtioneaza corect. Avem eroare de compilare la linia 9: <pre class='inline'><code>double f(int y, int x) {</code></pre>\n</div>\n<samp class='error'>cannot overload functions distinguished by return type alone</samp>\n<div>\nPare ca functia f este supraincarcata dar nu este asa. Ca sa supraincarci o functie trebuie sa schimbi ori numarul de parametrii ori tipul parametrilor ori ordinea parametrilor (daca ai parametrii cu tipuri diferite) si cateva alte lucruri pe care la discut <a href='./tips.html#function-overloading'> aici</a>.\n</div>\n<div>\nDeci functiile <pre class='inline'><code>int f(int x, int y)</code></pre> si <pre class='inline'><code>double f(int y, int x)</code></pre> se deosebesc doar prin tipul returnat, care nu este destul pentru a le diferentia (am schimbat si <var>x</var> cu <var>y</var> in a doua functie dar asta nu are nicio treaba, sunt doar niste nume, tot doi parametrii de tip <pre class='inline'><code>int</code></pre> avem). De ce nu se deosebesc prin tipul returnat? Pentru ca exista situatii de genul urmator:\n</div>\n<div>\n<pre class='block'><code>#include &lt;iostream&gt; \nusing namespace std;\n\nint calculeazaPret(int pret, float TVA){\n\treturn pret + TVA * pret / 100;\n}\n\nfloat calculeazaPret(int pret, float TVA){\n\treturn pret + TVA * pret / 100;\n}\n\nint main()\n{\n\tdouble x = calculeazaPret(100, 4);\n\tcout &lt;&lt; x &lt;&lt; endl;\n}</code></pre>\n</div>\n<div>\nAici si <pre class='inline'><code>int</code></pre> si <pre class='inline'><code>float</code></pre> se poate converti la <pre class='inline'><code>double</code></pre> deci la linia <pre class='inline'><code>double x = calculeazaPret(100, 4);</code></pre> care functie se apeleaza? Ca sa se evite situatii de genul asta fara sens, tipul returnat nu e destul pentru a face diferenta.\n</div>\n<div>\nCa programul sa fie corect trebuie schimbata linia 9: <pre class='inline'><code>double f(int y, int x) {</code></pre> in ceva de genul <pre class='inline'><code>double f(double y, int x) {</code></pre> de exemplu.\n</div></div>", "tags": ["easy", "incorrect", "function overloading", "function signature"]}, {"id": 4, "problem": "#include <iostream> \nusing namespace std;\n\nvoid g(int x, int y, double z) {\n\tcout << \"x + y + z = \" << x + y + z << endl;\n\tz = x + y;\n}\n\nvoid g(int x, double y, int z) {\n\tcout << \"x + y - z = \" << x + y - z << endl;\n\tz = 5;\n}\n\nvoid g(double x, double y, int z) {\n\tx = y = 1.0;\n\tcout << \"x * y + z =\" << x * y + z << endl;\n}\n\nint main() {\n\tg(5, 6.5, 10);\n\tg(1, 2, 3);\n\tg(4, 5, 2.0);\n}", "solution": "<div><div>\nProgramul nu este corect. Avem eroare de compilare la linia 21: <pre class='inline'><code>g(1, 2, 3);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nAvem functia g care este supraincarcata si avem 3 &quot;variante&quot;: <pre class='inline'><code>void g(int x, int y, double z)</code></pre>, <pre class='inline'><code>void g(int x, double y, int z)</code></pre>, <pre class='inline'><code>void g(double x, double y, int z)</code></pre>. In main mai intai apelam functia g aici <pre class='inline'><code>g(5, 6.5, 10);</code></pre>. Se potriveste perfect cu a doua functie (<pre class='inline'><code>void g(int x, double y, int z)</code></pre>, are 3 argumente in ordinea asta: <pre class='inline'><code>int</code></pre>, <pre class='inline'><code>double</code></pre>, <pre class='inline'><code>int</code></pre>). Cand apelam functia g la sfarsit <pre class='inline'><code>g(4, 5, 2.0);</code></pre> si acum se potriveste perfect cu prima functie <pre class='inline'><code>void g(int x, int y, double z)</code></pre>.\n</div>\n<div>\nProblemele apar la <pre class='inline'><code>g(1, 2, 3);</code></pre>. Toate argumentele sunt de tip <pre class='inline'><code>int</code></pre>. Acum sa ne uitam la functii: avem prima si a doua care trebuie sa faca 1 conversie (de la <pre class='inline'><code>int</code></pre> la <pre class='inline'><code>double</code></pre>) si a treia care trebuie sa faca 2 conversii. A treia iese din discutie fiindca trebuie sa faca mai multa treaba. Dintre prima si a doua functie pe care o alegem? Asta e problema, ca nu stim, se potrivesc amandoua. Deci apelul functiei g la linia 21: <pre class='inline'><code>g(1, 2, 3);</code></pre> este ambiguu.\n</div></div>", "tags": ["easy", "incorrect", "function overloading", "implicit cast"]}, {"id": 5, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int x, int y) {\n\tcout << \"x = \" << x << \" si y = \" << y << endl;\n\tcout << \"Prima functie!\" << endl;\n\tint z = x + y;\n}\n\nvoid f(double x, int y) {\n\tdouble z = x + x;\n\tcout << \"Dublul lui x = \" << z << endl;\n\tcout << \"A doua functie!\" << endl;\n\tz = x - 20.0;\n}\n\nint main() {\n\tfloat x = 5;\n\tint y = 2;\n\tf(x, y);\n}", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>Dublul lui x = 10\nA doua functie!</samp>\n<div>\nPoate te-a luat prin surprindere ca este corect. Avem functia f care este supraincarcata <pre class='inline'><code>void f(int x, int y)</code></pre> si <pre class='inline'><code>void f(double x, int y)</code></pre>. In main apelam functia f cu un <pre class='inline'><code>float</code></pre> si cu un <pre class='inline'><code>int</code></pre>.\n</div>\n<div>\n<pre class='inline'><code>void f(int x, int y)</code></pre> trebuie sa converteasca <pre class='inline'><code>float</code></pre> la <pre class='inline'><code>int</code></pre> iar <pre class='inline'><code>void f(double x, int y)</code></pre> trebuie sa converteasca <pre class='inline'><code>float</code></pre> la <pre class='inline'><code>double</code></pre>. Ambele fac o singura conversie de ce nu este ambiguu apelul <pre class='inline'><code>f(x, y);</code></pre>?\n</div>\n<div>\nPentru ca aceste conversii si ele de mai multe feluri, unele mai importante decat celelalte si asta contribuie la ce functie se alege in cazul asta.\nConversia de la <pre class='inline'><code>float</code></pre> la <pre class='inline'><code>double</code></pre> are un nume special putin, se numeste &quot;<b>promotie</b>&quot; (floating-point promotion). Conversia de la <pre class='inline'><code>int</code></pre> la <pre class='inline'><code>double</code></pre> se numeste tot &quot;<b>conversie</b>&quot; (floating-point conversion). \n</div>\n<div>\nPromotia se refera ca poti reprezenta si pastra exact informatia din tipul care se converteste in tipul convertit fara sa pierzi informatia. (de ex din <pre class='inline'><code>float</code></pre> in <pre class='inline'><code>double</code></pre> sau din <pre class='inline'><code>short</code></pre> in <pre class='inline'><code>int</code></pre>). Cand faci o conversie s-ar putea sa pierzi infomatia sau sa se modifice(de ex din <pre class='inline'><code>int</code></pre> in <pre class='inline'><code>float</code></pre>, pentru ca exista numere intregi care nu se reprezinta exact cu un <pre class='inline'><code>float</code></pre> ). Ai grija ca conversia din <pre class='inline'><code>int</code></pre> in <pre class='inline'><code>long</code></pre> sau <pre class='inline'><code>long long</code></pre> (dar si altele) <b>NU</b> sunt promotii, sunt conversii. Pentru mai multe detalii citeste <a href='./tips.html#function-overloading'>aici</a>.\n</div>\n<div>\nIn cazul asta se face o conversie in cazul primei functii si o promotie in cazul celei de a doua functii, si cum promotia este mai puternica nu mai exista ambiguitate si prin <pre class='inline'><code>f(x,y);</code></pre> apelezi a doua functie. \n</div></div>", "tags": ["correct", "easy", "function overloading", "implicit cast"]}, {"id": 6, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint *n, *nr, *s;\n\n\tcout << \"Cate numere sunt?\" << endl;\n\tn = new int;\n\tcin >> *n;\t// 5\n\n\tnr = new int[*n];\n\n\tcout << \"Introdu numerele\" << endl;\n\tfor (int i = 0; i < *n; ++i) {\n\t\tcin >> nr[i]; // 1 2 3 4 5\n\t}\n\n\ts = new int(0);\n\tfor (int i = 0; i < *n; ++i) {\n\t\t*s += nr[i];\n\t}\n\n\tcout << \"Suma este: \" << *s << endl;\n\n\tdelete n;\n\tdelete s;\n\tdelete nr;\n}", "solution": "<div><div>\nDaca se citeste de la tastatura <pre class='inline'><code>1</code></pre> si dupa <pre class='inline'><code>1 2 3 4 5</code></pre> se afiseaza:\n</div>\n<samp class='output'>Cate numere sunt?\n5\nIntrodu numerele\n1 2 3 4 5\nSuma este: 15</samp>\n<div>\nProbabil va functiona corect daca incerci, dar la linia 27: <pre class='inline'><code>delete nr;</code></pre> nu e corect. Cand aloci dinamic memorie cu <pre class='inline'><code>new</code></pre>, eliberezi memoria cu <pre class='inline'><code>delete</code></pre> iar cand aloci memorie cu <pre class='inline'><code>new[]</code></pre> eliberezi cu <pre class='inline'><code>delete[]</code></pre>. In cazul asta <pre class='inline'><code>nr</code></pre> e un array alocat dinamic si trebuie eliberata memoria cu <pre class='inline'><code>delete[]</code></pre> nu cu <pre class='inline'><code>delete</code></pre>. Daca folosesti <pre class='inline'><code>delete</code></pre> pentru un array ce se intampla e <i>undefined behaviour</i>, adica depinde de compilator ce se intampla, poate nimic, poate ceva grav care nu va genera eroare dar va face programul sa nu functioneze corect mai tarziu. Deci corect ar fi sa inlocuiesti <pre class='inline'><code>delete nr;</code></pre> cu <pre class='inline'><code>delete[] nr;</code></pre>\n</div>\n<div>\n<pre class='inline'><code>s = new int(0);</code></pre> inseamna ca aloci dinamic un <pre class='inline'><code>int</code></pre> si ii dai valoarea 0. Poti pune si alte numere. \n</div>\n<div>\nCand aloci dinamic un array de ex. <pre class='inline'><code>int *s = new int[10];</code></pre> si vrei ca elementele sa fie 0 poti scrie direct <pre class='inline'><code>int *s = new int[10]()</code></pre>, nu pune nimic intre paranteze.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "dynamic memory allocation"]}, {"id": 7, "problem": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tchar* s = new char[20];\n\tstrcpy(s, \"Hello world!\");\n\n\tcout << s << endl;\n\n\tdelete[] s;\n\n\ts = new char[4];\n\ts[0] = 'a';\n\ts[1] = 'b';\n\ts[2] = 'c';\n\ts[3] = 0;\n\n\tcout << s << endl;\n\n\tdelete[] s;\n}", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>Hello world!\nabc</samp>\n<div>\nSe aloca dinamic spatiu in memorie pentru un sir de caractere de lungime 20 (practic 19 pentru ca ultimul trebuie sa fie caracterul special <pre class='inline'><code>&#39;\\0&#39;</code></pre> ca sa marcheze sfarsitul). Se copiaza <pre class='inline'><code>&quot;Hello world!&quot;</code></pre> in <var>s</var> si se afiseaza dupa care se sterge si se aloca iar spatiu pentru 4 caractere de data asta. Se pun <pre class='inline'><code>&#39;a&#39;</code></pre>, <pre class='inline'><code>&#39;b&#39;</code></pre>, <pre class='inline'><code>&#39;c&#39;</code></pre> pe primele 3 pozitii iar pe ultima se pune caracterul special <pre class='inline'><code>&#39;\\0&#39;</code></pre> sau <pre class='inline'><code>0</code></pre> (sau <pre class='inline'><code>NULL</code></pre>). La final se elibereaza memoria cu <pre class='inline'><code>delete[]</code></pre>.\n</div>\n<div>\nDaca nu pui <pre class='inline'><code>&#39;\\0&#39;</code></pre> sau <pre class='inline'><code>0</code></pre> la sfarsit se pot afisa caractere in plus la finalul cuvantului pentru ca se afiseaza caracter cu caracter pana la <pre class='inline'><code>0</code></pre> pus de tine sau gasit undeva in memorie random.\n</div>\n<pre class='block'><code>s = new char[3];\ns[0] = &#39;a&#39;;\ns[1] = &#39;b&#39;;\ns[2] = &#39;c&#39;;\n\ncout &lt;&lt; s &lt;&lt; endl;</code></pre>\n<div>\nSe afiseaza (pe calculatorul meu):\n</div>\n<samp class='output'>Hello world!\nabc$|PPP</samp></div>", "tags": ["easy", "correct", "pointers", "dynamic memory allocation"]}, {"id": 8, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint a = 5;\n\tint b = 2;\n\tint& x = a;\n\n\tx += b;\n\ta = b;\n\tb += x;\n\n\tcout << a << ' ' << b << ' ' << x << endl;\n}", "solution": "<div><div>\nProgramul este corect, se afiseaza:\n</div>\n<samp class='output'>2 4 2</samp>\n<div>\nSe creeaza variabila <var>a</var> avand valoarea 5 si variabila <var>b</var> avand valoarea 2 si o referinta la variabila <var>a</var>. In cazul asta referinta este un alias pentru variabila <var>a</var> deci <pre class='inline'><code>x += b;</code></pre> este practic <pre class='inline'><code>a += b;</code></pre>. Deci acum <var>a</var> = 7. Dupa <var>a</var> ia valorea lui <var>b</var> adica 2 si dupa <pre class='inline'><code>b += x;</code></pre> inseamna <pre class='inline'><code>b += a;</code></pre>. Deci in final <var>a</var> = 2, <var>b</var> = 4.\n</div>\n<div>\nTrebuie sa initializezi o referinta cand o creezi si nu poti schimba la cine se refera referinta dupa ce faci asta.\n</div>\n<pre class='block'><code>int a = 5;\nint&amp; b;\t\t// eroare\nb = a;\n\nint c = 10;\nint &amp;t = c;\nt = a;\t\t// inseamna &#39;c = a;&#39;</code></pre></div>", "tags": ["correct", "references", "easy"]}, {"id": 9, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint x = 1, y = 2, z = 3;\n\tint &a = x, &b = y, &c = z;\n\n\tint& arr[] = { a, b ,c };\n\n\tarr[0] = 100;\n\n\tcout << arr[0] << endl;\n\tcout << x << \" \" << y << \" \" << z << endl;\n}", "solution": "<div><div>\nProgramul nu e corect, avem eroare la linia 8:<pre class='inline'><code>int&amp; arr[] = { a, b ,c };</code></pre>\n</div>\n<samp class='error'>array of reference is not allowed</samp>\n<div>\nCum spune si eroarea nu putem creea array-uri (de fapt orice container) de referinte. Trebuie schimbata linia 8:<pre class='inline'><code>int&amp; arr[] = { a, b ,c };</code></pre> in <pre class='inline'><code>int arr[] = { a, b ,c };</code></pre>.\n</div>\n<div>\nMai intai se creeaza 3 variabile si dupa 3 referinte pentru cele 3 variabile. Dupa se creeaza un array de <pre class='inline'><code>int</code></pre> iar valorile din el sunt de fapt valorile variabilelor <var>x</var>, <var>y</var>, <var>z</var> pentru ca referintele sunt ca un alias pentru variabilele <var>x</var>, <var>y</var>, <var>z</var> deci <pre class='inline'><code>arr[0] = 100;</code></pre> nu modifica valoarea lui <var>x</var>.\n</div>\n<div>\nDe ce nu putem avea array de referinte? Cand creezi un array, de ex <pre class='inline'><code>int v[3] = {1, 2, 3};</code></pre>, <pre class='inline'><code>v</code></pre> este un pointer la primul element. Cand accesezi elementul <pre class='inline'><code>v[2]</code></pre> de fapt este <pre class='inline'><code>*(v + 2)</code></pre>. Acum daca ai avea <pre class='inline'><code>int&amp; v[3] = {a, b, c};</code></pre> v este un pointer la primul element, adica <var>a</var>, dar a e referinta si adresa lui a este adresa varibilei la care se refera (pentru care e un alias) care este altundeva in memorie deci nu ai cum sa te referi la restul elementelor.\n</div>\n<div>\nDe asemenea nu poti avea pointeri la referinte si referinte la referinte.\n</div></div>", "tags": ["incorrect", "easy", "references"]}, {"id": 10, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint x = 123, y = 456;\n\tint& rx = x;\n\trx = 50;\n\t\n\tint* p = &rx;\n\tint*& rp = p;\n\n\t*rp = 100;\n\tp = &y;\n\t*rp = 200;\n\n\tcout << x << ' ' << y << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>100 200</samp>\n<div>\nAvem doua variabile <var>x</var> si <var>y</var> si o referinta la <var>x</var>. <pre class='inline'><code>rx = 50;</code></pre> este de fapt <pre class='inline'><code>x = 50;</code></pre> pentru ca referinta este ca un alias pentru variabila <var>x</var>. Dupa avem un pointer care arata spre adresa de memorie lui <var>rx</var> care este de fapt adresa de memorie lui <var>x</var> pentru ca referintele nu ocupa memorie. Dupa la linia 10: <pre class='inline'><code>int*&amp; rp = p;</code></pre> se creeaza o referinta la pointerul <var>p</var>. Deci acum <var>rp</var> este practic <var>p</var>. <pre class='inline'><code>*rp = 100;</code></pre> este ca si cum ai scrie <pre class='inline'><code>*p = 100;</code></pre>. Adica dereferentiezi pointerul <var>p</var> ca sa ai acces la zona din memorie la care arata, adica la variabila <var>x</var> a carui valorea este modificata in 100.\n</div>\n<div>\nApoi <var>p</var> arata acum spre zona din memorie unde este <var>y</var>. <var>rp</var> continua sa fie o referinta la <var>p</var> deci <pre class='inline'><code>*rp = 200;</code></pre> este practic <pre class='inline'><code>*p = 200;</code></pre> adica prin <var>p</var> accesezi variabila <var>y</var> a carui valoare o schimbi in 200.\n</div></div>", "tags": ["easy", "pointers", "references", "correct"]}, {"id": 11, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int*& x, int& y) {\n\ty = *x;\n\tx = &y;\n}\n\nint main()\n{\n\tint a = 10;\n\tint b = 20;\n\tint* p = &a;\n\tf(p, b);\n\n\t*p = 0;\n\n\tcout << a << \" \" << b << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>10 0</samp>\n<div>\nSe creeaza 2 variabile <var>a</var> si <var>b</var> si un pointer care arata spre zona de memorie unde este <var>a</var>. Se apeleaza functia f unde parametrii sunt de tip referinta (referinta la un pointer de tip <pre class='inline'><code>int</code></pre> si referinta la un <pre class='inline'><code>int</code></pre>). Deci in interiorul functiei <var>x</var> este <var>p</var> iar <var>y</var> este <var>b</var>. <var>y</var> ia valoarea variabilei de la adresa la care arata pointerul <var>x</var> adica <var>b</var> ia valorea lui <var>a</var> si dupa <var>x</var> arata spre adresa lui <var>y</var>, deci <var>p</var> arata spre adresa lui <var>b</var>. Prin <pre class='inline'><code>*p</code></pre> accesezi zona din memorie la care arata pointerul si in cazul asta setezi valorea lui <var>b</var> la 0.\n</div></div>", "tags": ["correct", "easy", "pointers", "references"]}, {"id": 12, "problem": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N = 99, M = 2;\n\tint v[] = { 10, 20, N, M };\n\n\tint(*p1)[4] = &v;\n\tint* p2 = v;\n\n\tp1++;\n\tp2++;\n\tcout << (*p1)[1] << \" \" << p2[1];\n}", "solution": "<div><div>\nProgramul nu functioneaza corect. Nu avem eroare de compilare dar posibil eroare la runtime pentru ca accesam memorie unde nu trebuie.\n</div>\n<div>\nDeci avem un array <pre class='inline'><code>v[] = {10, 20, 99, 2};</code></pre> (am pus direct valorile lui <var>N</var> si <var>M</var>). La linia 9: <pre class='inline'><code>int(*p1)[4] = &amp;v;</code></pre> se creeaza un pointer cu numele <var>p1</var> de tip <pre class='inline'><code>int(*)[4]</code></pre> care arata spre un array cu 4 elemente, in cazul asta <var>v</var>. Deci <var>p1</var> arata spre intreg array-ul <var>v</var>. \n</div>\n<div>\nCand scrii <pre class='inline'><code>int* p2 = v;</code></pre> este ca si cum ai scrie <pre class='inline'><code>int* p2 = &amp;v[0];</code></pre>. (se produce un &quot;decay&quot;, array-ul se transforma intr-un pointer la primul element, <var>v</var> nu este de tip <pre class='inline'><code>int*</code></pre> ci <pre class='inline'><code>int[4]</code></pre> dar totusi poti scrie <pre class='inline'><code>int* p2 = v;</code></pre>). Deci <var>p2</var> este un pointer la primul element.\n</div>\n<div>\nDeci <var>p2</var> este un pointer de tip <pre class='inline'><code>int*</code></pre> la primul element din array-ul <var>v</var>, iar <var>p1</var> este un pointer de tip <pre class='inline'><code>int(*)[4]</code></pre> la intreg array-ul v. Deocamdata ambii pointeri arata spre aceeasi zona de memorie (inceputul array-ului) dar sunt de tipuri <b>diferite</b>.\n</div>\n<div>\nAcum urmeaza partea care nu e corecta. Operatiile aritmetice cu pointeri se folosesc de tipul lor. Un <pre class='inline'><code>int</code></pre> are 4 bytes si <var>p2</var> arata spre un <pre class='inline'><code>int</code></pre> deci <pre class='inline'><code>p2++;</code></pre> inseamna ca adresa la care arata p2 se mareste cu 4 bytes adica trece la urmatorul numar din array-ul <var>v</var> adica <pre class='inline'><code>20</code></pre>. Insa <var>p1</var> arata spre un <pre class='inline'><code>int[4]</code></pre> si <pre class='inline'><code>p1++;</code></pre> mareste adresa lui p1 cu 4*4=16 bytes (dimensiunea lui <pre class='inline'><code>int[4]</code></pre>) deci ajunge <b>dupa</b> zona de memorie rezervata pentru array-ul <var>v</var>. Cand scrii <pre class='inline'><code>(*p1)[1]</code></pre> si dereferentiezi <var>p1</var> obtii ceva de tip <pre class='inline'><code>int[4]</code></pre> adica un array, dar array-ul asta e dupa zona de memorie a lui <var>v</var> daca incerci sa accesezi primul element obtii o valoare random din memorie sau intri peste memorie deja alocata si ai eroare. Este corect sa scrii <pre class='inline'><code>p2[1]</code></pre> pentru ca inseamna de fapt <pre class='inline'><code>*(p2 + 1)</code></pre> adica urmatorul nr din array-ul <var>v</var> dupa <pre class='inline'><code>20</code></pre> adica 99.\n</div>\n<div>\nDeci ca sa fie corect stergi linia 12: <pre class='inline'><code>p1++;</code></pre>. Sau ai putea inlocui linia 15: cu <pre class='inline'><code>cout &lt;&lt; (*(p1-1))[1] &lt;&lt; &quot; &quot; &lt;&lt; p2[1];</code></pre>. <pre class='inline'><code>p1-1</code></pre> inseamna practic ca te intorci la adresa la care se afla <var>v</var>. Ca sa ai acces la array trebuie sa deferentiezi pointerul adica <pre class='inline'><code>*(p1-1)</code></pre> si pentru ca <pre class='inline'><code>[]</code></pre> are precedenta mai mare mai trebuie niste paranteze <pre class='inline'><code>(*(p1-1))[1]</code></pre> si asta inseamana practic <pre class='inline'><code>v[1]</code></pre>.\n</div></div>", "tags": ["incorrect", "easy", "pointers", "array"]}]}