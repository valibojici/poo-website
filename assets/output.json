{"content": [{"id": 1, "problem": "#include <iostream> \nusing namespace std;\n\nvoid f(int x, int y) {\n\tcout << \"x=\" << x << \" \" << \"y=\" << y << endl;\n}\n\nvoid f(int x, double y) {\n\tcout << \"x+y=\" << x + y << endl;\n}\n\nint main()\n{\n\tf(1.5, 2);\n\tf(4, 2.4);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul funtioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>x=1 y=2\nx+y=6.4</samp>\n<div>\nFunctia f este supraincarcata. La linia 14: <pre class='inline'><code>f(1.5, 2);</code></pre> se apeleaza prima functie iar la linia 16: <pre class='inline'><code>f(4, 2.4)</code></pre> se apeleaza a doua. De ce? \n</div>\n<div>\nSa ne uitam la <pre class='inline'><code>f(1.5, 2);</code></pre>. Ambele functii, <pre class='inline'><code>void f(int x, int y)</code></pre> si <pre class='inline'><code>void f(int x, double y)</code></pre> au ca prim parametru o variabila de tip <pre class='inline'><code>int</code></pre> deci ambele functii convertesc 1.5 la 1 (de la <pre class='inline'><code>double</code></pre> la <pre class='inline'><code>int</code></pre>).\n</div>\n<div>\nAl doilea parametru din prima functie este de tip <pre class='inline'><code>int</code></pre> care se potriveste perfect cu ce avem. Al doilea parametru din a doua functie este de tip <pre class='inline'><code>double</code></pre> deci trebuie o conversie de la <pre class='inline'><code>int</code></pre> la <pre class='inline'><code>double</code></pre>, adica munca in plus. Deci prima functie este aleasa.\n</div>\n<div>\nSimilar se comporta linia 15: <pre class='inline'><code>f(4, 2.4);</code></pre>. Pentru mai multe detalii legat de cum se alege o functie daca este supraincarcata si are mai multe variante vezi ce am scris <a href='./tips.html#function-overloading'>aici</a>.\n</div></div>", "tags": ["easy", "correct", "function overloading", "implicit cast"]}, {"id": 2, "problem": "#include <iostream> \nusing namespace std;\n\nvoid f(double x, int y) {\n\tcout << \"x * y =\" << x + y << endl;\n}\n\nvoid f(int x, double y) {\n\tcout << \"x + y =\" << x + y << endl;\n}\n\nint main()\n{\n\tf(1, 2);\n\tf(1.5, 2);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect. Avem eroare de compilare la linia 14: <pre class='inline'><code>f(1, 2);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nDe ce avem eroare? In primul rand functia f este supraincarcata. Daca ne uitam la linia 14: <pre class='inline'><code>f(1, 2);</code></pre> ambele argumente sunt de tip <pre class='inline'><code>int</code></pre>. Acum sa ne uitam la functii: <pre class='inline'><code>void f(double x, int y)</code></pre> si <pre class='inline'><code>void f(int x, double y)</code></pre>. Prima functie trebuie sa converteasca primul argument (adica 1) din <pre class='inline'><code>int</code></pre> in <pre class='inline'><code>double</code></pre>, a doua functie nu trebuie sa faca nimic.\n</div>\n<div>\nAcum, prima functie nu trebuie sa mai faca nimic pentru al doilea argument (adica 2) pentru ca e deja <pre class='inline'><code>int</code></pre> in schimb a doua funtie trebuie sa convertesca din <pre class='inline'><code>double</code></pre> in <pre class='inline'><code>int</code></pre>.\n</div>\n<div>\nIn concluzie ambele functii trebuie sa faca o conversie obligatoriu, deci apelul functiei f este ambiguu, nu se stie care functie sa se apeleze. Ca programul sa fie corect sunt mai multe variante:\n</div>\n<div>\n1) schimbi linia 15 din <pre class='inline'><code>f(1, 2);</code></pre> in <pre class='inline'><code>f(1.0, 2);</code></pre> de exemplu (sa fie un double ca prim argument) sau in <pre class='inline'><code>f(1, 2.0);</code></pre>. Ai grija ca ceva de genul <pre class='inline'><code>f(1.3, 2.1);</code></pre> da aceeasi eroare.\n</div>\n<div>\n2) schimbi linia 4: <pre class='inline'><code>void f(double x, int y) {</code></pre> in <pre class='inline'><code>void f(int x, int y){</code></pre>\n</div>\n<div>\n3) schimbi linia 8: <pre class='inline'><code>void f(int x, double y) {</code></pre> in <pre class='inline'><code>void f(double x, double y) {</code></pre> sau <pre class='inline'><code>void f(int x, int y) {</code></pre>\n</div></div>", "tags": ["incorrect", "function overloading", "implicit cast", "easy"]}, {"id": 3, "problem": "#include <iostream> \nusing namespace std;\n\nint f(int x, int y) {\n\tcout << \"Salut din prima functie\" << endl;\n\treturn x + y;\n}\n\ndouble f(int y, int x) {\n\tcout << \"Salut din a doua functie\" << endl;\n\treturn 10.0;\n}\n\nint main()\n{\n\tf(2, 2);\n\tf(2.5, 3);\n\treturn 0;\n}", "solution": "<div><div>\nProgramul nu funtioneaza corect. Avem eroare de compilare la linia 9: <pre class='inline'><code>double f(int y, int x) {</code></pre>\n</div>\n<samp class='error'>cannot overload functions distinguished by return type alone</samp>\n<div>\nPare ca functia f este supraincarcata dar nu este asa. Ca sa supraincarci o functie trebuie sa schimbi ori numarul de parametrii ori tipul parametrilor ori ordinea parametrilor (daca ai parametrii cu tipuri diferite) si cateva alte lucruri pe care la discut <a href='./tips.html#function-overloading'> aici</a>.\n</div>\n<div>\nDeci functiile <pre class='inline'><code>int f(int x, int y)</code></pre> si <pre class='inline'><code>double f(int y, int x)</code></pre> se deosebesc doar prin tipul returnat, care nu este destul pentru a le diferentia (am schimbat si <var>x</var> cu <var>y</var> in a doua functie dar asta nu are nicio treaba, sunt doar niste nume, tot doi parametrii de tip <pre class='inline'><code>int</code></pre> avem). De ce nu se deosebesc prin tipul returnat? Pentru ca exista situatii de genul urmator:\n</div>\n<div>\n<pre class='block'><code>#include &lt;iostream&gt; \nusing namespace std;\n\nint calculeazaPret(int pret, float TVA){\n\treturn pret + TVA * pret / 100;\n}\n\nfloat calculeazaPret(int pret, float TVA){\n\treturn pret + TVA * pret / 100;\n}\n\nint main()\n{\n\tdouble x = calculeazaPret(100, 4);\n\tcout &lt;&lt; x &lt;&lt; endl;\n}</code></pre>\n</div>\n<div>\nAici si <pre class='inline'><code>int</code></pre> si <pre class='inline'><code>float</code></pre> se poate converti la <pre class='inline'><code>double</code></pre> deci la linia <pre class='inline'><code>double x = calculeazaPret(100, 4);</code></pre> care functie se apeleaza? Ca sa se evite situatii de genul asta fara sens, tipul returnat nu e destul pentru a face diferenta.\n</div>\n<div>\nCa programul sa fie corect trebuie schimbata linia 9: <pre class='inline'><code>double f(int y, int x) {</code></pre> in ceva de genul <pre class='inline'><code>double f(double y, int x) {</code></pre> de exemplu.\n</div></div>", "tags": ["easy", "incorrect", "function overloading", "function signature"]}, {"id": 4, "problem": "#include <iostream> \nusing namespace std;\n\nvoid g(int x, int y, double z) {\n\tcout << \"x + y + z = \" << x + y + z << endl;\n\tz = x + y;\n}\n\nvoid g(int x, double y, int z) {\n\tcout << \"x + y - z = \" << x + y - z << endl;\n\tz = 5;\n}\n\nvoid g(double x, double y, int z) {\n\tx = y = 1.0;\n\tcout << \"x * y + z =\" << x * y + z << endl;\n}\n\nint main() {\n\tg(5, 6.5, 10);\n\tg(1, 2, 3);\n\tg(4, 5, 2.0);\n}", "solution": "<div><div>\nProgramul nu este corect. Avem eroare de compilare la linia 21: <pre class='inline'><code>g(1, 2, 3);</code></pre>\n</div>\n<samp class='error'>more than one instance of overloaded function &quot;f&quot; matches the argument list</samp>\n<div>\nAvem functia g care este supraincarcata si avem 3 &quot;variante&quot;: <pre class='inline'><code>void g(int x, int y, double z)</code></pre>, <pre class='inline'><code>void g(int x, double y, int z)</code></pre>, <pre class='inline'><code>void g(double x, double y, int z)</code></pre>. In main mai intai apelam functia g aici <pre class='inline'><code>g(5, 6.5, 10);</code></pre>. Se potriveste perfect cu a doua functie (<pre class='inline'><code>void g(int x, double y, int z)</code></pre>, are 3 argumente in ordinea asta: <pre class='inline'><code>int</code></pre>, <pre class='inline'><code>double</code></pre>, <pre class='inline'><code>int</code></pre>). Cand apelam functia g la sfarsit <pre class='inline'><code>g(4, 5, 2.0);</code></pre> si acum se potriveste perfect cu prima functie <pre class='inline'><code>void g(int x, int y, double z)</code></pre>.\n</div>\n<div>\nProblemele apar la <pre class='inline'><code>g(1, 2, 3);</code></pre>. Toate argumentele sunt de tip <pre class='inline'><code>int</code></pre>. Acum sa ne uitam la functii: avem prima si a doua care trebuie sa faca 1 conversie (de la <pre class='inline'><code>int</code></pre> la <pre class='inline'><code>double</code></pre>) si a treia care trebuie sa faca 2 conversii. A treia iese din discutie fiindca trebuie sa faca mai multa treaba. Dintre prima si a doua functie pe care o alegem? Asta e problema, ca nu stim, se potrivesc amandoua. Deci apelul functiei g la linia 21: <pre class='inline'><code>g(1, 2, 3);</code></pre> este ambiguu.\n</div></div>", "tags": ["easy", "incorrect", "function overloading", "implicit cast"]}, {"id": 5, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int x, int y) {\n\tcout << \"x = \" << x << \" si y = \" << y << endl;\n\tcout << \"Prima functie!\" << endl;\n\tint z = x + y;\n}\n\nvoid f(double x, int y) {\n\tdouble z = x + x;\n\tcout << \"Dublul lui x = \" << z << endl;\n\tcout << \"A doua functie!\" << endl;\n\tz = x - 20.0;\n}\n\nint main() {\n\tfloat x = 5;\n\tint y = 2;\n\tf(x, y);\n}", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>Dublul lui x = 10\nA doua functie!</samp>\n<div>\nPoate te-a luat prin surprindere ca este corect. Avem functia f care este supraincarcata <pre class='inline'><code>void f(int x, int y)</code></pre> si <pre class='inline'><code>void f(double x, int y)</code></pre>. In main apelam functia f cu un <pre class='inline'><code>float</code></pre> si cu un <pre class='inline'><code>int</code></pre>.\n</div>\n<div>\n<pre class='inline'><code>void f(int x, int y)</code></pre> trebuie sa converteasca <pre class='inline'><code>float</code></pre> la <pre class='inline'><code>int</code></pre> iar <pre class='inline'><code>void f(double x, int y)</code></pre> trebuie sa converteasca <pre class='inline'><code>float</code></pre> la <pre class='inline'><code>double</code></pre>. Ambele fac o singura conversie de ce nu este ambiguu apelul <pre class='inline'><code>f(x, y);</code></pre>?\n</div>\n<div>\nPentru ca aceste conversii si ele de mai multe feluri, unele mai importante decat celelalte si asta contribuie la ce functie se alege in cazul asta.\nConversia de la <pre class='inline'><code>float</code></pre> la <pre class='inline'><code>double</code></pre> are un nume special putin, se numeste &quot;<b>promotie</b>&quot; (floating-point promotion). Conversia de la <pre class='inline'><code>int</code></pre> la <pre class='inline'><code>double</code></pre> se numeste tot &quot;<b>conversie</b>&quot; (floating-point conversion). \n</div>\n<div>\nPromotia se refera ca poti reprezenta si pastra exact informatia din tipul care se converteste in tipul convertit fara sa pierzi informatia. (de ex din <pre class='inline'><code>float</code></pre> in <pre class='inline'><code>double</code></pre> sau din <pre class='inline'><code>short</code></pre> in <pre class='inline'><code>int</code></pre>). Cand faci o conversie s-ar putea sa pierzi infomatia sau sa se modifice(de ex din <pre class='inline'><code>int</code></pre> in <pre class='inline'><code>float</code></pre>, pentru ca exista numere intregi care nu se reprezinta exact cu un <pre class='inline'><code>float</code></pre> ). Ai grija ca conversia din <pre class='inline'><code>int</code></pre> in <pre class='inline'><code>long</code></pre> sau <pre class='inline'><code>long long</code></pre> (dar si altele) <b>NU</b> sunt promotii, sunt conversii. Pentru mai multe detalii citeste <a href='./tips.html#function-overloading'>aici</a>.\n</div>\n<div>\nIn cazul asta se face o conversie in cazul primei functii si o promotie in cazul celei de a doua functii, si cum promotia este mai puternica nu mai exista ambiguitate si prin <pre class='inline'><code>f(x,y);</code></pre> apelezi a doua functie. \n</div></div>", "tags": ["correct", "easy", "function overloading", "implicit cast"]}, {"id": 6, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint *n, *nr, *s;\n\n\tcout << \"Cate numere sunt?\" << endl;\n\tn = new int;\n\tcin >> *n;\t// 5\n\n\tnr = new int[*n];\n\n\tcout << \"Introdu numerele\" << endl;\n\tfor (int i = 0; i < *n; ++i) {\n\t\tcin >> nr[i]; // 1 2 3 4 5\n\t}\n\n\ts = new int(0);\n\tfor (int i = 0; i < *n; ++i) {\n\t\t*s += nr[i];\n\t}\n\n\tcout << \"Suma este: \" << *s << endl;\n\n\tdelete n;\n\tdelete s;\n\tdelete nr;\n}", "solution": "<div><div>\nDaca se citeste de la tastatura <pre class='inline'><code>1</code></pre> si dupa <pre class='inline'><code>1 2 3 4 5</code></pre> se afiseaza:\n</div>\n<samp class='output'>Cate numere sunt?\n5\nIntrodu numerele\n1 2 3 4 5\nSuma este: 15</samp>\n<div>\nProbabil va functiona corect daca incerci, dar la linia 27: <pre class='inline'><code>delete nr;</code></pre> nu e corect. Cand aloci dinamic memorie cu <pre class='inline'><code>new</code></pre>, eliberezi memoria cu <pre class='inline'><code>delete</code></pre> iar cand aloci memorie cu <pre class='inline'><code>new[]</code></pre> eliberezi cu <pre class='inline'><code>delete[]</code></pre>. In cazul asta <pre class='inline'><code>nr</code></pre> e un array alocat dinamic si trebuie eliberata memoria cu <pre class='inline'><code>delete[]</code></pre> nu cu <pre class='inline'><code>delete</code></pre>. Daca folosesti <pre class='inline'><code>delete</code></pre> pentru un array ce se intampla e <i>undefined behaviour</i>, adica depinde de compilator ce se intampla, poate nimic, poate ceva grav care nu va genera eroare dar va face programul sa nu functioneze corect mai tarziu. Deci corect ar fi sa inlocuiesti <pre class='inline'><code>delete nr;</code></pre> cu <pre class='inline'><code>delete[] nr;</code></pre>\n</div>\n<div>\n<pre class='inline'><code>s = new int(0);</code></pre> inseamna ca aloci dinamic un <pre class='inline'><code>int</code></pre> si ii dai valoarea 0. Poti pune si alte numere. \n</div>\n<div>\nCand aloci dinamic un array de ex. <pre class='inline'><code>int *s = new int[10];</code></pre> si vrei ca elementele sa fie 0 poti scrie direct <pre class='inline'><code>int *s = new int[10]()</code></pre>, nu pune nimic intre paranteze.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "dynamic memory allocation"]}, {"id": 7, "problem": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tchar* s = new char[20];\n\tstrcpy(s, \"Hello world!\");\n\n\tcout << s << endl;\n\n\tdelete[] s;\n\n\ts = new char[4];\n\ts[0] = 'a';\n\ts[1] = 'b';\n\ts[2] = 'c';\n\ts[3] = 0;\n\n\tcout << s << endl;\n\n\tdelete[] s;\n}", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>Hello world!\nabc</samp>\n<div>\nSe aloca dinamic spatiu in memorie pentru un sir de caractere de lungime 20 (practic 19 pentru ca ultimul trebuie sa fie caracterul special <pre class='inline'><code>&#39;\\0&#39;</code></pre> ca sa marcheze sfarsitul). Se copiaza <pre class='inline'><code>&quot;Hello world!&quot;</code></pre> in <var>s</var> si se afiseaza dupa care se sterge si se aloca iar spatiu pentru 4 caractere de data asta. Se pun <pre class='inline'><code>&#39;a&#39;</code></pre>, <pre class='inline'><code>&#39;b&#39;</code></pre>, <pre class='inline'><code>&#39;c&#39;</code></pre> pe primele 3 pozitii iar pe ultima se pune caracterul special <pre class='inline'><code>&#39;\\0&#39;</code></pre> sau <pre class='inline'><code>0</code></pre> (sau <pre class='inline'><code>NULL</code></pre>). La final se elibereaza memoria cu <pre class='inline'><code>delete[]</code></pre>.\n</div>\n<div>\nDaca nu pui <pre class='inline'><code>&#39;\\0&#39;</code></pre> sau <pre class='inline'><code>0</code></pre> la sfarsit se pot afisa caractere in plus la finalul cuvantului pentru ca se afiseaza caracter cu caracter pana la <pre class='inline'><code>0</code></pre> pus de tine sau gasit undeva in memorie random.\n</div>\n<pre class='block'><code>s = new char[3];\ns[0] = &#39;a&#39;;\ns[1] = &#39;b&#39;;\ns[2] = &#39;c&#39;;\n\ncout &lt;&lt; s &lt;&lt; endl;</code></pre>\n<div>\nSe afiseaza (pe calculatorul meu):\n</div>\n<samp class='output'>Hello world!\nabc$|PPP</samp></div>", "tags": ["easy", "correct", "pointers", "dynamic memory allocation"]}, {"id": 8, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint a = 5;\n\tint b = 2;\n\tint& x = a;\n\n\tx += b;\n\ta = b;\n\tb += x;\n\n\tcout << a << ' ' << b << ' ' << x << endl;\n}", "solution": "<div><div>\nProgramul este corect, se afiseaza:\n</div>\n<samp class='output'>2 4 2</samp>\n<div>\nSe creeaza variabila <var>a</var> avand valoarea 5 si variabila <var>b</var> avand valoarea 2 si o referinta la variabila <var>a</var>. In cazul asta referinta este un alias pentru variabila <var>a</var> deci <pre class='inline'><code>x += b;</code></pre> este practic <pre class='inline'><code>a += b;</code></pre>. Deci acum <var>a</var> = 7. Dupa <var>a</var> ia valorea lui <var>b</var> adica 2 si dupa <pre class='inline'><code>b += x;</code></pre> inseamna <pre class='inline'><code>b += a;</code></pre>. Deci in final <var>a</var> = 2, <var>b</var> = 4.\n</div>\n<div>\nTrebuie sa initializezi o referinta cand o creezi si nu poti schimba la cine se refera referinta dupa ce faci asta.\n</div>\n<pre class='block'><code>int a = 5;\nint&amp; b;\t\t// eroare\nb = a;\n\nint c = 10;\nint &amp;t = c;\nt = a;\t\t// inseamna &#39;c = a;&#39;</code></pre></div>", "tags": ["correct", "references", "easy"]}, {"id": 9, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint x = 1, y = 2, z = 3;\n\tint &a = x, &b = y, &c = z;\n\n\tint& arr[] = { a, b ,c };\n\n\tarr[0] = 100;\n\n\tcout << arr[0] << endl;\n\tcout << x << \" \" << y << \" \" << z << endl;\n}", "solution": "<div><div>\nProgramul nu e corect, avem eroare la linia 8:<pre class='inline'><code>int&amp; arr[] = { a, b ,c };</code></pre>\n</div>\n<samp class='error'>array of reference is not allowed</samp>\n<div>\nCum spune si eroarea nu putem creea array-uri (de fapt orice container) de referinte. Trebuie schimbata linia 8:<pre class='inline'><code>int&amp; arr[] = { a, b ,c };</code></pre> in <pre class='inline'><code>int arr[] = { a, b ,c };</code></pre>.\n</div>\n<div>\nMai intai se creeaza 3 variabile si dupa 3 referinte pentru cele 3 variabile. Dupa se creeaza un array de <pre class='inline'><code>int</code></pre> iar valorile din el sunt de fapt valorile variabilelor <var>x</var>, <var>y</var>, <var>z</var> pentru ca referintele sunt ca un alias pentru variabilele <var>x</var>, <var>y</var>, <var>z</var> deci <pre class='inline'><code>arr[0] = 100;</code></pre> nu modifica valoarea lui <var>x</var>.\n</div>\n<div>\nDe ce nu putem avea array de referinte? Cand creezi un array, de ex <pre class='inline'><code>int v[3] = {1, 2, 3};</code></pre>, <pre class='inline'><code>v</code></pre> este un pointer la primul element, iar elementele sunt unele langa altele in memorie. Cand accesezi elementul <pre class='inline'><code>v[2]</code></pre> de fapt este <pre class='inline'><code>*(v + 2)</code></pre>(de la primul element te duci 2 pozitii in fata). Acum daca ai avea <pre class='inline'><code>int&amp; v[3] = {a, b, c};</code></pre> v este un pointer la primul element, adica <var>a</var>, dar <var>a</var> e referinta si adresa lui <var>a</var> este adresa varibilei la care se refera (pentru care e un alias) care este altundeva in memorie deci nu ai cum sa te referi la restul elementelor.\n</div>\n<div>\nDe asemenea nu poti avea pointeri la referinte si referinte la referinte.\n</div></div>", "tags": ["incorrect", "easy", "references"]}, {"id": 10, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint x = 123, y = 456;\n\tint& rx = x;\n\trx = 50;\n\t\n\tint* p = &rx;\n\tint*& rp = p;\n\n\t*rp = 100;\n\tp = &y;\n\t*rp = 200;\n\n\tcout << x << ' ' << y << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect. Se afiseaza:\n</div>\n<samp class='output'>100 200</samp>\n<div>\nAvem doua variabile <var>x</var> si <var>y</var> si o referinta la <var>x</var>. <pre class='inline'><code>rx = 50;</code></pre> este de fapt <pre class='inline'><code>x = 50;</code></pre> pentru ca referinta este ca un alias pentru variabila <var>x</var>. Dupa avem un pointer care arata spre adresa de memorie lui <var>rx</var> care este de fapt adresa de memorie lui <var>x</var> pentru ca referintele nu ocupa memorie. Dupa la linia 10: <pre class='inline'><code>int*&amp; rp = p;</code></pre> se creeaza o referinta la pointerul <var>p</var>. Deci acum <var>rp</var> este practic <var>p</var>. <pre class='inline'><code>*rp = 100;</code></pre> este ca si cum ai scrie <pre class='inline'><code>*p = 100;</code></pre>. Adica dereferentiezi pointerul <var>p</var> ca sa ai acces la zona din memorie la care arata, adica la variabila <var>x</var> a carui valorea este modificata in 100.\n</div>\n<div>\nApoi <var>p</var> arata acum spre zona din memorie unde este <var>y</var>. <var>rp</var> continua sa fie o referinta la <var>p</var> deci <pre class='inline'><code>*rp = 200;</code></pre> este practic <pre class='inline'><code>*p = 200;</code></pre> adica prin <var>p</var> accesezi variabila <var>y</var> a carui valoare o schimbi in 200.\n</div></div>", "tags": ["easy", "pointers", "references", "correct"]}, {"id": 11, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int*& x, int& y) {\n\ty = *x;\n\tx = &y;\n}\n\nint main()\n{\n\tint a = 10;\n\tint b = 20;\n\tint* p = &a;\n\tf(p, b);\n\n\t*p = 0;\n\n\tcout << a << \" \" << b << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>10 0</samp>\n<div>\nSe creeaza 2 variabile <var>a</var> si <var>b</var> si un pointer care arata spre zona de memorie unde este <var>a</var>. Se apeleaza functia f unde parametrii sunt de tip referinta (referinta la un pointer de tip <pre class='inline'><code>int</code></pre> si referinta la un <pre class='inline'><code>int</code></pre>). Deci in interiorul functiei <var>x</var> este <var>p</var> iar <var>y</var> este <var>b</var>. <var>y</var> ia valoarea variabilei de la adresa la care arata pointerul <var>x</var> adica <var>b</var> ia valorea lui <var>a</var> si dupa <var>x</var> arata spre adresa lui <var>y</var>, deci <var>p</var> arata spre adresa lui <var>b</var>. Prin <pre class='inline'><code>*p</code></pre> accesezi zona din memorie la care arata pointerul si in cazul asta setezi valorea lui <var>b</var> la 0.\n</div></div>", "tags": ["correct", "easy", "pointers", "references"]}, {"id": 12, "problem": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N = 99, M = 2;\n\tint v[] = { 10, 20, N, M };\n\n\tint(*p1)[4] = &v;\n\tint* p2 = v;\n\n\tp1++;\n\tp2++;\n\tcout << (*p1)[1] << \" \" << p2[1];\n}", "solution": "<div><div>\nProgramul nu functioneaza corect. Nu avem eroare de compilare dar posibil eroare la runtime pentru ca accesam memorie unde nu trebuie.\n</div>\n<div>\nDeci avem un array <pre class='inline'><code>v[] = {10, 20, 99, 2};</code></pre> (am pus direct valorile lui <var>N</var> si <var>M</var>). La linia 9: <pre class='inline'><code>int(*p1)[4] = &amp;v;</code></pre> se creeaza un pointer cu numele <var>p1</var> de tip <pre class='inline'><code>int(*)[4]</code></pre> care arata spre un array cu 4 elemente, in cazul asta <var>v</var>. Deci <var>p1</var> arata spre intreg array-ul <var>v</var>. \n</div>\n<div>\nCand scrii <pre class='inline'><code>int* p2 = v;</code></pre> este ca si cum ai scrie <pre class='inline'><code>int* p2 = &amp;v[0];</code></pre>. (se produce un &quot;decay&quot;, array-ul se transforma intr-un pointer la primul element, <var>v</var> nu este de tip <pre class='inline'><code>int*</code></pre> ci <pre class='inline'><code>int[4]</code></pre> dar totusi poti scrie <pre class='inline'><code>int* p2 = v;</code></pre>). Deci <var>p2</var> este un pointer la primul element.\n</div>\n<div>\nDeci <var>p2</var> este un pointer de tip <pre class='inline'><code>int*</code></pre> la primul element din array-ul <var>v</var>, iar <var>p1</var> este un pointer de tip <pre class='inline'><code>int(*)[4]</code></pre> la intreg array-ul v. Deocamdata ambii pointeri arata spre aceeasi zona de memorie (inceputul array-ului) dar sunt de tipuri <b>diferite</b>.\n</div>\n<div>\nAcum urmeaza partea care nu e corecta. Operatiile aritmetice cu pointeri se folosesc de tipul lor. Un <pre class='inline'><code>int</code></pre> are 4 bytes si <var>p2</var> arata spre un <pre class='inline'><code>int</code></pre> deci <pre class='inline'><code>p2++;</code></pre> inseamna ca adresa la care arata p2 se mareste cu 4 bytes adica trece la urmatorul numar din array-ul <var>v</var> adica <pre class='inline'><code>20</code></pre>. Insa <var>p1</var> arata spre un <pre class='inline'><code>int[4]</code></pre> si <pre class='inline'><code>p1++;</code></pre> mareste adresa lui p1 cu 4*4=16 bytes (dimensiunea lui <pre class='inline'><code>int[4]</code></pre>) deci ajunge <b>dupa</b> zona de memorie rezervata pentru array-ul <var>v</var>. Cand scrii <pre class='inline'><code>(*p1)[1]</code></pre> si dereferentiezi <var>p1</var> obtii ceva de tip <pre class='inline'><code>int[4]</code></pre> adica un array, dar array-ul asta e dupa zona de memorie a lui <var>v</var> daca incerci sa accesezi primul element obtii o valoare random din memorie sau intri peste memorie deja alocata si ai eroare. Este corect sa scrii <pre class='inline'><code>p2[1]</code></pre> pentru ca inseamna de fapt <pre class='inline'><code>*(p2 + 1)</code></pre> adica urmatorul nr din array-ul <var>v</var> dupa <pre class='inline'><code>20</code></pre> adica 99.\n</div>\n<img class='img-fluid' src='./imgs/p12.png' alt='...'>\n<div>\nDeci ca sa fie corect stergi linia 12: <pre class='inline'><code>p1++;</code></pre>. Sau ai putea inlocui linia 15: cu <pre class='inline'><code>cout &lt;&lt; (*(p1-1))[1] &lt;&lt; &quot; &quot; &lt;&lt; p2[1];</code></pre>. <pre class='inline'><code>p1-1</code></pre> inseamna practic ca te intorci la adresa la care se afla <var>v</var>. Ca sa ai acces la array trebuie sa deferentiezi pointerul adica <pre class='inline'><code>*(p1-1)</code></pre> si pentru ca <pre class='inline'><code>[]</code></pre> are precedenta mai mare mai trebuie niste paranteze <pre class='inline'><code>(*(p1-1))[1]</code></pre> si asta inseamana practic <pre class='inline'><code>v[1]</code></pre>.\n</div></div>", "tags": ["incorrect", "easy", "pointers", "array"]}, {"id": 13, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint x = 5;\n\tconst int y = 10;\n\n\tconst int* p = &y;\n\tint const* p2 = &x;\n\n\t*p2 = *p;\n\n\tcout << x << \" \" << y << endl;\n}", "solution": "<div><div>\nProgramul nu este corect, avem eroare la linia 11: <pre class='inline'><code>*p2 = *p;</code></pre>\n</div>\n<samp class='error'>expression must be a modifiable lvalue</samp>\n<div>\nAvem <var>x</var> care are valoarea 5 si <var>y</var> care are valoarea 10 (<var>y</var> este <pre class='inline'><code>const int</code></pre> si deci nu mai poti schimba valoarea lui <var>y</var>, poti elimina partea de const cu un cast dar ce rost mai are). <pre class='inline'><code>const int*</code></pre> este identic cu <pre class='inline'><code>int const*</code></pre> deci\n</div>\n<pre class='block'><code>const int* p = &amp;y;\nint const* p2 = &amp;x;</code></pre>\n<div>\ne identic cu\n</div>\n<pre class='block'><code>const int* p = &amp;y;\nconst int* p2 = &amp;x;</code></pre>\n<div>\n<pre class='inline'><code>const int* p = &amp;y;</code></pre> inseamna un pointer la un <pre class='inline'><code>const int</code></pre> adica NU ai voie sa modifici valorea de la adresa la care arata pointerul dar in schimb poti modifica la ce adresa arata pointerul (gen <pre class='inline'><code>p = &amp;x;</code></pre> e corect dar <pre class='inline'><code>*p = 5;</code></pre> nu e corect pentru ca modific valoarea de la adresa la care arata pointerul).\n</div>\n<div>\nProblema e la <pre class='inline'><code>*p2 = *p;</code></pre> ca <var>p2</var> e pointer la <pre class='inline'><code>const int</code></pre> si incerci sa modifici valoarea de la adresa la care arata pointerul. Ca sa mearga programul trebuie schimbata linia 9: <pre class='inline'><code>int const* p2 = &amp;x;</code></pre> in <pre class='inline'><code>int* p2 = &amp;x;</code></pre> si acum <var>p2</var> e pointer la <pre class='inline'><code>int</code></pre> si poti sa modifici valoarea de la adresa la care arata pointerul, deci <var>x</var> ia valoarea lui <var>y</var> adica 10.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "const"]}, {"id": 14, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint a = 100;\n\tint b = 200;\n\tint c = 300;\n\n\tint* const p1 = &a;\n\t*p1 = 999;\n\tp1 = &b;\n\t*p1 = 9999;\n\n\tconst int* p2 = &c;\n\tp2 = p1;\n\tp2 = &a;\n\n\tcout << *p1 << ' ' << *p2;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare la linia 11: <pre class='inline'><code>p1 = &amp;b;</code></pre>\n</div>\n<samp class='error'>expression must be a modifiable lvalue</samp>\n<div>\n<var>p1</var> este un pointer constant la un <pre class='inline'><code>int</code></pre>, deci il poti dereferentia cu <pre class='inline'><code>*</code></pre> si sa schimbi valorea de la adresa la care arata, dar nu poti schimba la ce adresa arata (adica arata spre <var>a</var>, nu poti schimba sa arate spre <var>b</var>). Ca sa fie corect poti schimba linia 10: <pre class='inline'><code>int* const p1 = &amp;a;</code></pre> in <pre class='inline'><code>int* p1 = &amp;a;</code></pre> si acum <var>p1</var> este un simplu pointer la un <pre class='inline'><code>int</code></pre> si poti schimba si adresa la care arata.\n</div>\n<pre class='block'><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint a = 100;\n\tint b = 200;\n\tint c = 300;\n\n\tint* p1 = &amp;a;\t// p1 arata spre a\n\t*p1 = 999;\t\t// a ia valorea 999\n\tp1 = &amp;b;\t\t// acum p1 arata spre b\n\t*p1 = 9999;\t\t// b ia valoarea 9999\n\n\tconst int* p2 = &amp;c;\t\t// p2 arata spre c\n\t\n\t// p2 e un pointer la un int constant, poti schimba la ce\n\t// adresa arata dar nu poti schimba valoarea de la adresa \n\t// la care arata: *p2 = 5; eroare si p2 = &amp;a; ok\n\t\n\tp2 = p1;\t// p2 arata spre ce arata p1 adica b\n\tp2 = &amp;a;\t// acum p2 arata spre a (p1 nu se modifica)\n\n\tcout &lt;&lt; *p1 &lt;&lt; &#39; &#39; &lt;&lt; *p2; // 9999 999\n}</code></pre></div>", "tags": ["easy", "incorrect", "pointers", "const"]}, {"id": 15, "problem": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int x = 5;\n\tint* const p = &x;\n\n\tint y = 100;\n\tconst int* const p2 = &y;\n\ty = 200;\n\n\tcout << *p + *p2;\n}", "solution": "<div><div>\nProgramul nu este corect, avem eroare la linia 6: <pre class='inline'><code>int* const p = &amp;x;</code></pre>\n</div>\n<samp class='error'>a value of type &quot;const int *&quot; cannot be used to initialize an entity of type &quot;int *const&quot;</samp>\n<div>\n<var>p</var> este un pointer const la un <pre class='inline'><code>int</code></pre> (poti modifica valoarea de la adresa la care arata, dar nu poti modifica la ce adresa arata pointerul) dar <var>x</var> este <pre class='inline'><code>const int</code></pre> si practic ai putea modifica valorea lui prin pointerul <var>p</var> deci nu e corect sa initializezi pointerul <var>p</var> cu adresa lui <var>x</var>. Ca sa fie corect <var>p</var> trebuie sa fie un pointer la <pre class='inline'><code>const int</code></pre> sau <var>x</var> sa fie doar <pre class='inline'><code>int</code></pre>. Deci ori schimbi linia 5: <pre class='inline'><code>const int x = 5;</code></pre> in <pre class='inline'><code>int x = 5;</code></pre> ori schimbi linia 6: <pre class='inline'><code>int* const p = &amp;x;</code></pre> in <pre class='inline'><code>const int* const p = &amp;x</code></pre>.\n</div>\n<div>\n<var>p2</var> este un pointer constant la un <pre class='inline'><code>const int</code></pre> deci nu poti modifica valoarea de la adresa la care arata <var>p2</var> si nici adresa la care arata. Poti modifica <var>y</var>, nu are legatura cu <var>p2</var>. La final se afiseaza: <pre class='inline'><code>205</code></pre> (daca faci modificarile de mai sus).\n</div>\n<div>\nCa sa nu te incurci cand citesti ceva de genul <pre class='inline'><code>const int* const p2 = &amp;y;</code></pre>, citeste de la dreapta la stanga: <var>p2</var> este un const  pointer la un <pre class='inline'><code>int</code></pre> const, <pre class='inline'><code>const int* const * const p3 = &amp;p2;</code></pre> este un const pointer la un const pointer la un <pre class='inline'><code>const int</code></pre>. Poti folosi si site-ul <a href='https://cdecl.org/?q=int*const+*const+p3'>asta</a>.\n</div></div>", "tags": ["easy", "incorrect", "pointers", "const"]}, {"id": 16, "problem": "#include <iostream>\nusing namespace std;\n\nconst int f(int x, int y) {\n\tint* p = &x;\n\tint& ry = y;\n\n\t*p = 100;\n\try = x;\n\try = 5;\n\n\treturn x + y;\n}\n\nint main() {\n\tconst int a = 500;\n\tint b = 300;\n\n\tint c = f(a, b);\n\n\tcout << a << \" \" << b << \" \" << c << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>500 300 105</samp>\n<div>\nAvem <var>a</var> care este un <pre class='inline'><code>const int</code></pre> cu valorea 500 si <var>b</var> care are valorea 300. <var>c</var> se initializeaza cu valorea returnata de functia <var>f</var> (nu conteaza ca <var>f</var> intoarce un <pre class='inline'><code>const int</code></pre>, se poate initializa un <pre class='inline'><code>int</code></pre> cu un <pre class='inline'><code>const int</code></pre>).\n</div>\n<div>\nIn functia <var>f</var> parametrii sunt transmisi prin valoare deci <var>x</var> si <var>y</var> sunt copii ale variabilelor <var>a</var> si <var>b</var>. <pre class='inline'><code>int* p = &amp;x;</code></pre> inseamna ca pointerul <var>p</var> arata spre zona de memorie unde este <var>x</var>, iar <var>ry</var> este o referinta la y (un alt nume practic). Prin <pre class='inline'><code>*p = 100;</code></pre> dereferentiezi pointerul <var>p</var> ca sa ai acces la zona de memorie la care arata si modifici valoarea de acolo in 100, adica <var>x</var> devine 100. <pre class='inline'><code>ry = x;</code></pre> inseamna practic <pre class='inline'><code>y = x;</code></pre>, pentru ca <var>ry</var> este o referinta la <var>y</var> (NU inseamna ca schimbi la ce se refera <var>ry</var>, nu poti face asta), deci <var>y</var> ia valorea lui <var>x</var> adica 100. <pre class='inline'><code>ry = 5;</code></pre> inseamna ca <var>y</var> ia valorea 5. La final se returneaza 100 + 5 adica 105. (nu uita ca <var>x</var> si <var>y</var> sunt copii ale lui <var>a</var> si <var>b</var> deci nu le modifica). Deci <var>a</var> ramane 500, <var>b</var> ramane 300 si <var>c</var> ia valorea 105.\n</div></div>", "tags": ["easy", "pointers", "references", "correct"]}, {"id": 17, "problem": "#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid f(int x, const double& y) {\n\tif (x == 0) {\n\t\tcout << \"x = 0!\";\n\t}\n\telse {\n\t\tcout << y / x << endl;\n\t}\n}\n\nvoid f(int x, double& y) {\n\tcout << x << \" si \" << y << endl;\n}\n\nint main() {\n\tf(2, 3.0);\n\n\tint x = 4;\n\tdouble y = 10.0;\n\n\tf(x, y);\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>1.5\n4 si 10</samp>\n<div>\nPrima functie <pre class='inline'><code>void f(int x, const double&amp; y)</code></pre> are ca parametru o referinta la un <pre class='inline'><code>const double</code></pre>, asta inseamana ca poti apela functia asta si cu ceva temporar care nu exista in memorie adica <pre class='inline'><code>f(1, 2.0)</code></pre> si cu o variabila <pre class='inline'><code>f(1, a);</code></pre>.\n</div>\n<div>\n<pre class='inline'><code>void f(int x, double&amp; y)</code></pre> aici referinta e la un <pre class='inline'><code>double</code></pre> deci functia se asteapta ca parametrul <var>y</var> sa fie o referinta la ceva care chiar exista in memorie, nu ar merge <pre class='inline'><code>f(1, 2.0)</code></pre>.\n</div>\n<div>\nDeci la <pre class='inline'><code>f(2, 3.0);</code></pre> se apeleaza prima functie, <var>x</var> e diferit de 0 si se afiseaza 3.0 / 2 adica <pre class='inline'><code>1.5</code></pre>.\nLa linia 24: <pre class='inline'><code>f(x, y);</code></pre> desi se potrivesc ambele functii a doua este preferata, e mai specifica, si se apeleaza <pre class='inline'><code>void f(int x, double&amp; y)</code></pre> si se afiseaza <pre class='inline'><code>4 si 10</code></pre>.\n</div>\n<div>\nDaca vrei ca functia sa accepte numai ceva temporar poti scrie <pre class='inline'><code>void f(int x, double&amp;&amp; y)</code></pre> (asta de la C++11 incoace), acum <pre class='inline'><code>f(1, 2.0);</code></pre> merge dar <pre class='inline'><code>f(1, x);</code></pre> nu merge.\n</div></div>", "tags": ["easy", "references", "function overloading", "correct"]}, {"id": 18, "problem": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nvoid afis(char v[][20], int rows) {\n\t\n\tfor (int i = 0; i < rows; ++i) {\n\t\tfor (int j = 0; j < strlen(v[i]); ++j) {\n\t\t\tcout << v[i][j] << \" \";\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\n\nint main() {\n\tchar v[3][20] = {\n\t\t\"Creion\",\n\t\t\"Hartie\",\n\t\t\"Pix\"\n\t};\n\n\tafis(v, 3);\n}", "solution": "<div><div>\nProgramul e corect, se afiseaza:\n</div>\n<samp class='output'>C r e i o n\nH a r t i e\nP i x</samp>\n<div>\nSe creeaza o &quot;matrice&quot; de <pre class='inline'><code>char</code></pre> sau mai bine zis, un array de cuvinte, unde lungimea maxima a cuvintelor este 20 si exista 3 cuvinte. Daca ai in parametrii functiei array-uri care au mai multe dimensiuni (in cazul asta 2) trebuie sa specifici marimea pentru fiecare dimensiune in afara de prima (poti si la prima dar daca nu faci asta dimensiunea e variabila). \n</div>\n<pre class='block'><code>void f(int v[][][100])  { /* ... */ } \t// gresit\nvoid f(int v[25][][30]) { /* ... */ } \t// gresit\nvoid f(int v[][20][10]) { /* ... */ } \t// corect\nvoid f(int v[10][20][10]) { /* ... */ } // corect</code></pre>\n<div><pre class='inline'><code>void afis(char v[][20], int rows)</code></pre> are ca prim parametru o matrice de <pre class='inline'><code>char</code></pre> cu 20 coloane si numar variabil de linii, parametrul <var>rows</var> inseamna numarul de linii.\n</div>\n<div>\nLuam fiecare linie pe rand (pe fiecare linie e un cuvant), acum parcurgem pe rand literele cuvantului respectiv, care poate avea mai putin de 20 de caractere de aceea folosim <pre class='inline'><code>strlen</code></pre> care e o functie care ne da numarul de caractere din cuvant. Se afiseaza literele cuvintelor separate prin spatiu, iar cand se termina cuvantul se trece la o linie noua si la urmatorul cuvant.\n</div></div>", "tags": ["correct", "easy", "2d array"]}, {"id": 19, "problem": "#include <iostream>\nusing namespace std;\n\nvoid f(int x, double y, const int z) \n{\n\tcout << \"x = \" << x << endl;\n\tcout << y / 2 << endl;\n\tint temp = z + x;\n\n\tfor (int i = 0; i < temp; ++i)\n\t{\n\t\tcout << 'a' << ' ' << endl;\n\t}\n}\n\nvoid f(int x,const double y, int z)\n{\n\twhile (x > 1) \n\t{\n\t\tcout << y << \", \";\n\t\tx--;\n\t}\n\tcout << endl;\n\n\tif (z < 0) z = -z;\n\t\n\tcout << x + z << endl;\n}\n \n\nint main() {\n\tconst int x = 4;\n\tconst double y = 3.14;\n\tf(2, 2.0, x);\n\tf(3, y, 3);\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 16\n</div>\n<samp class='error'>function &#39;void f(int,double,const int)&#39; already has a body</samp>\n<div>\nNu te poti baza pe faptul ca un parametru este sau nu <pre class='inline'><code>const</code></pre> atunci cand vrei sa supraincarci o functie, decat daca acel parametru este <b>pointer sau referinta</b> pentru ca daca nu este pointer sau referinta se transmite argumentul prin valoare, adica se copiaza si nu conteaza ca parametrul e <pre class='inline'><code>const</code></pre> pentru ca oricum este o copie.\n</div>\n<div>\nEroarea spune ca practic definesti aceeasi functie de 2 ori, nu conteaza ca unii paramterii sunt <pre class='inline'><code>const</code></pre> pentru ca nu sunt referinte sau pointeri. Ca programul sa functioneze corect poti schimba prima functie (linia 4) in <pre class='inline'><code>void f(int x, double&amp; y, const int z)</code></pre>, acum primeste o referinta la <pre class='inline'><code>double</code></pre>, ceea ce ii permite sa modifice valoarea argumentului cand se apeleaza functia, deci nu mai face acelasi lucru cu a doua functie care nu putea face asta pentru ca argumentul se transmite prin copiere.\n</div>\n<div>\nCu modificarea de mai sus, <pre class='inline'><code>f(2, 2.0, x);</code></pre> se apeleaza a doua functie pentru ca <pre class='inline'><code>2.0</code></pre> este o valoare temporara care nu exista in memorie si nu putem avea referinta la ea. La urmatoarea linie <pre class='inline'><code>f(3, y, 3);</code></pre> se apeleaza a doua functie pentru ca la prima ai referinta la un <pre class='inline'><code>double</code></pre> care NU e const, deci ai putea modifica valorea lui in functie si se va reflecta si in afara functiei, dar in <pre class='inline'><code>main</code></pre>, <var>y</var> este <pre class='inline'><code>const double</code></pre> si nu-i poti modifica valorea. La final se afiseaza:\n</div>\n<samp class='output'>2,\n5\n3.14, 3.14,\n4</samp></div>", "tags": ["easy", "incorrect", "const", "function overloading"]}, {"id": 20, "problem": "#include <iostream>\nusing namespace std;\n\nint myFunction(int A = 1, int B = 2, int C) {\n\tint temp = A;\n\tfor (int i = 0; i < B; ++i)\n\t{\n\t\ttemp += C;\n\t\tC--;\n\t}\n\treturn temp;\n}\n\nint main() {\n\tint num = myFunction(1, 2, 3);\n\tcout << num << endl;\n}", "solution": "<div><div>\nProgramul nu functioneaza corect, avem eroare de compilare la linia 4: <pre class='inline'><code>int myFunction(int A = 1, int B = 2, int C) {</code></pre>.\n</div>\n<samp class='error'>default argument not at end of parameter list</samp>\n<div>\nDaca ai o functie cu parametrii care au valori implicite, ei trebuie sa se afle la sfarsit, nu pot urma parametrii fara valori implicite dupa cei cu valori implicite.\nCa sa fie corect modifica linia 4 in <pre class='inline'><code>int myFunction(int A = 1, int B = 2, int C = 0) {</code></pre> sau in <pre class='inline'><code>int myFunction(int A, int B, int C) {</code></pre>. La final se afiseaza:\n</div>\n<samp class='output'>1</samp></div>", "tags": ["easy", "incorrect"]}, {"id": 21, "problem": "#include <iostream>\nusing namespace std;\n\nint f(double x)\n{\n\tint i = 1;\n\twhile (i * i < x)\n\t{\n\t\ti++;\n\t\tcout << '*';\n\t}\n\tcout << '!' << endl;\n\treturn i;\n}\n\nint f(int x)\n{\n\tif (x % 2 == 0)\n\t\treturn x * 2;\n\telse\n\t\treturn x * 3 - 10;\n}\n\nint main()\n{\n\tshort a = 3;\n\tfloat b = 5.0f;\n\n\tint x = f(a);\n\tint y = f(b);\n\n\tcout << x << ' ' << y << endl;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>**!\n-1 3</samp>\n<div>\nFunctia <var>f</var> este supraincarcata. La linia 29: <pre class='inline'><code>int x = f(a);</code></pre> se apeleaza functia <var>f</var> cu un <pre class='inline'><code>short int</code></pre>. Ambele variante ale functiei <var>f</var> fac o conversie deci nu ar trebui sa fie ambiguu apelul, adica sa nu se stie care functie se apeleaza? In cazul asta nu pentru ca, desi ambele functii fac o conversie, cea de la <pre class='inline'><code>short int</code></pre> la <pre class='inline'><code>int</code></pre> este mai speciala, se numeste &quot;promotie&quot; (adica valorile care se reprezinta cu un <pre class='inline'><code>short int</code></pre> se pot reprezenta la fel de exact si cu un <pre class='inline'><code>int</code></pre>). Cand se alege ce functie se apeleaza, promotiile sunt mai importante decat conversile obisnuite si de aceea se apeleaza a doua functie. \n</div>\n<div>\nLa linia 30: <pre class='inline'><code>int y = f(b);</code></pre> se apeleaza functia <var>f</var> cu un <pre class='inline'><code>float</code></pre>. Este aceeasi situatie de mai sus, din nou conversia din <pre class='inline'><code>float</code></pre> in <pre class='inline'><code>double</code></pre> este &quot;promotie&quot; deci se alege prima functie. Mai multe detalii <a href='./tips.html#function-overloading'>aici</a>.\n</div></div>", "tags": ["correct", "easy", "function overloading"]}, {"id": 22, "problem": "#include <iostream>\nusing namespace std;\n\nvoid multiply(int* v, int n, int x)\n{\n\tfor (int i = 0; i < n; ++i)\n\t\tv[i] *= x;\n}\n\nvoid print(int* v, int n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << v[i] << ' ';\n\t\n\tcout << endl;\n}\n\nint main()\n{\n\tint* i = new int[5]{ 1, 2, 3, 4, 5 }; \n\t// din C++11 https://www.geeksforgeeks.org/uniform-initialization-in-c/\n\n\tint* j = i;\n\n\tmultiply(i, 5, 2);\n\tprint(i, 5);\n\tprint(j, 5);\n\n\tdelete[] i;\n}", "solution": "<div><div>\nProgramul functioneaza corect, se afiseaza:\n</div>\n<samp class='output'>2 4 6 8 10\n2 4 6 8 10</samp>\n<div>\nSe creeaza un array alocat dinamic cu 5 elemente (1, 2, 3, 4 si 5). Se creeaza un pointer <var>j</var> care arata spre aceeasi zona de memorie ca <var>i</var> (primul element din array). Functia <pre class='inline'><code>void multiply(int* v, int n, int x)</code></pre> primeste ca argumente pointerul <var>i</var>, lungimea array-ului si un numar cu care inmulteste toate elementele. La linia 26: <pre class='inline'><code>print(i, 5);</code></pre> si linia 27: <pre class='inline'><code>print(j, 5);</code></pre> se apeleaza functia <pre class='inline'><code>void print(int* v, int n)</code></pre> care printeaza elementele array-ului. Se printeaza aceleasi valori de 2 ori pentru ca <var>i</var> si <var>j</var> arata spre aceeasi zona de memorie.\n</div>\n<div>\nCand scrii o functie <pre class='inline'><code>void f(int v[]) { /* ... */ }</code></pre> este acelasi lucru cu <pre class='inline'><code>void f(int *v) { /* ... */ }</code></pre> (nu conteaza ca returneaza <pre class='inline'><code>void</code></pre> sau array-ul/pointerul este <pre class='inline'><code>int</code></pre>). <pre class='inline'><code>v[i]</code></pre> este de fapt <pre class='inline'><code>*(v + i)</code></pre>.\n</div>\n<div>\nMereu array-urile sunt transmise prin &quot;referinta&quot; la o functie (de fapt cum este mai sus, se transmite pointerul la primul element prin valoare dar asta nu conteaza pentru ca arata spre aceeasi zona de memorie, adica array-ul initial).\n</div></div>", "tags": ["correct", "easy", "dynamic memory allocation", "pointers"]}]}