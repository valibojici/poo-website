#BEGIN_PROBLEM
#include <iostream>
#include <cstring>

using namespace std;

class Fruct{
protected:
    char denumire[10];
    int kg;
public:
    Fruct(const char* nume="fara", int kg=0){
        strcpy(denumire, nume);
        this->kg = kg;
    }
};

class Mar : public Fruct{
private:
    char culoare[10];
public:
    Mar(const char* nume="", int kg=0, const char* culoare="fara") : Fruct::Fruct(nume, kg) {
        strcpy(this->culoare, culoare);
    }

    void afis(){
        cout << denumire << " " << kg << " " << culoare << '\n';
    }
};

int main(){
    Mar m1("Red Delicious", 23, "Rosu"), m2("Honeycrisp", 2);
    m1.afis();
    m2.afis();
}

#END_PROBLEM

#BEGIN_SOLUTION
Programul compileaza. Se afiseaza
<br>
<samp>
Red Deliciou 23 Rosu
<br>
Honeycrisp 2 fara
</samp>
<br>
Se creaza 2 variabile de tip Mar, <var>m1</var> si <var>m2</var>. Pentru amandoua se apeleaza pe rand constructorul de la linia 21, care apeleaza la randul lui constructorul din clasa de baza Fruct. Asta trebuie sa se faca in initializer list, nu se poate in corpul constructorului!!! De ce? C++ garanteaza ca clasa de baza se construieste inainte de clasa derivata. Cand esti in corpul constructorului din clasa Mar, s-a apelat deja constructorul din clasa Fruct (daca nu l-ai apelat tu se apeleaza automat) deci nu poti sa il mai apelezi iar.
<block>
    Mar(const char* nume="", int kg=0, const char* culoare="fara"){
        Fruct::Fruct(nume, kg); // nu e corect, eroare
        strcpy(this->culoare, culoare);
    }
</block>
<br>
<block>
    Mar(const char* nume="", int kg=0, const char* culoare="fara"){
        strcpy(this->culoare, culoare);  
    }

    // este echivalent cu:

    Mar(const char* nume="", int kg=0, const char* culoare="fara")
        : Fruct::Fruct() // daca nu apelezi tu constructorul, se apeleaza automat constructorul implicit
    {
        strcpy(this->culoare, culoare);  
    }
</block>
In constructorul din clasa Fruct de exemplu, avem parametrul <var>kg</var> dar si data membra <var>kg</var>. Deci cum deosebim care e care? Punand <inline>this->kg</inline> te referi la data membra, cand scrii doar <var>kg</var> te referi la parametrul constructorului. Daca parametrul din consrtuctor avea alt nume, de ex. <var>kilograme</var> atunci puteai scrie doar <var>kg</var> in loc de <inline>this->kg</inline> pentru ca nu mai exista confuzii.
<br>
In constructori avem parametrii impliciti, care trebuie pusi dupa cei care nu sunt impliciti dar in exemplul asta nu avem. De exemplu cand se apeleaza constructorul pentru <var>m2</var> nu se specifica <var>culoare</var> deci va avea valoarea implicita <var>fara</var>.
#END_SOLUTION

#BEGIN_TAGS
easy, correct, mostenire, constructor, initializer list
#END_TAGS