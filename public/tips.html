<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- bootstrap TO DO compile just essential stuff-->
    <link href="./styles/customBootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous" defer></script>
    
    <!-- jquery -->
    <script src="./js/jquery.js" defer></script>

    <!-- bs icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.5.0/font/bootstrap-icons.min.css">

    <!-- highlightjs -->
    <link rel="stylesheet" href="./styles/vs.min.css">
    <script src="./js/highlight.min.js" defer></script>

    <!-- my stuff -->
    <script src="./js/codeblock.js" defer></script>
    <script src="./js/tips.js" defer></script>
    <link rel="stylesheet" href="./styles/tips.min.css">
    <link rel="stylesheet" href="./styles/codeblock.min.css">
    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    <title>InvataPOO - Tips</title>
    <meta name="description" content="La pagina Tips gasesti informatii legate de unele chestii de C++ sau POO in general">

</head>
<body data-bs-spy="scroll" data-bs-target="#scrollspy" data-bs-offset="0" tabindex="0" class="bg-altlight">

    <!-- navbar -->
    <nav id='navbar-container' class="navbar navbar-expand-lg navbar-dark bg-dark text-light py-2">
        <div class="container">
            <a class="navbar-brand" href="./index.html">&Icirc;nvață POO</a>
            
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbar">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbar">
                <ul class="navbar-nav ms-4 me-auto mb-2 mb-lg-0">
                    <li class="nav-item mx-xl-2">
                        <a class="nav-link" href="./index.html">Acasă</a>
                    </li>
                    <li class="nav-item dropdown mx-xl-2">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">Categorii probleme</a>
                        <ul class="dropdown-menu dropdown-menu-dark">
                            <li><a class="dropdown-item" href="./problem.html?t=easy">Usor</a></li>
                            <li><a class="dropdown-item" href="./problem.html?t=medium">Mediu</a></li>
                            <li><a class="dropdown-item" href="./problem.html?t=hard">Greu</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="./problem.html?order=random">Random</a></li>
                        </ul>
                    </li>
                    <li class="nav-item mx-xl-2">
                        <a class="nav-link" href="./tips.html">Tips</a>
                    </li>
                    <li class="nav-item mx-xl-2">
                        <a class="nav-link" href="./index.html#contact" >Contact</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- offcanvas --> 
    <div class="offcanvas offcanvas-start bg-dark d-block d-md-none" data-bs-scroll="true" tabindex="-1" id="offcanvas">
        <div class="offcanvas-header px-4 pt-4 pb-0">
            <h5 class="offcanvas-title text-light text-center flex-grow-1" id="offcanvasLabel">Cuprins</h5>
            <button type="button" class="btn-close btn-close-white text-reset p-0 m-0" data-bs-dismiss="offcanvas"></button>
        </div>
        <div class="offcanvas-body px-0 px-sm-3 pt-0">
            <nav id="offcanvas-nav" class="navbar navbar-dark bg-dark flex-column align-items-stretch px-3 sticky-top w-100">
                <nav class="nav nav-pills flex-column align-items-start">
                  <a class="nav-link py-0 mt-2" href="#overloading-overriding" data-bs-dismiss="offcanvas">Supraincarcare & Supradefinire</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="ms-5 mt-2 text-decoration-none" href="#function-overloading"  >Supraincarcare functii</a>
                    <a class="ms-5 mt-2 text-decoration-none" href="#operator-overloading" data-bs-dismiss="offcanvas">Supraincarcare operatori</a>
                    <a class="ms-5 mt-2 text-decoration-none" href="#function-overriding" data-bs-dismiss="offcanvas">Supradefinire functii</a>
                  </nav>
                  <a class="nav-link py-0 mt-2" href="#endl" data-bs-dismiss="offcanvas">Ce face <code>endl</code>?</a>
                </nav>
            </nav>
        </div>
    </div>

    <!-- button offcanvas -->
    <a id='offcanvas-btn' class="btn btn-outline-secondary px-0 d-block d-md-none" data-bs-toggle="offcanvas" href="#offcanvas" role="button" >
        Cuprins
    </a>

    <div class="row g-0" >
        <div class="content col col-md-9 col-xl-10 px-2 px-sm-3 px-md-4 px-xll-0">
            
            <!-- overloading overriding -->
            <section id="overloading-overriding" class="bg-altlight pt-5 my-5">
                <div class="container">
                    <h1 class="display-3">Supraincarcare (overloading) & supradefinire (overriding)</h1>
        
                    <article id="function-overloading" class="mt-5">
                        <h3 class='my-2 ps-2 rounded'>Supraincarcare functii</h3>
                        <div class="article-content lead">
                            <div>
                                In C++ putem avea mai multe functii cu acelasi nume dar trebuie ca parametrii ori sa fie de tipuri diferite, ori sa difere numarul de parametrii, ori parametrii sa fie in alta ordine (ma refer la tipul lor de ex. <div class="inline-code">int, int, float</div> si <div class="inline-code">float, int, int</div> nu la denumire, asta nu conteaza). De exemplu:
                                <div class="block-code">           
                                    void f(int x) {}            // numar diferit de parametrii fata de functiile de mai jos
                                    void f(int x, float y) {}   // difera ordinea tipurilor parametriilor fata de functia de mai jos
                                    void f(float x, int y) {}
                                </div>
                            </div>
                            <div>
                                Totusi ai grija la parametrii cu valori implicite, de exemplu mai jos avem eroare pentru ca apelul de functie este ambiguu, nu se stie care functie sa se aleaga.
                                <div class="block-code">
                                    #include &lt;iostream&gt;
                                    using namespace std;

                                    void f(int x) {}
                                    void f(int x, int y = 4) {}

                                    int main() {
                                        f(5); // eroare aici
                                    }
                                </div>
                            </div>
                        <div>
                            Tehnic vorbind functiile trebuie sa aiba signaturi diferite. Signatura se refera la numele functiei, numarul, ordinea si tipul parametrilor.
                        </div>
                        <div>
                            <div>Daca avem ceva de genul:</div>
                            <div class="block-code">
                                #include &lt;iostream&gt;
                                using namespace std;

                                void f(int x, int y) {}
                                void f(double x, int y) {}

                                int main() {
                                    f(2, 2.3);
                                }
                            </div>
                            <div>Cum se alege ce functie se apeleaza? Compilatorul se uita pe rand la fiecare argument si creaza o multime de functii candidat pentru fiecare argument, adica tipul argumentului (cand apelezi functia) se poate converti (cumva) in tipul parametrului (in definitia functiei). Pentru fiecare argument se creeaza o multime de functii care se potrivesc cel mai bine (chiar daca exista multe functii canditat unele fac mai multa &quot;treaba&quot; decat altele sa converteasca, de aceea se aleg cele care se potrivesc cel mai bine). Din multimile astea de functii care se potrivesc cel mai bine pentru fiecare argument se face o intersectie si functia rezultata este cea care se apeleaza. Daca intersectia e vida sau contine mai mult de 1 functie avem eroare de compilare.</div>
                        </div>

                        <div>
                            <div>De exemplu:</div>
                            <div class="block-code">
                                #include &lt;iostream&gt;
                                using namespace std;

                                class MyClass {
                                    // o clasa goala pentru exemplu
                                };

                                void f(MyClass x, long long y) {}   // functia 1
                                void f(long long x, MyClass y) {}   // functia 2
                                void f(MyClass x, MyClass y) {}     // functia 3

                                int main() {
                                    int x = 4;
                                    MyClass y;

                                    f(x, y);
                                    f(x, x);
                                }
                            </div>
                            <div>
                                Sa ne uitam la linia 16: <div class="inline-code">f(x, y);</div>. Mai intai la primul argument de tip <div class="inline-code">MyClass</div>, multimea functiilor candidat = {functia 1, functia 2},multimea functiilor care ce potrivesc cel mai bine = {functia 1, functia 2}. Acum sa ne uitam la al doilea argument de tip <div class="inline-code">int</div>, multimea functiilor candidat = multimea functiilor care se potrivesc cel mai bine = {functia 1} (pentru ca se poate converti <div class="inline-code">int</div> in <div class="inline-code">long long</div> ).
                            </div>
                        </div>
                        <div>
                            {functia 1, functia 2} ∩ {functia 1} = {functia 1}. Asta inseamna ca in final pentru <div class="inline-code">f(x, y);</div> se apeleaza functia 1.
                        </div>
                        <div>
                            Daca ne uitam la linia 17: <div class="inline-code">f(x, x);</div>, pentru primul argument multimea functiilor care se potrivesc cel mai bine = {functia 2}, pentru al doilea argument multimea functiilor care se potrivesc cel mai bine = {functia 1}, iar {functia 2} ∩ {functia 1} = Ø si deci eroare.
                        </div>

                        <div>
                            In general daca avem o functie care e supraincarcata si avem doua variante F1 si F2, cum alege compilatorul functia care se potriveste cel mai bine? Functia F1 este mai &quot;buna&quot; decat F2 daca in primul rand conversiile implicite pe care le face F1 (de la tipul argumentelor la tipul parametrilor) nu sunt mai rele decat cele facute de F2 (pt. fiecare argument) si in plus:
                            <ol class="">
                                <li>E cel putin un argument in F1 a carui conversie implicita este mai buna decat conversia implicita pentru acel argument in F2</li>
                                <li>Sau daca nu e asa, dar doar in cazul conversiilor definite de tine (gen operatorul de cast intr-o clasa), daca conversia implicita de la tipul returnat de F1 la tipul destinatie este mai buna decat conversia implicita de la tipul returnat de F2 la tipul destinatie.
                                    <div class="block-code">
                                        class MyClass {
                                        public:
                                            operator float() { return 5.5; }
                                            operator int() { return 1; }
                                        };

                                        int main() {
                                            MyClass a;
                                            double x = a;   // se apeleza prima functie vezi mai jos de ce
                                            cout &lt;&lt; x;      // se afiseaza 5.5
                                        }
                                    </div>
                                </li>
                                <li>Sau daca nu e asa, F1 este non-template iar F2 este template sau ambele sunt template dar F1 este mai specializata (dar despre template vorbesc separat).</li>
                            </ol>
                        </div>

                        <div>
                            Acum ce inseamna ca o conversie e mai buna decat alta? Exista 3 tipuri (in ordinea importantei):
                            <ol>
                                <li class="mt-4">
                                    <h5>Exact match</h5>
                                    <div>Nu trebuie sa se faca nicio &quot;conversie&quot; sau daca se face se considera exact match.
                                        <div class="block-code">
                                            void f(int& x);
                                            void f(double x);
                                            int x = 42;
                                            f(x); // argument type is int; exact match with int&

                                            /////////////////////////////////////////

                                            void g(int* p);
                                            void g(void* p);

                                            int a[100];
                                            g(a); // calls f(int*); exact match with array-to-pointer conversion
                                    </div>
                                    </div>
                                </li>
                                <li class="mt-4">
                                    <h5>Promotion</h5>
                                    <div>Aici intra <i>integral promotion</i> si <i>floating-point promotion</i>. Promotia e un tip special de conversie pentru tipurile de date built-in (<div class="inline-code">int</div>, <div class="inline-code">float</div> etc.) si este garantat ca nu schimba valoarea. (adica tipul de date la care se converteste poate reprezenta exact orice valoare a tipului de date de la care se converteste)</div>
                                    <div class="text-decoration-underline">Integral promotion</div>
                                    <ul>
                                        <li><div class="inline-code">signed char</div> sau <div class="inline-code">signed short</div> se pot converti la <div class="inline-code">int</div></li>
                                        <li><div class="inline-code">unsigned char</div> sau <div class="inline-code">unsigned short</div> se pot converti la <div class="inline-code">int</div> daca <div class="inline-code">int</div> poate retine toate valorile sau la <div class="inline-code">unsigned int</div> daca nu poate. (e posibil ca short/char si int sa aiba acelasi nr. de biti pe un calculator si de aceea nu poti din unsigned short/char in int) </li>
                                        <li><div class="inline-code">char</div> se poate converti la <div class="inline-code">int</div> sau <div class="inline-code">unsigned int</div> (depinde daca prin <div class="inline-code">char</div> te referi la <div class="inline-code">signed char</div> sau <div class="inline-code">unsigned char</div>)</li>
                                        <li><div class="inline-code">bool</div> se poate converti la <div class="inline-code">int</div>, <div class="inline-code">false</div> devine <div class="inline-code">0</div> iar <div class="inline-code">true</div> devine <div class="inline-code">1</div></li>
                                    </ul>
                                    <div class="text-decoration-underline">Floating-point promotion</div>
                                    <ul>
                                        <li>Se refera doar la conversia de la <div class="inline-code">float</div> la <div class="inline-code">double</div>.</li>
                                    </ul>
                                </li>
                                <li class="mt-4">
                                    <h5>Conversion</h5>
                                    <div>
                                        Aici intra <i>integral conversion</i>, <i>floating-point conversion</i>, <i>floating-integral conversion</i>, <i>bool conversion</i>
                                    </div>
                                    <div class="text-decoration-underline">Integral conversion</div>
                                    <ul>
                                        <li>aici intra conversii dintre 2 tipuri de date ce reprezinta nr. intregi dar <b>nu</b> e promotion, de exemplu din <div class="inline-code">int</div> in <div class="inline-code">long</div> sau din <div class="inline-code">unsigned short</div> in <div class="inline-code">short</div> </li>
                                    </ul>
                                    <div class="text-decoration-underline">Floating-point conversion</div>
                                    <ul>
                                        <li>aici intra conversii dintre 2 tipuri de date ce reprezinta nr. cu virgula dar <b>nu</b> e promotion, de exemplu din <div class="inline-code">double</div> in <div class="inline-code">float</div> sau din <div class="inline-code">float</div> in <div class="inline-code">long double</div>
                                        <div>
                                            <div class="block-code">
                                                void f(double);
                                                void f(long double);
                                                f(0.0f);
                                            </div>
                                            Se apeleaza prima functie pentru ca promotia (de la <div class="inline-code">float</div> la <div class="inline-code">double</div>) este mai buna decat conversia (de la <div class="inline-code">float</div> la  <div class="inline-code">long double</div>)
                                        </div>
                                        </li>
                                    </ul>
                                    <div class="text-decoration-underline">Floating-integral conversion</div>
                                    <ul>
                                        <li>aici intra conversii dintre un tip de date ce reprezinta nr. cu virgula si un tip de date care reprezinta nr. intregi de exemplu din <div class="inline-code">double</div> in <div class="inline-code">int</div> sau din <div class="inline-code">int</div> in <div class="inline-code">float</div>
                                        <div>
                                            <div class="block-code">
                                                void f(int);
                                                void f(long double);
                                                f(0.0f);
                                            </div>
                                            Eroare de compilare, apelul este ambiguu, avem 2 conversii (de la <div class="inline-code">float</div> la <div class="inline-code">int</div> si de la <div class="inline-code">float</div> la  <div class="inline-code">long double</div>  )
                                        </div>
                                        </li>
                                    </ul>
                                    <div class="text-decoration-underline">Bool conversion</div>
                                    <ul>
                                        <li>de exemplu din <div class="inline-code">int</div> in <div class="inline-code">bool</div> sau din <div class="inline-code">float</div> in <div class="inline-code">bool</div>. (de ex. <div class="inline-code">bool x = 5; // true</div> )
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                    <div>
                        <h3>Surse</h3>
                        <ul>
                            <li><a href="https://en.cppreference.com/w/c/language/conversion">https://en.cppreference.com/w/c/language/conversion</a></li>
                            <li><a href="https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions?view=msvc-160">https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions?view=msvc-160</a></li>
                            <li><a href="https://stackoverflow.com/questions/30490592/no-really-when-does-floating-point-promotion-actually-happen">https://stackoverflow.com/questions/30490592/no-really-when-does-floating-point-promotion-actually-happen</a></li>
                            <li><a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">https://en.cppreference.com/w/cpp/language/implicit_conversion</a></li>
                            <li><a href="https://riptutorial.com/cplusplus/example/8117/steps-of-overload-resolution">https://riptutorial.com/cplusplus/example/8117/steps-of-overload-resolution</a></li>
                            <li><a href="https://riptutorial.com/cplusplus/example/6616/exact-match">https://riptutorial.com/cplusplus/example/6616/exact-match</a></li>
                            <li><a href="https://en.cppreference.com/w/cpp/language/overload_resolution">https://en.cppreference.com/w/cpp/language/overload_resolution</a></li>
                        </ul>
                    </div>
                    </article>
        
                    <article id="operator-overloading" class='mt-5'>
                        <h3 class='my-2 ps-2 rounded'>Supraincarcare operatori</h3>
                        <div class="article-content lead">
                            <ol class="">
                                <li>Majoritatea operatorilor din C++ pot fi supraincarcati (ori ca functii membre intr-o clasa ori ca functii prieten, insa unii pot fi DOAR functii membre).</li>
                                <li>Nu poti fi supraincarcati: <div class="inline-code">.  .*  ::  ?: sizeof</div> (da, <div class="inline-code">sizeof</div> e un operator, nu functie).</li>
                                <li>Nu poti modifica precedenta operatorilor sau numarul de argumente pe care le primesc.</li>
                                <li><b>Toti operatorii care pot fi supraincarcati NU pot avea parametrii default, exceptie face</b><div class="inline-code">()</div> (operatorul &apos;apel de functie&apos;).</li>
                                <li><b>Toti operatorii supraincarcati intr-o clasa de baza sunt mosteniti de clasa derivata,<span class='text-danger'>cu exceptia</span></b>  <div class="inline-code">=</div> (operatorul de atribuire).</li>
                                <li><b>Operatorii</b> <div class="inline-code">=</div> <div class="inline-code">()</div> <div class="inline-code">[]</div> <div class="inline-code">-></div><b> trebuie declarati ca functii membre ale unei clase (nu merge sa fie functii prieten).</b> </li>
                            </ol>
                            <div>Mai multe informatii despre supraincarcarea operatorilor <a href="http://isocpp.org/wiki/faq/operator-overloading">sunt aici</a>.</div>
                        </div>
                    </article>
        
                    <!-- supradefinire functii -->
                    <article id="function-overriding" class='mt-5'>
                        <h3 class='my-2 ps-2 rounded'>Supradefinire functii</h3>
                        <div class="article-content lead">
                            <div>Supradefinirea de functii, folosind <div class="inline-code">virtual</div>, are legatura cu polimorfismul la runtime. Daca o metoda din clasa de baza este virtuala si este redefinita intr-o clasa derivata, o putem apela folosindu-ne de un pointer/referinta la clasa de baza (care arata spre un obiect de tipul clasei derivate). In mod normal, daca metoda nu ar fi virtuala, nu am putea face asta deoarece compilatorul s-ar uita doar la tipul pointerului/referintei (nu il intereseaza daca am facut upcast)</div>
                            
                            <div>
                                Cand supradefinesti o functie (care e virtuala in clasa de baza) in clasa derivata <b>trebuie sa fie exact la fel, cu tot cu tipul returnat</b> (o diferenta fata de supraincarcarea functiilor). Totusi pentru tipul returnat exista o <b>exceptie</b>: cand intorci pointeri/referinte. Metoda supradefinita din clasa derivata poate intoarce ceva mai &quot;specializat&quot; (daca metoda din clasa de baza intorcea B*, cea din clasa derivata poate intoarce D*, unde D mosteneste B). La ce ne trebuie asta? De obicei asta se foloseste la un design pattern care se numeste &quot;prototype&quot; sau &quot;clone&quot;.
                            </div>

                            <div><b>Metodele statice nu pot fi virtuale (pentru ca nu corespund unui obiect ci intregii clase)</b>.</div>
                            
                            <div class="block-code">
                                #include &lt;iostream&gt;
                                using namespace std;

                                class Base {
                                public:
                                    // f nu este virtuala, g si h sunt virtuale
                                    void f() { cout &lt;&lt; &quot;Base f()&quot; &lt;&lt; endl; }
                                    virtual void g() { cout &lt;&lt; &quot;Base g()&quot; &lt;&lt; endl; }
                                    virtual void h() { cout &lt;&lt; &quot;Base h()&quot; &lt;&lt; endl; }
                                };

                                class Derived : public Base {
                                public:
                                    void f() { cout &lt;&lt; &quot;Derived f()&quot; &lt;&lt; endl; }
                                    void g() { cout &lt;&lt; &quot;Derived g()&quot; &lt;&lt; endl; }
                                    // g este virtuala si aici chiar daca nu apare virtual !
                                };

                                int main()
                                {
                                    Base* p1 = new Base;
                                    Base* p2 = new Derived; // upcast

                                    p1-&gt;f(); // Base f()
                                    // ne uitam la tipul lui p1 care este Base*, metoda f din clasa Base nu este virtuala, deci ea se executa

                                    p2-&gt;f(); // Base f()
                                    // ne uitam la tipul lui p2 care este Base*, metoda f din clasa Base nu este virtuala, deci ea se executa

                                    p1-&gt;g(); // Base g()
                                    // ne uitam la tipul lui p1 care este Base*, metoda g din clasa Base este virtuala
                                    // ne uitam acum la tipul obiectului la care arata p1, adica ceva de tip Base
                                    // deci metoda g din clasa Base se executa

                                    p2-&gt;g(); // Derived g()
                                    // ne uitam la tipul lui p2 care este Base*, metoda g din clasa Base este virtuala
                                    // ne uitam acum la tipul obiectului la care arata p2, adica ceva de tip Derived
                                    // in clasa Derived este supradefinita metoda g, deci ea se apeleaza.
                                    
                                    p1-&gt;h(); // Base h()
                                    // p1 este de tip Base*, metoda h din Base este virtuala
                                    // ne uitam la tipul obiectului la care arata p1, adica Base, deci se executa metoda din Base.

                                    p2-&gt;h(); // 
                                    // p2 este de tip Base*, metoda h din Base este virtuala
                                    // ne uitam la tipul obiectului la care arata p2, adica Derived
                                    // in Derived nu este supradefinita metoda h, deci se executa metoda din Base (care e mostenita practic in clasa Derived).
                                    return 0;
                                }
                            </div>
                            
                            <div>Daca nu lucrezi cu pointeri sau referinte nu adauga nimic in plus faptul ca o functie e virtuala.</div>
                            <div>Ce faci daca ai metode virtuale dar totusi vrei sa apelezi numai metoda din clasa de baza de exemplu? Folosesti operatorul de scop si numele clasei. Te poti duce doar in sus in ierarhia de clase, nu in jos.</div>
                            <!-- <div class="block-code">
                                // avem clasele de mai sus
                                Base* p = new Derived; // upcast

                                p-&gt;Base::g();     // Base g()
                                p-&gt;g();           // Derived g()

                                p-&gt;Derived::g();  // eroare
                            </div> -->

                            <div class="block-code">
                                class SuperBase {
                                public:
                                    virtual void g() { cout &lt;&lt; &quot;SuperBase g()&quot;; }
                                };
                                
                                class Base : public SuperBase{
                                public:
                                    virtual void g() { cout &lt;&lt; &quot;Base g()&quot; &lt;&lt; endl; }
                                    // g este deja virtual, nu este necesar sa scrii iar virtual
                                };
                                
                                class Derived : public Base {
                                public:
                                    void g() { cout &lt;&lt; &quot;Derived g()&quot; &lt;&lt; endl; }
                                    // g este virtuala si aici chiar daca nu apare virtual !
                                };

                                int main(){
                                    Base *p = new Derived;  // upcast
                                    
                                    p-&gt;g();  // Derived g() (polimorfism la runtime)
                                    p-&gt;Base::g();  // Base g()
                                    
                                    p-&gt;SuperBase::g();  // Superbase g()
                                    // p este de tip Base*, Base mosteneste SuperBase deci putem merge in &quot;sus&quot; in ierarhie
                                    
                                    p-&gt;Derived::g(); // EROARE
                                    // nu putem merge in &quot;jos&quot; in ierarhie
                                }
                            </div>

                            <div class="mt-5">
                               Metoda virtuala din clasa de baza nu trebuie sa fie accesibila sau vizibila neaparat ca sa fie supradefinita. Poate fi <div class="inline-code">private</div> de exemplu. <b class="text-danger">Pe langa asta se ignora faptul ca o metoda e virtuala in constructori</b>.
                            </div>

                            <div class="block-code">
                                class B {
                                private:
                                    virtual void f() { cout &lt;&lt; &quot;B&quot;; }
                                    // f e private
                                public:
                                    B() { f(); } 
                                    // in constructor se apeleaza metoda f de mai sus, nu se tine cont de virtual !
                                    // de ce? pentru ca am apela metoda f din clasa derivata inainte sa terminam de construit ce avem in clasa de baza

                                    void do_f() { f(); }
                                    // aici se apeleaza ori metoda f din clasa de baza ori cea din clasa derivata
                                    // in functie de obiectul curent
                                };
                                
                                class D : public B {
                                    void f() { cout &lt;&lt; &quot;D&quot;; }
                                };
                                
                                
                                int main()
                                {
                                    D ob;
                                    B&amp; ref = ob;
                                
                                    ref.do_f(); // D
                                }
                            </div>

                            <div class="mt-5">Ai grija ca atunci cand ai mostenire multipla, daca clasele care mostenesc virtual supradefinesc o functie, trebuie supradefinita si in clasa &quot;nepot&quot; pentru ca altfel ar exista 2 supradefiniri in clasa cea mai derivata si n-ar fi ok.</div>
                            <div class="block-code">
                                class Base {
                                public:
                                    virtual int f() const { return 5; } 
                                    // metoda e const deci trebuie sa fie const si cand supradefinesti !!
                                };
                                
                                class Derived_1 : public virtual Base {
                                public:
                                    int f() const { return 10; } 
                                };
                                
                                class Derived_2 : public virtual Base {
                                public:
                                    int f() const { return 20; }
                                };
                                
                                class MM : public Derived_1, public Derived_2{
                                public:
                                    int f() const { return 50; }
                                    // daca lipseste metoda f aici, ai eroare
                                    // ai avea aici si metoda f din Derived_1 si metoda f din Derived_2
                                    // care supradefinesc metoda f din Base deci nu se stie care e varianta finala
                                };
                                
                                int main()
                                {
                                    Base *p = new MM;
                                    cout &lt;&lt; p-&gt;f() // 50;
                                
                                    return 0;
                                }
                            </div>

                            <div class="mt-5">Daca functia din clasa derivata arata altfel (acelasi nume, lista de parametrii diferita), nu o mai supradefineste pe cea din clasa de baza, o ascunde.</div>
                            <div class="block-code">
                                class SuperBase {
                                public:
                                    virtual void f() { cout &lt;&lt; &quot;SuperBase&quot; &lt;&lt; endl; }
                                };
                                
                                class Base : public SuperBase {
                                public:
                                    void f(int) { cout &lt;&lt; &quot;Base&quot; &lt;&lt; endl; }
                                    // asta nu supradefineste, o ascunde pe cea din SuperBase
                                };
                                
                                class Derived : public Base {
                                public:
                                    void f() { cout &lt;&lt; &quot;Derived&quot; &lt;&lt; endl; }
                                    // supradefineste metoda din SuperBase
                                    // metoda de aici o ascunde si pe cea din Base
                                };
                                
                                int main()
                                {
                                    SuperBase* p1 = new SuperBase;
                                    SuperBase* p2 = new Base;
                                    SuperBase* p3 = new Derived;
                                    
                                    p1-&gt;f(); // SuperBase
                                    p2-&gt;f(); // SuperBase (pt ca in Base nu se supradefineste)
                                    p3-&gt;f(); // Derived (pt ca in Derived se supradefineste)
                                    
                                    Derived ob;
                                    ob.f(); // Derived
                                    // ob.f(2); // eroare, f(int) din Base nu e vizibila
                                    ob.Base::f(2); // acum e ok, se apeleaza explicit
                                    
                                    
                                    Base* p4 = new Base;
                                    Base* p5 = new Derived;
                                    
                                    // p4-&gt;f(); // eroare, in Base avem doar f(int)
                                    // p5-&gt;f(); // eroare, in Base avem doar f(int)
                                    
                                    p4-&gt;SuperBase::f(); // SuperBase
                                    p5-&gt;SuperBase::f(); // SuperBase (cand apelezi asa explicit nu se tine cont de virtual)
                                
                                    return 0;
                                }
                            </div>

                            <div class="mt-5">Putem avea destructori virtuali. Asta se face cand vrei sa stergi un obiect de tipul clasei derivate printr-un pointer de tipul clasei de baza. Destructorii sunt automat supradefiniti (pentru ca fiecare clasa). Daca clasa derivata nu aloca memorie pe heap, nu este necesar sa mai fie virtual.</div>
                            <div class="block-code">
                                class B {
                                public:
                                    virtual ~B() { cout &lt;&lt; &quot;~B&quot;; }
                                };
                                
                                class D : public B {
                                    int* v;
                                public:
                                    D() { v = new int[100]; }
                                    ~D() { delete[] v; cout &lt;&lt; &quot;~D&quot;; }
                                };
                                    
                                
                                int main()
                                {
                                    B* p = new D;
                                    delete p;  // ~D~B
                                    // daca destructorul din B nu ar fi virtual, nu s-ar executa destructorul din D
                                    // la delete p, pentru ca p este de tip B* (se comporta ca o metoda normala)
                                    return 0;
                                }
                            </div>

                            <div>Mai multe detalii despre functii virtuale <a href="https://docs.microsoft.com/en-us/cpp/cpp/virtual-functions?view=msvc-160">aici (de la Microsoft)</a> si <a href="https://en.cppreference.com/w/cpp/language/virtual">aici (de la cppreference)</a></div>
                        </div>
                    </article>
                </div>
            </section>

            <!-- endl -->
            <section id="endl" class="bg-altlight pt-5 mb-5">
                <div class="container">
                    <h1 class="display-2">Ce face <code>endl</code>?</h1>
                    <article id="s3-a1" class='mt-5'>
                        <h3 class='my-2 ps-2 rounded'>Fisiere si std::flush</h3>
                        <div class="article-content lead">
                            <div>
                            Sa scrii intr-un fisier dureaza, pentru ca acel fisier nu este stocat in RAM. Dureaza pana se creeaza o conexiune la harddisk sau ssd ca sa accesezi ce e pe el, asa ca in loc sa scrii cate un byte (caracter) pe rand intr-un fisier, mai bine pui mai multi intr-un loc temporar (buffer) si cand se umple, pui totul in fisier deodata. Asta se intampla si cand scrii ceva intr-un fisier (sau cand citesti) folosind <div class="inline-code">fstream</div>.
                        <div class="block-code">
                            #include &lt;iostream&gt;
                            #include &lt;fstream&gt;

                            using namespace std;

                            int main()
                            {
                                ofstream g(&quot;out.txt&quot;);
                                
                                g &lt;&lt; &quot;Hello world!&quot;;

                                return 0;
                            }
                        </div>
                        Aici <div class="inline-code">&quot;Hello world!&quot;</div> se pune intr-un buffer, un fel de array cu cateva mii de caractere, si cand se umple, continutul lui e pus in fisier (tot deodata). Asta se intampla si cand se apeleaza destructorul pentru obiectul <var>g</var> (pentru ca <var>g</var> este un obiect de tip <div class="inline-code">ofstream</div>). Acest lucru se face pentru a se goli bufferul in caz ca s-a scris ceva si nu s-a umplut bufferul. In cazul asta bufferul nu e plin, dar la sfarsitul functiei <var>main</var>, se distruge obiectul <var>g</var> si se scrie in fisier ce mai avea in buffer. Acum daca am avea o eroare dupa <div class="inline-code">g &lt;&lt; &quot;Hello world!&quot;;</div>, programul s-ar termina brusc si in fisier nu am mai avea nimic, pentru ca nici bufferul nu s-a umplut, nici destructorul nu a fost apelat.
                        <div class="block-code">
                            #include &lt;iostream&gt;
                            #include &lt;fstream&gt;

                            using namespace std;

                            int main()
                            {
                                ofstream g(&quot;out.txt&quot;);
                                
                                g &lt;&lt; &quot;Hello world!&quot;;
                                int x = 0;
                                cout &lt;&lt; 1 / x; // eroare aici
                                return 0;
                            }
                        </div>  
                        Acum o sa avem o eroare la linia 12, ca impartim la 0. Eroarea asta nu e prinsa si programul se opreste. Fisierul ramane gol (chiar daca avea ceva in el la inceput, cand creezi un obiect de tip <div class="inline-code">ofstream</div>, daca nu mai dai alte argumente constructorului, se sterge continutul mai intai). Ok dar daca avem un fisier special unde scriem niste date din program sa tinem evidenta de ceva. Daca avem eroare si nu este prinsa, fisierul nu o sa fie complet, poate ne-ar fi ajutat continutul fisierului sa gasim eroarea. 
                        </div>  
                            <div>
                                Pentru asta exista <div class="inline-code">std::flush</div>, care este un manipulator pentru operatii de output (definit in &lt;ostream&gt;), ceva gen <div class="inline-code">std::setw()</div>. Daca scrii <div class="inline-code">g &lt;&lt; &quot;Hello world!&quot; &lt;&lt; flush;</div> fortezi bufferul sa fie scris in fisier, indiferent daca e plin sau nu. Deci este scris <div class="inline-code">&quot;Hello world!&quot;</div> in fisier si dupa avem eroarea, deci la final avem in fisier string-ul. Acum, sa fortezi scrierea bufferului in fisier daca nu e plin nu este deloc eficient, tocmai de asta exista bufferul, ca sa scrii cat mai mult deodata in fisier deci trebuie folosit doar cand ai nevoie.
                            </div>
                            <div>
                                Ce treaba are asta cu <div class="inline-code">endl</div>? Poate sti ca <div class="inline-code">g &lt;&lt; endl</div> trece la urmatoarea linie, e ca si cum ai scrie <div class="inline-code">g &lt;&lt; &quot;\n&quot;;</div> <b>dar pe langa asta face si un flush!</b>, deci e echivalent cu <div class="inline-code">g &lt;&lt; &#039;\n&#039; &lt;&lt; flush;</div> (apropo, <div class="inline-code">cout &lt;&lt; &quot;\n&quot;;</div> e la fel cu <div class="inline-code">cout &lt;&lt; &#039;\n&#039;;</div> doar ca <div class="inline-code">&quot;\n&quot;</div> e un sir de caractere si <div class="inline-code">&#039;\n&#039;</div> e un caracter, deci mai bine folosesti un caracter)
                            </div>
                            <div>
                                Daca scrii multe linii in fisier si folosesti la fiecare <div class="inline-code">endl</div>, o sa ruleze mult mai incet decat daca nu ai folosi <div class="inline-code">endl</div> si ai pune <div class="inline-code">&#039;\n&#039;</div> pentru linie noua.
                                <div class="block-code">
                                    #include &lt;iostream&gt;
                                    #include &lt;fstream&gt;
                                    using namespace std;

                                    void printWithEndl() {
                                        ofstream g(&quot;out.out&quot;);
                                        for (int i = 0; i &lt; 100000; ++i) {
                                            g &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
                                        }
                                    }

                                    void printNoEndl() {
                                        ofstream g(&quot;out.out&quot;);
                                        for (int i = 0; i &lt; 100000; ++i) {
                                            g &lt;&lt; &quot;Hello world!&quot; &lt;&lt; '\n';
                                        }
                                    }

                                    int main()
                                    {
                                        printWithEndl();   // 300 ms

                                        printNoEndl();     // 18 ms
                                        return 0;
                                    }
                                </div>              
                            Functiile astea de mai sus printeaza 100000 de linii intr-un fisier. Functia care foloseste <div class="inline-code">endl</div> a durat 300ms si cea care nu foloseste a durat 18ms (am facut un test rapid pe calculatorul meu). Diferenta este mai mare de 10 ori (daca marim numarul de linii la 1 milion, diferenta e si mai drastica, 3000ms vs 130ms )
                            </div>
                            <div>
                                Deci, daca vrei ca programul tau sa ruleze mai rapid, nu mai folosi <div class="inline-code">endl</div>.
                            </div>
                        </div>
                    </article>
                </div>
            </section>


        </div>


        <!-- scrollspy -->
        <div class="col-3 col-xl-2 bg-dark d-none d-md-block">
            <nav id="scrollspy" class="navbar navbar-dark flex-column align-items-stretch px-3 sticky-top w-100">
                <a class="navbar-brand text-center" href="#">Cuprins</a>
                <nav class="nav nav-pills flex-column">
                    <a class="nav-link py-0 mt-2" href="#overloading-overriding" data-bs-dismiss="offcanvas">Supraincarcare & Supradefinire</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="ms-5 my-1 text-decoration-none" href="#function-overloading"  >Supraincarcare functii</a>
                      <a class="ms-5 my-1 text-decoration-none" href="#operator-overloading" data-bs-dismiss="offcanvas">Supraincarcare operatori</a>
                      <a class="ms-5 my-1 text-decoration-none" href="#function-overriding" data-bs-dismiss="offcanvas">Supradefinire functii</a>
                    </nav>
                    <a class="nav-link py-0 mt-2" href="#endl" data-bs-dismiss="offcanvas">Ce face <code>endl</code>?</a>
                </nav>
            </nav>
        </div>

        
    </div>
</body>
</html>