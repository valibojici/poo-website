<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- bootstrap TO DO compile just essential stuff-->
    <link href="./styles/customBootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous" defer></script>
    
    <!-- jquery -->
    <script src="./js/jquery.js" defer></script>

    <!-- bs icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.5.0/font/bootstrap-icons.min.css">

    <!-- highlightjs -->
    <link rel="stylesheet" href="./styles/vs.min.css">
    <script src="./js/highlight.min.js" defer></script>

    <!-- my stuff -->
    <script src="./js/codeblock.js" defer></script>
    <script src="./js/tips.js" defer></script>
    <link rel="stylesheet" href="./styles/tips.min.css">
    <link rel="stylesheet" href="./styles/codeblock.min.css">
    <link rel="icon" type="image/png" href="./imgs/icon.png">
    <title>InvataPOO - Tips</title>
    <meta name="description" content="La pagina Tips gasesti informatii legate de unele chestii de C++ sau POO in general">

</head>
<body data-bs-spy="scroll" data-bs-target="#scrollspy" data-bs-offset="0" tabindex="0" class="bg-altlight">

    <!-- navbar -->
    <nav id='navbar-container' class="navbar navbar-expand-lg navbar-dark bg-dark text-light py-2">
        <div class="container">
            <a class="navbar-brand" href="./index.html">&Icirc;nvață POO</a>
            
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbar">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbar">
                <ul class="navbar-nav ms-4 me-auto mb-2 mb-lg-0">
                    <li class="nav-item mx-xl-2">
                        <a class="nav-link" href="./index.html">Acasă</a>
                    </li>
                    <li class="nav-item dropdown mx-xl-2">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">Categorii probleme</a>
                        <ul class="dropdown-menu dropdown-menu-dark">
                            <li><a class="dropdown-item" href="./problem.html?t=easy">Usor</a></li>
                            <li><a class="dropdown-item" href="./problem.html?t=medium">Mediu</a></li>
                            <li><a class="dropdown-item" href="./problem.html?t=hard">Greu</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="./problem.html?order=random">Random</a></li>
                        </ul>
                    </li>
                    <li class="nav-item mx-xl-2">
                        <a class="nav-link" href="./tips.html">Tips</a>
                    </li>
                    <li class="nav-item mx-xl-2">
                        <a class="nav-link" href="./index.html#contact" >Contact</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- offcanvas --> 
    <div class="offcanvas offcanvas-start bg-dark d-block d-md-none" data-bs-scroll="true" tabindex="-1" id="offcanvas">
        <div class="offcanvas-header px-4 pt-4 pb-0">
            <h5 class="offcanvas-title text-light text-center flex-grow-1" id="offcanvasLabel">Cuprins</h5>
            <button type="button" class="btn-close btn-close-white text-reset p-0 m-0" data-bs-dismiss="offcanvas"></button>
        </div>
        <div class="offcanvas-body px-0 px-sm-3 pt-0">
            <nav id="offcanvas-nav" class="navbar navbar-dark bg-dark flex-column align-items-stretch px-3 sticky-top w-100">
                <nav class="nav nav-pills flex-column align-items-start">
                  <a class="nav-link py-0 mt-2" href="#overloading-overriding" data-bs-dismiss="offcanvas">Supraincarcare & Supradefinire</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="ms-5 mt-2 text-decoration-none" href="#function-overloading"  >Supraincarcare functii</a>
                    <a class="ms-5 mt-2 text-decoration-none" href="#operator-overloading" data-bs-dismiss="offcanvas">Supraincarcare operatori</a>
                    <a class="ms-5 mt-2 text-decoration-none" href="#function-overriding" data-bs-dismiss="offcanvas">Supradefinire functii</a>
                  </nav>
                  <a class="nav-link py-0 mt-2" href="#endl" data-bs-dismiss="offcanvas">Ce face <code>endl</code>?</a>
                </nav>
            </nav>
        </div>
    </div>

    <!-- button offcanvas -->
    <a id='offcanvas-btn' class="btn btn-outline-secondary px-0 d-block d-md-none" data-bs-toggle="offcanvas" href="#offcanvas" role="button" >
        Cuprins
    </a>

    <div class="row g-0" >
        <div class="content col col-md-9 col-xl-10 px-2 px-sm-3 px-md-4 px-xll-0">
            
            <!-- overloading overriding -->
            <section id="overloading-overriding" class="bg-altlight pt-5 my-5">
                <div class="container">
                    <h1 class="display-3">Supraincarcare (overloading) & supradefinire (overriding)</h1>
        
                    <article id="function-overloading" class="mt-5">
                        <h3 class='my-2 ps-2 rounded'>Supraincarcare functii</h3>
                        <div class="article-content lead">
                            <div>
                                In C++ putem avea mai multe functii cu acelasi nume dar trebuie ca parametrii ori sa fie de tipuri diferite, ori sa difere numarul de parametrii, ori parametrii sa fie in alta ordine (ma refer la tipul lor de ex. <div class="inline-code">int, int, float</div> si <div class="inline-code">float, int, int</div> nu la denumire, asta nu conteaza). De exemplu:
                                <div class="block-code">           
                                    void f(int x) {}            // numar diferit de parametrii fata de functiile de mai jos
                                    void f(int x, float y) {}   // difera ordinea tipurilor parametriilor fata de functia de mai jos
                                    void f(float x, int y) {}
                                </div>
                            </div>
                            <div>
                                Totusi ai grija la parametrii cu valori implicite, de exemplu mai jos avem eroare pentru ca apelul de functie este ambiguu, nu se stie care functie sa se aleaga.
                                <div class="block-code">
                                    #include &lt;iostream&gt;
                                    using namespace std;

                                    void f(int x) {}
                                    void f(int x, int y = 4) {}

                                    int main() {
                                        f(5); // eroare aici
                                    }
                                </div>
                            </div>
                        <div>
                            Tehnic vorbind functiile trebuie sa aiba signaturi diferite. Signatura se refera la numele functiei, numarul, ordinea si tipul parametrilor.
                        </div>
                        <div>
                            <div>Daca avem ceva de genul:</div>
                            <div class="block-code">
                                #include &lt;iostream&gt;
                                using namespace std;

                                void f(int x, int y) {}
                                void f(double x, int y) {}

                                int main() {
                                    f(2, 2.3);
                                }
                            </div>
                            <div>Cum se alege ce functie se apeleaza? Compilatorul se uita pe rand la fiecare argument si creaza o multime de functii candidat pentru fiecare argument, adica tipul argumentului (cand apelezi functia) se poate converti (cumva) in tipul parametrului (in definitia functiei). Pentru fiecare argument se creeaza o multime de functii care se potrivesc cel mai bine (chiar daca exista multe functii canditat unele fac mai multa &quot;treaba&quot; decat altele sa converteasca, de aceea se aleg cele care se potrivesc cel mai bine). Din multimile astea de functii care se potrivesc cel mai bine pentru fiecare argument se face o intersectie si functia rezultata este cea care se apeleaza. Daca intersectia e vida sau contine mai mult de 1 functie avem eroare de compilare.</div>
                        </div>

                        <div>
                            <div>De exemplu:</div>
                            <div class="block-code">
                                #include &lt;iostream&gt;
                                using namespace std;

                                class MyClass {
                                    // o clasa goala pentru exemplu
                                };

                                void f(MyClass x, long long y) {}   // functia 1
                                void f(long long x, MyClass y) {}   // functia 2
                                void f(MyClass x, MyClass y) {}     // functia 3

                                int main() {
                                    int x = 4;
                                    MyClass y;

                                    f(x, y);
                                    f(x, x);
                                }
                            </div>
                            <div>
                                Sa ne uitam la linia 16: <div class="inline-code">f(x, y);</div>. Mai intai la primul argument de tip <div class="inline-code">MyClass</div>, multimea functiilor candidat = {functia 1, functia 2},multimea functiilor care ce potrivesc cel mai bine = {functia 1, functia 2}. Acum sa ne uitam la al doilea argument de tip <div class="inline-code">int</div>, multimea functiilor candidat = multimea functiilor care se potrivesc cel mai bine = {functia 1} (pentru ca se poate converti <div class="inline-code">int</div> in <div class="inline-code">long long</div> ).
                            </div>
                        </div>
                        <div>
                            {functia 1, functia 2} ∩ {functia 1} = {functia 1}. Asta inseamna ca in final pentru <div class="inline-code">f(x, y);</div> se apeleaza functia 1.
                        </div>
                        <div>
                            Daca ne uitam la linia 17: <div class="inline-code">f(x, x);</div>, pentru primul argument multimea functiilor care se potrivesc cel mai bine = {functia 2}, pentru al doilea argument multimea functiilor care se potrivesc cel mai bine = {functia 1}, iar {functia 2} ∩ {functia 1} = Ø si deci eroare.
                        </div>

                        <div>
                            In general daca avem o functie care e supraincarcata si avem doua variante F1 si F2, cum alege compilatorul functia care se potriveste cel mai bine? Functia F1 este mai &quot;buna&quot; decat F2 daca in primul rand conversiile implicite pe care le face F1 (de la tipul argumentelor la tipul parametrilor) nu sunt mai rele decat cele facute de F2 (pt. fiecare argument) si in plus:
                            <ol class="">
                                <li>E cel putin un argument in F1 a carui conversie implicita este mai buna decat conversia implicita pentru acel argument in F2</li>
                                <li>Sau daca nu e asa, dar doar in cazul conversiilor definite de tine (gen operatorul de cast intr-o clasa), daca conversia implicita de la tipul returnat de F1 la tipul destinatie este mai buna decat conversia implicita de la tipul returnat de F2 la tipul destinatie.
                                    <div class="block-code">
                                        class MyClass {
                                        public:
                                            operator float() { return 5.5; }
                                            operator int() { return 1; }
                                        };

                                        int main() {
                                            MyClass a;
                                            double x = a;   // se apeleza prima functie vezi mai jos de ce
                                            cout &lt;&lt; x;      // se afiseaza 5.5
                                        }
                                    </div>
                                </li>
                                <li>Sau daca nu e asa, F1 este non-template iar F2 este template sau ambele sunt template dar F1 este mai specializata (dar despre template vorbesc separat).</li>
                            </ol>
                        </div>

                        <div>
                            Acum ce inseamna ca o conversie e mai buna decat alta? Exista 3 tipuri (in ordinea importantei):
                            <ol>
                                <li class="mt-4">
                                    <h5>Exact match</h5>
                                    <div>Nu trebuie sa se faca nicio &quot;conversie&quot; sau daca se face se considera exact match.
                                        <div class="block-code">
                                            void f(int& x);
                                            void f(double x);
                                            int x = 42;
                                            f(x); // argument type is int; exact match with int&

                                            /////////////////////////////////////////

                                            void g(int* p);
                                            void g(void* p);

                                            int a[100];
                                            g(a); // calls f(int*); exact match with array-to-pointer conversion
                                    </div>
                                    </div>
                                </li>
                                <li class="mt-4">
                                    <h5>Promotion</h5>
                                    <div>Aici intra <i>integral promotion</i> si <i>floating-point promotion</i>. Promotia e un tip special de conversie pentru tipurile de date built-in (<div class="inline-code">int</div>, <div class="inline-code">float</div> etc.) si este garantat ca nu schimba valoarea. (adica tipul de date la care se converteste poate reprezenta exact orice valoare a tipului de date de la care se converteste)</div>
                                    <div class="text-decoration-underline">Integral promotion</div>
                                    <ul>
                                        <li><div class="inline-code">signed char</div> sau <div class="inline-code">signed short</div> se pot converti la <div class="inline-code">int</div></li>
                                        <li><div class="inline-code">unsigned char</div> sau <div class="inline-code">unsigned short</div> se pot converti la <div class="inline-code">int</div> daca <div class="inline-code">int</div> poate retine toate valorile sau la <div class="inline-code">unsigned int</div> daca nu poate. (e posibil ca short/char si int sa aiba acelasi nr. de biti pe un calculator si de aceea nu poti din unsigned short/char in int) </li>
                                        <li><div class="inline-code">char</div> se poate converti la <div class="inline-code">int</div> sau <div class="inline-code">unsigned int</div> (depinde daca prin <div class="inline-code">char</div> te referi la <div class="inline-code">signed char</div> sau <div class="inline-code">unsigned char</div>)</li>
                                        <li><div class="inline-code">bool</div> se poate converti la <div class="inline-code">int</div>, <div class="inline-code">false</div> devine <div class="inline-code">0</div> iar <div class="inline-code">true</div> devine <div class="inline-code">1</div></li>
                                    </ul>
                                    <div class="text-decoration-underline">Floating-point promotion</div>
                                    <ul>
                                        <li>Se refera doar la conversia de la <div class="inline-code">float</div> la <div class="inline-code">double</div>.</li>
                                    </ul>
                                </li>
                                <li class="mt-4">
                                    <h5>Conversion</h5>
                                    <div>
                                        Aici intra <i>integral conversion</i>, <i>floating-point conversion</i>, <i>floating-integral conversion</i>, <i>bool conversion</i>
                                    </div>
                                    <div class="text-decoration-underline">Integral conversion</div>
                                    <ul>
                                        <li>aici intra conversii dintre 2 tipuri de date ce reprezinta nr. intregi dar <b>nu</b> e promotion, de exemplu din <div class="inline-code">int</div> in <div class="inline-code">long</div> sau din <div class="inline-code">unsigned short</div> in <div class="inline-code">short</div> </li>
                                    </ul>
                                    <div class="text-decoration-underline">Floating-point conversion</div>
                                    <ul>
                                        <li>aici intra conversii dintre 2 tipuri de date ce reprezinta nr. cu virgula dar <b>nu</b> e promotion, de exemplu din <div class="inline-code">double</div> in <div class="inline-code">float</div> sau din <div class="inline-code">float</div> in <div class="inline-code">long double</div>
                                        <div>
                                            <div class="block-code">
                                                void f(double);
                                                void f(long double);
                                                f(0.0f);
                                            </div>
                                            Se apeleaza prima functie pentru ca promotia (de la <div class="inline-code">float</div> la <div class="inline-code">double</div>) este mai buna decat conversia (de la <div class="inline-code">float</div> la  <div class="inline-code">long double</div>)
                                        </div>
                                        </li>
                                    </ul>
                                    <div class="text-decoration-underline">Floating-integral conversion</div>
                                    <ul>
                                        <li>aici intra conversii dintre un tip de date ce reprezinta nr. cu virgula si un tip de date care reprezinta nr. intregi de exemplu din <div class="inline-code">double</div> in <div class="inline-code">int</div> sau din <div class="inline-code">int</div> in <div class="inline-code">float</div>
                                        <div>
                                            <div class="block-code">
                                                void f(int);
                                                void f(long double);
                                                f(0.0f);
                                            </div>
                                            Eroare de compilare, apelul este ambiguu, avem 2 conversii (de la <div class="inline-code">float</div> la <div class="inline-code">int</div> si de la <div class="inline-code">float</div> la  <div class="inline-code">long double</div>  )
                                        </div>
                                        </li>
                                    </ul>
                                    <div class="text-decoration-underline">Bool conversion</div>
                                    <ul>
                                        <li>de exemplu din <div class="inline-code">int</div> in <div class="inline-code">bool</div> sau din <div class="inline-code">float</div> in <div class="inline-code">bool</div>. (de ex. <div class="inline-code">bool x = 5; // true</div> )
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                    <div>
                        <h3>Surse</h3>
                        <ul>
                            <li><a href="https://en.cppreference.com/w/c/language/conversion">https://en.cppreference.com/w/c/language/conversion</a></li>
                            <li><a href="https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions?view=msvc-160">https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions?view=msvc-160</a></li>
                            <li><a href="https://stackoverflow.com/questions/30490592/no-really-when-does-floating-point-promotion-actually-happen">https://stackoverflow.com/questions/30490592/no-really-when-does-floating-point-promotion-actually-happen</a></li>
                            <li><a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">https://en.cppreference.com/w/cpp/language/implicit_conversion</a></li>
                            <li><a href="https://riptutorial.com/cplusplus/example/8117/steps-of-overload-resolution">https://riptutorial.com/cplusplus/example/8117/steps-of-overload-resolution</a></li>
                            <li><a href="https://riptutorial.com/cplusplus/example/6616/exact-match">https://riptutorial.com/cplusplus/example/6616/exact-match</a></li>
                            <li><a href="https://en.cppreference.com/w/cpp/language/overload_resolution">https://en.cppreference.com/w/cpp/language/overload_resolution</a></li>
                        </ul>
                    </div>
                    </article>
        
                    <article id="operator-overloading" class='mt-5'>
                        <h3 class='my-2 ps-2 rounded'>Supraincarcare operatori</h3>
                        <div class="article-content lead">
                            <ol class="">
                                <li>Majoritatea operatorilor din C++ pot fi supraincarcati (ori ca functii membre intr-o clasa ori ca functii prieten, insa unii pot fi DOAR functii membre).</li>
                                <li>Nu poti fi supraincarcati: <div class="inline-code">.  .*  ::  ?: sizeof</div> (da, <div class="inline-code">sizeof</div> e un operator, nu functie).</li>
                                <li>Nu poti modifica precedenta operatorilor sau numarul de argumente pe care le primesc.</li>
                                <li><b>Toti operatorii care pot fi supraincarcati NU pot avea parametrii default, exceptie face <div class="inline-code">()</div></b> (operatorul &apos;apel de functie&apos;).</li>
                                <li><b>Toti operatorii supraincarcati intr-o clasa de baza sunt mosteniti de clasa derivata, <span class='text-danger'>cu exceptia</span> <div class="inline-code">=</div></b> (operatorul de atribuire).</li>
                                <li><b>Operatorii <div class="inline-code">=</div> <div class="inline-code">()</div> <div class="inline-code">[]</div> <div class="inline-code">-></div> trebuie declarati ca functii membre ale unei clase (nu merge sa fie functii prieten).</b> </li>
                            </ol>
                            <div>Mai multe informatii despre supraincarcarea operatorilor <a href="http://isocpp.org/wiki/faq/operator-overloading">sunt aici</a>.</div>
                        </div>
                    </article>
        
                    <article id="function-overriding" class='mt-5'>
                        <h3 class='my-2 ps-2 rounded'>Supradefinire functii</h3>
                        <div class="article-content lead">Lorem ipsum dolor, sit amet consectetur adipisicing elit. Deleniti, eius provident quos molestiae repellendus eos quibusdam deserunt! Dicta temporibus mollitia voluptate eveniet saepe repellendus debitis praesentium officia vel nam? Commodi assumenda, culpa animi suscipit eveniet labore et, ex error eos voluptatibus nemo cupiditate nihil quasi voluptatum quisquam id quidem at mollitia amet voluptates unde facere provident. Maxime quis voluptatibus, excepturi obcaecati perferendis voluptate. Obcaecati, iste commodi. Quasi ducimus nostrum quae veniam assumenda optio excepturi libero. Odit laborum deserunt voluptates impedit aperiam soluta ut fugiat atque nobis asperiores laboriosam natus culpa aliquam ipsa consequuntur possimus, rerum praesentium iste voluptatum non modi repudiandae aut quia quod. Voluptatem ipsa quo provident exercitationem tempora consectetur veritatis. Ea unde, adipisci deleniti, quo quod laudantium, in incidunt illum eum labore explicabo vero. Non distinctio ullam, repellat impedit cupiditate error aperiam libero quibusdam saepe nostrum ad ea dicta, praesentium sint in iste aspernatur fugiat veniam repudiandae id! Deserunt at nemo deleniti minima minus commodi est asperiores nam odio labore dolorem iusto vel pariatur, modi aut quis amet veritatis rem culpa molestiae, illo repellendus? Quod rerum vero dicta ab voluptatem obcaecati exercitationem. Ut ipsam voluptatem animi. Pariatur sunt quibusdam repudiandae culpa aliquid, quos, asperiores hic minima ipsam optio esse eum nesciunt voluptatum placeat corrupti nisi quo commodi quod ab nam illo minus facilis assumenda? Perspiciatis vero voluptates voluptas rerum optio similique, illum odit suscipit quo eaque cum quas possimus officiis, impedit, eos consectetur. Voluptates ipsam ab eaque a. In quis, alias eligendi minima dolorum recusandae numquam cumque accusantium, labore perferendis sit, incidunt dolores inventore iure modi soluta ab! Ab velit odit modi deserunt consequatur, voluptatum eum quaerat cum tempore, unde delectus in. Vero facilis officia ipsum aliquam rem similique, accusantium quo? Reprehenderit incidunt doloremque aliquam animi beatae illo voluptates, odio officiis corporis eos expedita quia quis natus debitis. Dolor nulla inventore iusto itaque nesciunt ab architecto nisi rerum sapiente exercitationem assumenda, commodi repudiandae, voluptatem aut rem molestias expedita! Laborum illum quibusdam architecto dolores facilis fugiat adipisci dicta? Aut deleniti a minus officia ad eum optio unde voluptatum dolore! Rerum sed quibusdam maxime minima praesentium nisi magnam nam, eos culpa fugit, perferendis quasi voluptates expedita illum deleniti error animi unde. Debitis labore aliquam rerum repellat voluptates accusantium hic aliquid suscipit cumque, at excepturi sequi consequatur ex nesciunt. Harum non cupiditate numquam quas nulla, nisi earum cumque delectus aspernatur soluta quos perspiciatis tempora qui eveniet molestiae, odio asperiores error eius eum doloribus nostrum quaerat? Iure, non ipsa. Id iusto cumque architecto fuga consequatur doloribus labore dolor beatae repellat ipsum quae eaque at vitae, veniam, enim pariatur quibusdam aliquid vero incidunt. Ducimus soluta non quidem odio quo. Iure accusantium vel assumenda ratione cum modi provident voluptatum, fuga labore debitis vero eveniet consequatur minus voluptas totam dicta explicabo dolorem dignissimos iste maxime laudantium distinctio similique minima rerum! Perferendis, amet quaerat doloremque quis omnis necessitatibus rem, quod excepturi eveniet ex inventore voluptatibus delectus aspernatur sequi fuga vel doloribus, officia corrupti ducimus iure. Impedit quia omnis itaque doloremque temporibus veritatis, quae est consequuntur aspernatur!</div>
                    </article>
                </div>
            </section>

            <!-- endl -->
            <section id="endl" class="bg-altlight pt-5 mb-5">
                <div class="container">
                    <h1 class="display-2">Ce face <code>endl</code>?</h1>
                    <article id="s3-a1" class='mt-5'>
                        <div class="article-content lead">
                            <div>
                            Sa scrii intr-un fisier dureaza, pentru ca acel fisier nu este stocat in RAM. Dureaza pana se creeaza o conexiune la harddisk sau ssd ca sa accesezi ce e pe el, asa ca in loc sa scrii cate un byte (caracter) pe rand intr-un fisier, mai bine pui mai multi intr-un loc temporar (buffer) si cand se umple, pui totul in fisier deodata. Asta se intampla si cand scrii ceva intr-un fisier (sau cand citesti) folosind <div class="inline-code">fstream</div>.
                        <div class="block-code">
                            #include &lt;iostream&gt;
                            #include &lt;fstream&gt;

                            using namespace std;

                            int main()
                            {
                                ofstream g(&quot;out.txt&quot;);
                                
                                g &lt;&lt; &quot;Hello world!&quot;;

                                return 0;
                            }
                        </div>
                        Aici <div class="inline-code">&quot;Hello world!&quot;</div> se pune intr-un buffer, un fel de array cu cateva mii de caractere, si cand se umple, continutul lui e pus in fisier (tot deodata). Asta se intampla si cand se apeleaza destructorul pentru obiectul <var>g</var> (pentru ca <var>g</var> este un obiect de tip <div class="inline-code">ofstream</div>). Acest lucru se face pentru a se goli bufferul in caz ca s-a scris ceva si nu s-a umplut bufferul. In cazul asta bufferul nu e plin, dar la sfarsitul functiei <var>main</var>, se distruge obiectul <var>g</var> si se scrie in fisier ce mai avea in buffer. Acum daca am avea o eroare dupa <div class="inline-code">g &lt;&lt; &quot;Hello world!&quot;;</div>, programul s-ar termina brusc si in fisier nu am mai avea nimic, pentru ca nici bufferul nu s-a umplut, nici destructorul nu a fost apelat.
                        <div class="block-code">
                            #include &lt;iostream&gt;
                            #include &lt;fstream&gt;

                            using namespace std;

                            int main()
                            {
                                ofstream g(&quot;out.txt&quot;);
                                
                                g &lt;&lt; &quot;Hello world!&quot;;
                                int x = 0;
                                cout &lt;&lt; 1 / x; // eroare aici
                                return 0;
                            }
                        </div>  
                        Acum o sa avem o eroare la linia 12, ca impartim la 0. Eroarea asta nu e prinsa si programul se opreste. Fisierul ramane gol (chiar daca avea ceva in el la inceput, cand creezi un obiect de tip <div class="inline-code">ofstream</div>, daca nu mai dai alte argumente constructorului, se sterge continutul mai intai). Ok dar daca avem un fisier special unde scriem niste date din program sa tinem evidenta de ceva. Daca avem eroare si nu este prinsa, fisierul nu o sa fie complet, poate ne-ar fi ajutat continutul fisierului sa gasim eroarea. 
                        </div>  
                            <div>
                                Pentru asta exista <div class="inline-code">std::flush</div>, care este un manipulator pentru operatii de output (definit in &lt;ostream&gt;), ceva gen <div class="inline-code">std::setw()</div>. Daca scrii <div class="inline-code">g &lt;&lt; &quot;Hello world!&quot; &lt;&lt; flush;</div> fortezi bufferul sa fie scris in fisier, indiferent daca e plin sau nu. Deci este scris <div class="inline-code">&quot;Hello world!&quot;</div> in fisier si dupa avem eroarea, deci la final avem in fisier string-ul. Acum, sa fortezi scrierea bufferului in fisier daca nu e plin nu este deloc eficient, tocmai de asta exista bufferul, ca sa scrii cat mai mult deodata in fisier deci trebuie folosit doar cand ai nevoie.
                            </div>
                            <div>
                                Ce treaba are asta cu <div class="inline-code">endl</div>? Poate sti ca <div class="inline-code">g &lt;&lt; endl</div> trece la urmatoarea linie, e ca si cum ai scrie <div class="inline-code">g &lt;&lt; &quot;\n&quot;;</div> <b>dar pe langa asta face si un flush!</b>, deci e echivalent cu <div class="inline-code">g &lt;&lt; &#039;\n&#039; &lt;&lt; flush;</div> (apropo, <div class="inline-code">cout &lt;&lt; &quot;\n&quot;;</div> e la fel cu <div class="inline-code">cout &lt;&lt; &#039;\n&#039;;</div> doar ca <div class="inline-code">&quot;\n&quot;</div> e un sir de caractere si <div class="inline-code">&#039;\n&#039;</div> e un caracter, deci mai bine folosesti un caracter)
                            </div>
                            <div>
                                Daca scrii multe linii in fisier si folosesti la fiecare <div class="inline-code">endl</div>, o sa ruleze mult mai incet decat daca nu ai folosi <div class="inline-code">endl</div> si ai pune <div class="inline-code">&#039;\n&#039;</div> pentru linie noua.
                                <div class="block-code">
                                    #include &lt;iostream&gt;
                                    #include &lt;fstream&gt;
                                    using namespace std;

                                    void printWithEndl() {
                                        ofstream g(&quot;out.out&quot;);
                                        for (int i = 0; i &lt; 100000; ++i) {
                                            g &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
                                        }
                                    }

                                    void printNoEndl() {
                                        ofstream g(&quot;out.out&quot;);
                                        for (int i = 0; i &lt; 100000; ++i) {
                                            g &lt;&lt; &quot;Hello world!&quot; &lt;&lt; '\n';
                                        }
                                    }

                                    int main()
                                    {
                                        printWithEndl();   // 300 ms

                                        printNoEndl();     // 18 ms
                                        return 0;
                                    }
                                </div>              
                            Functiile astea de mai sus printeaza 100000 de linii intr-un fisier. Functia care foloseste <div class="inline-code">endl</div> a durat 300ms si cea care nu foloseste a durat 18ms (am facut un test rapid pe calculatorul meu). Diferenta este mai mare de 10 ori (daca marim numarul de linii la 1 milion, diferenta e si mai drastica, 3000ms vs 130ms )
                            </div>
                            <div>
                                Deci, daca vrei ca programul tau sa ruleze mai rapid, nu mai folosi <div class="inline-code">endl</div>.
                            </div>
                        </div>
                    </article>
                </div>
            </section>


        </div>


        <!-- scrollspy -->
        <div class="col-3 col-xl-2 bg-dark d-none d-md-block">
            <nav id="scrollspy" class="navbar navbar-dark flex-column align-items-stretch px-3 sticky-top w-100">
                <a class="navbar-brand text-center" href="#">Cuprins</a>
                <nav class="nav nav-pills flex-column">
                    <a class="nav-link py-0 mt-2" href="#overloading-overriding" data-bs-dismiss="offcanvas">Supraincarcare & Supradefinire</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="ms-5 my-1 text-decoration-none" href="#function-overloading"  >Supraincarcare functii</a>
                      <a class="ms-5 my-1 text-decoration-none" href="#operator-overloading" data-bs-dismiss="offcanvas">Supraincarcare operatori</a>
                      <a class="ms-5 my-1 text-decoration-none" href="#function-overriding" data-bs-dismiss="offcanvas">Supradefinire functii</a>
                    </nav>
                    <a class="nav-link py-0 mt-2" href="#endl" data-bs-dismiss="offcanvas">Ce face <code>endl</code>?</a>
                </nav>
            </nav>
        </div>

        
    </div>
</body>
</html>