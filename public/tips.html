<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- bootstrap TO DO compile just essential stuff-->
    <link href="./styles/customBootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous" defer></script>
    
    <!-- jquery -->
    <script src="./js/jquery.js" defer></script>

    <!-- bs icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.5.0/font/bootstrap-icons.min.css">

    <!-- highlightjs -->
    <link rel="stylesheet" href="./styles/vs.min.css">
    <script src="./js/highlight.min.js" defer></script>

    <!-- my stuff -->
    <script src="./js/codeblock.js" defer></script>
    <script src="./js/tips.js" defer></script>
    <link rel="stylesheet" href="./styles/tips.min.css">
    <link rel="stylesheet" href="./styles/codeblock.min.css">
    <link rel="icon" type="image/png" href="./imgs/icon.png">
    <title>InvataPOO - Tips</title>
    <meta name="description" content="La pagina Tips gasesti informatii legate de unele chestii de C++ sau POO in general">

</head>
<body data-bs-spy="scroll" data-bs-target="#scrollspy" data-bs-offset="0" tabindex="0" class="bg-altlight">

    <!-- navbar -->
    <nav id='navbar-container' class="navbar navbar-expand-lg navbar-dark bg-dark text-light py-2">
        <div class="container">
            <a class="navbar-brand" href="./index.html">&Icirc;nvață POO</a>
            
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbar">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbar">
                <ul class="navbar-nav ms-4 me-auto mb-2 mb-lg-0">
                    <li class="nav-item mx-xl-2">
                        <a class="nav-link" href="./index.html">Acasă</a>
                    </li>
                    <li class="nav-item dropdown mx-xl-2">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">Categorii probleme</a>
                        <ul class="dropdown-menu dropdown-menu-dark">
                            <li><a class="dropdown-item" href="./problem.html?t=easy">Usor</a></li>
                            <li><a class="dropdown-item" href="./problem.html?t=medium">Mediu</a></li>
                            <li><a class="dropdown-item" href="./problem.html?t=hard">Greu</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="./problem.html?order=random">Random</a></li>
                        </ul>
                    </li>
                    <li class="nav-item mx-xl-2">
                        <a class="nav-link" href="./tips.html">Tips</a>
                    </li>
                    <li class="nav-item mx-xl-2">
                        <a class="nav-link" href="./index.html#contact" >Contact</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- offcanvas --> 
    <div class="offcanvas offcanvas-start bg-dark d-block d-md-none" data-bs-scroll="true" tabindex="-1" id="offcanvas">
        <div class="offcanvas-header px-4 pt-4 pb-0">
            <h5 class="offcanvas-title text-light text-center flex-grow-1" id="offcanvasLabel">Cuprins</h5>
            <button type="button" class="btn-close btn-close-white text-reset p-0 m-0" data-bs-dismiss="offcanvas"></button>
        </div>
        <div class="offcanvas-body px-0 px-sm-3 pt-0">
            <nav id="offcanvas-nav" class="navbar navbar-dark bg-dark flex-column align-items-stretch px-3 sticky-top w-100">
                <nav class="nav nav-pills flex-column align-items-start">
                  <a class="nav-link py-0 mt-2" href="#overloading-overriding" data-bs-dismiss="offcanvas">Supraincarcare & Supradefinire</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="ms-5 mt-2 text-decoration-none" href="#function-overloading"  >Supraincarcare functii</a>
                    <a class="ms-5 mt-2 text-decoration-none" href="#operator-overloading" data-bs-dismiss="offcanvas">Supraincarcare operatori</a>
                    <a class="ms-5 mt-2 text-decoration-none" href="#function-overriding" data-bs-dismiss="offcanvas">Supradefinire functii</a>
                  </nav>
                  <a class="nav-link py-0 mt-2" href="#endl" data-bs-dismiss="offcanvas">Ce face <code>endl</code>?</a>
                </nav>
            </nav>
        </div>
    </div>

    <!-- button offcanvas -->
    <a id='offcanvas-btn' class="btn btn-outline-secondary px-0 d-block d-md-none" data-bs-toggle="offcanvas" href="#offcanvas" role="button" >
        Cuprins
    </a>

    <div class="row g-0" >
        <div class="content col col-md-9 col-xl-10 px-2 px-sm-3 px-md-4 px-xll-0">
            
            <!-- overloading overriding -->
            <section id="overloading-overriding" class="bg-altlight pt-5 mb-5">
                <div class="container">
                    <h1 class="display-3">Supraincarcare (overloading) & supradefinire (overriding)</h1>
        
                    <article id="function-overloading" class="mt-4">
                        <h3 class='my-2 ps-2 rounded'>Supraincarcare functii</h3>
                        <div class="article-content lead">
                            <div>
                                In C++ putem avea mai multe functii cu acelasi nume dar trebuie ca parametrii ori sa fie de tipuri diferite, ori sa difere numarul de parametrii, ori parametrii sa fie in alta ordine (ma refer la tipul lor de ex. <pre class="inline"><code>int, int, float</code></pre> si <pre class="inline"><code>float, int, int</code></pre> nu la denumire, asta nu conteaza). De exemplu:
                                <pre class="block"><code class="language-cpp">void f(int x) {}            // numar diferit de parametrii fata de functiile de mai jos
void f(int x, float y) {}   // difera ordinea tipurilor parametriilor fata de functia de mai jos
void f(float x, int y) {}</code></pre>
                            </div>
                            <div>
                                Totusi ai grija la parametrii cu valori implicite, de exemplu mai jos avem eroare pentru ca apelul de functie este ambiguu, nu se stie care functie sa se aleaga.
                                <pre class="block"><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void f(int x) {}
void f(int x, int y = 4) {}

int main() {
    f(5); // eroare aici
}</code></pre>
                            </div>
                        <div>
                            Tehnic vorbind functiile trebuie sa aiba signaturi diferite. Signatura se refera la numele functiei, numarul, ordinea si tipul parametrilor.
                        </div>
                        <div>
                            Daca avem ceva de genul:
                            <pre class="block"><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void f(int x, int y) {}
void f(double x, int y) {}

int main() {
    f(2, 2.3);
}</code></pre>
                    Cum se alege ce functie se apeleaza? Compilatorul se uita pe rand la fiecare argument si creaza o multime de functii candidat pentru fiecare argument, adica tipul argumentului (cand apelezi functia) se poate converti (cumva) in tipul parametrului (in definitia functiei). Pentru fiecare argument se creeaza o multime de functii care se potrivesc cel mai bine (chiar daca exista multe functii canditat unele fac mai multa &quot;treaba&quot; decat altele sa converteasca, de aceea se aleg cele care se potrivesc cel mai bine). Din multimile astea de functii care se potrivesc cel mai bine pentru fiecare argument se face o intersectie si functia rezultata este cea care se apeleaza. Daca intersectia e vida sau contine mai mult de 1 functie avem eroare de compilare.
                        </div>

                        <div>
                            De exemplu:
                            <pre class="block"><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class MyClass {
    // o clasa goala pentru exemplu
};

void f(MyClass x, long long y) {}   // functia 1
void f(long long x, MyClass y) {}   // functia 2
void f(MyClass x, MyClass y) {}     // functia 3

int main() {
    int x = 4;
    MyClass y;

    f(x, y);
    f(x, x);
}</code></pre>
                            Sa ne uitam la linia 16: <pre class="inline"><code>f(x, y);</code></pre>. Mai intai la primul argument de tip <pre class="inline"><code>MyClass</code></pre>, multimea functiilor candidat = {functia 1, functia 2},multimea functiilor care ce potrivesc cel mai bine = {functia 1, functia 2}. Acum sa ne uitam la al doilea argument de tip <pre class="inline"><code>int</code></pre>, multimea functiilor candidat = multimea functiilor care se potrivesc cel mai bine = {functia 1} (pentru ca se poate converti <pre class="inline"><code>int</code></pre> in <pre class="inline"><code>long long</code></pre> ).
                        </div>
                        <div>
                            {functia 1, functia 2} ∩ {functia 1} = {functia 1}. Asta inseamna ca in final pentru <pre class="inline"><code>f(x, y);</code></pre> se apeleaza functia 1.
                        </div>
                        <div>
                            Daca ne uitam la linia 17: <pre class="inline"><code>f(x, x);</code></pre>, pentru primul argument multimea functiilor care se potrivesc cel mai bine = {functia 2}, pentru al doilea argument multimea functiilor care se potrivesc cel mai bine = {functia 1}, iar {functia 2} ∩ {functia 1} = Ø si deci eroare.
                        </div>

                        <div>
                            In general daca avem o functie care e supraincarcata si avem doua variante F1 si F2, cum alege compilatorul functia care se potriveste cel mai bine? Functia F1 este mai &quot;buna&quot; decat F2 daca in primul rand conversiile implicite pe care le face F1 (de la tipul argumentelor la tipul parametrilor) nu sunt mai rele decat cele facute de F2 (pt. fiecare argument) si in plus:
                            <ol class="">
                                <li>E cel putin un argument in F1 a carui conversie implicita este mai buna decat conversia implicita pentru acel argument in F2</li>
                                <li>Sau daca nu e asa, dar doar in cazul conversiilor definite de tine (gen operatorul de cast intr-o clasa), daca conversia implicita de la tipul returnat de F1 la tipul destinatie este mai buna decat conversia implicita de la tipul returnat de F2 la tipul destinatie.
                                    <pre class="block"><code>class MyClass {
public:
    operator float() { return 5.5; }
    operator int() { return 1; }
};

int main() {
    MyClass a;
    double x = a;   // se apeleza prima functie vezi mai jos de ce
    cout &lt;&lt; x;      // se afiseaza 5.5
}
                                    </code></pre>
                                </li>
                                <li>Sau daca nu e asa, F1 este non-template iar F2 este template sau ambele sunt template dar F1 este mai specializata (dar despre template vorbesc separat).</li>
                            </ol>
                        </div>

                        <div>
                            Acum ce inseamna ca o conversie e mai buna decat alta? Exista 3 tipuri (in ordinea importantei):
                            <ol>
                                <li class="mt-4">
                                    <h5>Exact match</h5>
                                    <div>Nu trebuie sa se faca nicio &quot;conversie&quot; sau daca se face se considera exact match.
                                        <pre class="block"><code>void f(int& x);
void f(double x);
int x = 42;
f(x); // argument type is int; exact match with int&

/////////////////////////////////////////

void g(int* p);
void g(void* p);

int a[100];
g(a); // calls f(int*); exact match with array-to-pointer conversion</code></pre>
                                    </div>
                                </li>
                                <li class="mt-4">
                                    <h5>Promotion</h5>
                                    <div>Aici intra <i>integral promotion</i> si <i>floating-point promotion</i>. Promotia e un tip special de conversie pentru tipurile de date built-in (<pre class="inline"><code>int</code></pre>, <pre class="inline"><code>float</code></pre> etc.) si este garantat ca nu schimba valoarea. (adica tipul de date la care se converteste poate reprezenta exact orice valoare a tipului de date de la care se converteste)</div>
                                    <div class="text-decoration-underline">Integral promotion</div>
                                    <ul>
                                        <li><pre class="inline"><code>signed char</code></pre> sau <pre class="inline"><code>signed short</code></pre> se pot converti la <pre class="inline"><code>int</code></pre></li>
                                        <li><pre class="inline"><code>unsigned char</code></pre> sau <pre class="inline"><code>unsigned short</code></pre> se pot converti la <pre class="inline"><code>int</code></pre> daca <pre class="inline"><code>int</code></pre> poate retine toate valorile sau la <pre class="inline"><code>unsigned int</code></pre> daca nu poate. (e posibil ca short/char si int sa aiba acelasi nr. de biti pe un calculator si de aceea nu poti din unsigned short/char in int) </li>
                                        <li><pre class="inline"><code>char</code></pre> se poate converti la <pre class="inline"><code>int</code></pre> sau <pre class="inline"><code>unsigned int</code></pre> (depinde daca prin <pre class="inline"><code>char</code></pre> te referi la <pre class="inline"><code>signed char</code></pre> sau <pre class="inline"><code>unsigned char</code></pre>)</li>
                                        <li><pre class="inline"><code>bool</code></pre> se poate converti la <pre class="inline"><code>int</code></pre>, <pre class="inline"><code>false</code></pre> devine <pre class="inline"><code>0</code></pre> iar <pre class="inline"><code>true</code></pre> devine <pre class="inline"><code>1</code></pre></li>
                                    </ul>
                                    <div class="text-decoration-underline">Floating-point promotion</div>
                                    <ul>
                                        <li>Se refera doar la conversia de la <pre class="inline"><code>float</code></pre> la <pre class="inline"><code>double</code></pre>.</li>
                                    </ul>
                                </li>
                                <li class="mt-4">
                                    <h5>Conversion</h5>
                                    <div>
                                        Aici intra <i>integral conversion</i>, <i>floating-point conversion</i>, <i>floating-integral conversion</i>, <i>bool conversion</i>
                                    </div>
                                    <div class="text-decoration-underline">Integral conversion</div>
                                    <ul>
                                        <li>aici intra conversii dintre 2 tipuri de date ce reprezinta nr. intregi dar <b>nu</b> e promotion, de exemplu din <pre class="inline"><code>int</code></pre> in <pre class="inline"><code>long</code></pre> sau din <pre class="inline"><code>unsigned short</code></pre> in <pre class="inline"><code>short</code></pre> </li>
                                    </ul>
                                    <div class="text-decoration-underline">Floating-point conversion</div>
                                    <ul>
                                        <li>aici intra conversii dintre 2 tipuri de date ce reprezinta nr. cu virgula dar <b>nu</b> e promotion, de exemplu din <pre class="inline"><code>double</code></pre> in <pre class="inline"><code>float</code></pre> sau din <pre class="inline"><code>float</code></pre> in <pre class="inline"><code>long double</code></pre>
                                        <div>
                                            <pre class="block"><code>void f(double);
void f(long double);
f(0.0f);</code></pre>
                                            Se apeleaza prima functie pentru ca promotia (de la <pre class="inline"><code>float</code></pre> la <pre class="inline"><code>double</code></pre>) este mai buna decat conversia (de la <pre class="inline"><code>float</code></pre> la  <pre class="inline"><code>long double</code></pre>)
                                        </div>
                                        </li>
                                    </ul>
                                    <div class="text-decoration-underline">Floating-integral conversion</div>
                                    <ul>
                                        <li>aici intra conversii dintre un tip de date ce reprezinta nr. cu virgula si un tip de date care reprezinta nr. intregi de exemplu din <pre class="inline"><code>double</code></pre> in <pre class="inline"><code>int</code></pre> sau din <pre class="inline"><code>int</code></pre> in <pre class="inline"><code>float</code></pre>
                                        <div>
                                            <pre class="block"><code>void f(int);
void f(long double);
f(0.0f);</code></pre>
                                            Eroare de compilare, apelul este ambiguu, avem 2 conversii (de la <pre class="inline"><code>float</code></pre> la <pre class="inline"><code>int</code></pre> si de la <pre class="inline"><code>float</code></pre> la  <pre class="inline"><code>long double</code></pre>  )
                                        </div>
                                        </li>
                                    </ul>
                                    <div class="text-decoration-underline">Bool conversion</div>
                                    <ul>
                                        <li>de exemplu din <pre class="inline"><code>int</code></pre> in <pre class="inline"><code>bool</code></pre> sau din <pre class="inline"><code>float</code></pre> in <pre class="inline"><code>bool</code></pre>. (de ex. <pre class="inline"><code>bool x = 5; // true</code></pre> )
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                    <div>
                        <h3>Surse</h3>
                        <ul>
                            <li><a href="https://en.cppreference.com/w/c/language/conversion">https://en.cppreference.com/w/c/language/conversion</a></li>
                            <li><a href="https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions?view=msvc-160">https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions?view=msvc-160</a></li>
                            <li><a href="https://stackoverflow.com/questions/30490592/no-really-when-does-floating-point-promotion-actually-happen">https://stackoverflow.com/questions/30490592/no-really-when-does-floating-point-promotion-actually-happen</a></li>
                            <li><a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">https://en.cppreference.com/w/cpp/language/implicit_conversion</a></li>
                            <li><a href="https://riptutorial.com/cplusplus/example/8117/steps-of-overload-resolution">https://riptutorial.com/cplusplus/example/8117/steps-of-overload-resolution</a></li>
                            <li><a href="https://riptutorial.com/cplusplus/example/6616/exact-match">https://riptutorial.com/cplusplus/example/6616/exact-match</a></li>
                            <li><a href="https://en.cppreference.com/w/cpp/language/overload_resolution">https://en.cppreference.com/w/cpp/language/overload_resolution</a></li>
                        </ul>
                    </div>
                    </article>
        
                    <article id="operator-overloading" class='mt-4'>
                        <h3 class='my-2 ps-2 rounded'>Supraincarcare operatori</h3>
                        <div class="article-content lead">Lorem ipsum, dolor sit amet consectetur adipisicing elit. Eum maiores ipsa atque deserunt repellendus. Iure cumque cum pariatur id! Dolorem quasi beatae doloremque corrupti ex quae rerum nesciunt veniam laudantium exercitationem, vitae, praesentium veritatis magni eius ipsum molestiae illum expedita, corporis ullam ipsa dicta reprehenderit voluptatibus. Quod perspiciatis unde ea ex possimus commodi, laboriosam reiciendis similique animi saepe. Unde ex recusandae deserunt, quam totam neque corporis reiciendis doloribus beatae harum adipisci similique voluptate omnis consectetur cumque? Voluptate error sapiente esse sint obcaecati nulla consequuntur commodi? Dicta eveniet dolore dolorem quisquam, minus reiciendis modi expedita voluptates consequuntur excepturi debitis ut blanditiis similique consequatur quos neque minima repellendus vero! Deserunt pariatur soluta maxime ab facilis est, a vero culpa cum, sapiente iure adipisci. Dicta adipisci molestias assumenda distinctio aliquam cumque sapiente aspernatur nostrum in dignissimos consectetur sit sed est ipsam, corporis libero nesciunt nobis! Explicabo unde esse ipsam blanditiis fugiat, repudiandae reiciendis libero voluptates harum soluta. Asperiores voluptate amet culpa distinctio sint. Minima saepe perferendis doloribus maiores tenetur corrupti hic at rerum architecto sequi amet voluptas, sapiente nihil, id sunt quidem consequatur! Reiciendis dolorem, natus ipsam repellat quibusdam voluptas tempora eligendi nam repudiandae maxime asperiores voluptates aperiam quo aut ullam? A ea dicta obcaecati cumque consequuntur eum mollitia doloremque possimus facilis sequi fuga, placeat ab sapiente qui ducimus iure nam, id tempora reprehenderit ullam accusamus necessitatibus provident et! Maxime saepe fuga laudantium unde veritatis, voluptatem explicabo necessitatibus aliquid quo natus ea hic asperiores sit esse quam consectetur quidem. Illum fugiat fugit quaerat voluptate nemo exercitationem quis? Obcaecati labore illum necessitatibus natus assumenda, libero dolorum similique hic nobis, quibusdam quasi, sed quisquam magni tempore. Natus saepe quae velit hic, unde a ducimus modi, autem soluta dolorum quis ipsa temporibus alias in! Magnam quia distinctio maxime fugiat eum aperiam ipsam adipisci quasi, quo facere molestias ipsa sed quas aut nobis! Temporibus animi natus voluptatum, perspiciatis amet aspernatur alias illum perferendis quas repudiandae odit minus dolore accusamus vel pariatur dignissimos modi, quaerat quod! Dolorum harum mollitia repellat iure. Natus amet minus neque similique sint officia aut quod, eveniet ratione, animi, numquam unde dignissimos iusto. Beatae adipisci ab, similique omnis voluptatum sequi. Qui, molestiae! Facere nam dolorem, nisi facilis quam excepturi laborum placeat repellat, itaque neque aliquam totam sequi amet adipisci et sed impedit doloribus corrupti possimus deserunt ratione. Consequatur ipsum inventore laboriosam? Magnam, ea magni. Veniam quam aliquam doloribus inventore distinctio autem, consequatur obcaecati cumque sunt ipsam. Non, aut consectetur? Odit numquam voluptatibus deserunt voluptates cum provident id aliquid sequi. Obcaecati quisquam maxime esse, quasi quae iste voluptas? Optio nobis nam maxime corrupti quo est expedita sequi, amet ipsum non totam, numquam veniam! Neque iusto molestiae, quae aut rerum eveniet perspiciatis, voluptate quibusdam veniam aliquam labore quia praesentium possimus fuga quam sunt error repudiandae asperiores dolorem sed totam! Nam, obcaecati corrupti doloremque tempore natus minima sunt consequatur expedita magnam, odit excepturi quam ducimus, et atque beatae facere ipsum! Quidem quo, ab perferendis ratione distinctio animi, ipsam, suscipit fuga laudantium qui alias omnis ut libero debitis?</div>
                    </article>
        
                    <article id="function-overriding" class='mt-4'>
                        <h3 class='my-2 ps-2 rounded'>Supradefinire functii</h3>
                        <div class="article-content lead">Lorem ipsum dolor, sit amet consectetur adipisicing elit. Deleniti, eius provident quos molestiae repellendus eos quibusdam deserunt! Dicta temporibus mollitia voluptate eveniet saepe repellendus debitis praesentium officia vel nam? Commodi assumenda, culpa animi suscipit eveniet labore et, ex error eos voluptatibus nemo cupiditate nihil quasi voluptatum quisquam id quidem at mollitia amet voluptates unde facere provident. Maxime quis voluptatibus, excepturi obcaecati perferendis voluptate. Obcaecati, iste commodi. Quasi ducimus nostrum quae veniam assumenda optio excepturi libero. Odit laborum deserunt voluptates impedit aperiam soluta ut fugiat atque nobis asperiores laboriosam natus culpa aliquam ipsa consequuntur possimus, rerum praesentium iste voluptatum non modi repudiandae aut quia quod. Voluptatem ipsa quo provident exercitationem tempora consectetur veritatis. Ea unde, adipisci deleniti, quo quod laudantium, in incidunt illum eum labore explicabo vero. Non distinctio ullam, repellat impedit cupiditate error aperiam libero quibusdam saepe nostrum ad ea dicta, praesentium sint in iste aspernatur fugiat veniam repudiandae id! Deserunt at nemo deleniti minima minus commodi est asperiores nam odio labore dolorem iusto vel pariatur, modi aut quis amet veritatis rem culpa molestiae, illo repellendus? Quod rerum vero dicta ab voluptatem obcaecati exercitationem. Ut ipsam voluptatem animi. Pariatur sunt quibusdam repudiandae culpa aliquid, quos, asperiores hic minima ipsam optio esse eum nesciunt voluptatum placeat corrupti nisi quo commodi quod ab nam illo minus facilis assumenda? Perspiciatis vero voluptates voluptas rerum optio similique, illum odit suscipit quo eaque cum quas possimus officiis, impedit, eos consectetur. Voluptates ipsam ab eaque a. In quis, alias eligendi minima dolorum recusandae numquam cumque accusantium, labore perferendis sit, incidunt dolores inventore iure modi soluta ab! Ab velit odit modi deserunt consequatur, voluptatum eum quaerat cum tempore, unde delectus in. Vero facilis officia ipsum aliquam rem similique, accusantium quo? Reprehenderit incidunt doloremque aliquam animi beatae illo voluptates, odio officiis corporis eos expedita quia quis natus debitis. Dolor nulla inventore iusto itaque nesciunt ab architecto nisi rerum sapiente exercitationem assumenda, commodi repudiandae, voluptatem aut rem molestias expedita! Laborum illum quibusdam architecto dolores facilis fugiat adipisci dicta? Aut deleniti a minus officia ad eum optio unde voluptatum dolore! Rerum sed quibusdam maxime minima praesentium nisi magnam nam, eos culpa fugit, perferendis quasi voluptates expedita illum deleniti error animi unde. Debitis labore aliquam rerum repellat voluptates accusantium hic aliquid suscipit cumque, at excepturi sequi consequatur ex nesciunt. Harum non cupiditate numquam quas nulla, nisi earum cumque delectus aspernatur soluta quos perspiciatis tempora qui eveniet molestiae, odio asperiores error eius eum doloribus nostrum quaerat? Iure, non ipsa. Id iusto cumque architecto fuga consequatur doloribus labore dolor beatae repellat ipsum quae eaque at vitae, veniam, enim pariatur quibusdam aliquid vero incidunt. Ducimus soluta non quidem odio quo. Iure accusantium vel assumenda ratione cum modi provident voluptatum, fuga labore debitis vero eveniet consequatur minus voluptas totam dicta explicabo dolorem dignissimos iste maxime laudantium distinctio similique minima rerum! Perferendis, amet quaerat doloremque quis omnis necessitatibus rem, quod excepturi eveniet ex inventore voluptatibus delectus aspernatur sequi fuga vel doloribus, officia corrupti ducimus iure. Impedit quia omnis itaque doloremque temporibus veritatis, quae est consequuntur aspernatur!</div>
                    </article>
                </div>
            </section>

            <!-- endl -->
            <section id="endl" class="bg-altlight pt-5 mb-5">
                <div class="container">
                    <h1 class="display-2">Ce face <code>endl</code>?</h1>
                    <article id="s3-a1" class='mt-4'>
                        <div class="article-content lead">
                            <div>
                            Sa scrii intr-un fisier dureaza, pentru ca acel fisier nu este stocat in RAM. Dureaza pana se creeaza o conexiune la harddisk sau ssd ca sa accesezi ce e pe el, asa ca in loc sa scrii cate un byte (caracter) pe rand intr-un fisier, mai bine pui mai multi intr-un loc temporar (buffer) si cand se umple, pui totul in fisier deodata. Asta se intampla si cand scrii ceva intr-un fisier (sau cand citesti) folosind <pre class="inline"><code>fstream</code></pre>.
                        <pre class="block"><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main()
{
    ofstream g(&quot;out.txt&quot;);
    
    g &lt;&lt; &quot;Hello world!&quot;;

    return 0;
}</code></pre>
                        Aici <pre class="inline"><code>&quot;Hello world!&quot;</code></pre> se pune intr-un buffer, un fel de array cu cateva mii de caractere, si cand se umple, continutul lui e pus in fisier (tot deodata). Asta se intampla si cand se apeleaza destructorul pentru obiectul <var>g</var> (pentru ca <var>g</var> este un obiect de tip <pre class="inline"><code>ofstream</code></pre>). Acest lucru se face pentru a se goli bufferul in caz ca s-a scris ceva si nu s-a umplut bufferul. In cazul asta bufferul nu e plin, dar la sfarsitul functiei <var>main</var>, se distruge obiectul <var>g</var> si se scrie in fisier ce mai avea in buffer. Acum daca am avea o eroare dupa <pre class="inline"><code>g &lt;&lt; &quot;Hello world!&quot;;</code></pre>, programul s-ar termina brusc si in fisier nu am mai avea nimic, pentru ca nici bufferul nu s-a umplut, nici destructorul nu a fost apelat.
                        <pre class="block"><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main()
{
    ofstream g(&quot;out.txt&quot;);
    
    g &lt;&lt; &quot;Hello world!&quot;;
    int x = 0;
    cout &lt;&lt; 1 / x; // eroare aici
    return 0;
}</code></pre>  
                        Acum o sa avem o eroare la linia 12, ca impartim la 0. Eroarea asta nu e prinsa si programul se opreste. Fisierul ramane gol (chiar daca avea ceva in el la inceput, cand creezi un obiect de tip <pre class="inline"><code>ofstream</code></pre>, daca nu mai dai alte argumente constructorului, se sterge continutul mai intai). Ok dar daca avem un fisier special unde scriem niste date din program sa tinem evidenta de ceva. Daca avem eroare si nu este prinsa, fisierul nu o sa fie complet, poate ne-ar fi ajutat continutul fisierului sa gasim eroarea. 
                        </div>  
                            <div>
                                Pentru asta exista <pre class="inline"><code>std::flush</code></pre>, care este un manipulator pentru operatii de output (definit in &lt;ostream&gt;), ceva gen <pre class="inline"><code>std::setw()</code></pre>. Daca scrii <pre class="inline"><code>g &lt;&lt; &quot;Hello world!&quot; &lt;&lt; flush;</code></pre> fortezi bufferul sa fie scris in fisier, indiferent daca e plin sau nu. Deci este scris <pre class="inline"><code>&quot;Hello world!&quot;</code></pre> in fisier si dupa avem eroarea, deci la final avem in fisier string-ul. Acum, sa fortezi scrierea bufferului in fisier daca nu e plin nu este deloc eficient, tocmai de asta exista bufferul, ca sa scrii cat mai mult deodata in fisier deci trebuie folosit doar cand ai nevoie.
                            </div>
                            <div>
                                Ce treaba are asta cu <pre class="inline"><code>endl</code></pre>? Poate sti ca <pre class="inline"><code>g &lt;&lt; endl</code></pre> trece la urmatoarea linie, e ca si cum ai scrie <pre class="inline"><code>g &lt;&lt; &quot;\n&quot;;</code></pre> <b>dar pe langa asta face si un flush!</b>, deci e echivalent cu <pre class="inline"><code>g &lt;&lt; &#039;\n&#039; &lt;&lt; flush;</code></pre> (apropo, <pre class="inline"><code>cout &lt;&lt; &quot;\n&quot;;</code></pre> e la fel cu <pre class="inline"><code>cout &lt;&lt; &#039;\n&#039;;</code></pre> doar ca <pre class="inline"><code>&quot;\n&quot;</code></pre> e un sir de caractere si <pre class="inline"><code>&#039;\n&#039;</code></pre> e un caracter, deci mai bine folosesti un caracter)
                            </div>
                            <div>
                                Daca scrii multe linii in fisier si folosesti la fiecare <pre class="inline"><code>endl</code></pre>, o sa ruleze mult mai incet decat daca nu ai folosi <pre class="inline"><code>endl</code></pre> si ai pune <pre class="inline"><code>&#039;\n&#039;</code></pre> pentru linie noua.
                                <pre class="block"><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

void printWithEndl() {
    ofstream g(&quot;out.out&quot;);
    for (int i = 0; i &lt; 100000; ++i) {
        g &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
    }
}

void printNoEndl() {
    ofstream g(&quot;out.out&quot;);
    for (int i = 0; i &lt; 100000; ++i) {
        g &lt;&lt; &quot;Hello world!&quot; &lt;&lt; '\n';
    }
}

int main()
{
    printWithEndl();   // 300 ms

    printNoEndl();     // 18 ms
    return 0;
}</code></pre>              
                            Functiile astea de mai sus printeaza 100000 de linii intr-un fisier. Functia care foloseste <pre class="inline"><code>endl</code></pre> a durat 300ms si cea care nu foloseste a durat 18ms (am facut un test rapid pe calculatorul meu). Diferenta este mai mare de 10 ori (daca marim numarul de linii la 1 milion, diferenta e si mai drastica, 3000ms vs 130ms )
                            </div>
                            <div>
                                Deci, daca vrei ca programul tau sa ruleze mai rapid, nu mai folosi <pre class="inline"><code>endl</code></pre>.
                            </div>
                        </div>
                    </article>
                </div>
            </section>


        </div>


        <!-- scrollspy -->
        <div class="col-3 col-xl-2 bg-dark d-none d-md-block">
            <nav id="scrollspy" class="navbar navbar-dark flex-column align-items-stretch px-3 sticky-top w-100">
                <a class="navbar-brand text-center" href="#">Cuprins</a>
                <nav class="nav nav-pills flex-column">
                    <a class="nav-link py-0 mt-2" href="#overloading-overriding" data-bs-dismiss="offcanvas">Supraincarcare & Supradefinire</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="ms-5 my-1 text-decoration-none" href="#function-overloading"  >Supraincarcare functii</a>
                      <a class="ms-5 my-1 text-decoration-none" href="#operator-overloading" data-bs-dismiss="offcanvas">Supraincarcare operatori</a>
                      <a class="ms-5 my-1 text-decoration-none" href="#function-overriding" data-bs-dismiss="offcanvas">Supradefinire functii</a>
                    </nav>
                    <a class="nav-link py-0 mt-2" href="#endl" data-bs-dismiss="offcanvas">Ce face <code>endl</code>?</a>
                </nav>
            </nav>
        </div>

        
    </div>
</body>
</html>